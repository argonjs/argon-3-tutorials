(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(factory);
	else if(typeof exports === 'object')
		exports["Argon"] = factory();
	else
		root["Argon"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(224);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    /**
	     * Returns true if the object is defined, returns false otherwise.
	     *
	     * @exports defined
	     *
	     * @example
	     * if (Cesium.defined(positions)) {
	     *      doSomething();
	     * } else {
	     *      doSomethingElse();
	     * }
	     */
	    var defined = function(value) {
	        return value !== undefined;
	    };

	    return defined;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined) {
	    "use strict";

	    /**
	     * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
	     * argument out of range, etc.  This exception should only be thrown during development;
	     * it usually indicates a bug in the calling code.  This exception should never be
	     * caught; instead the calling code should strive not to generate it.
	     * <br /><br />
	     * On the other hand, a {@link RuntimeError} indicates an exception that may
	     * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
	     * to catch.
	     *
	     * @alias DeveloperError
	     * @constructor
	     *
	     * @param {String} [message] The error message for this exception.
	     *
	     * @see RuntimeError
	     */
	    var DeveloperError = function(message) {
	        /**
	         * 'DeveloperError' indicating that this exception was thrown due to a developer error.
	         * @type {String}
	         * @readonly
	         */
	        this.name = 'DeveloperError';

	        /**
	         * The explanation for why this exception was thrown.
	         * @type {String}
	         * @readonly
	         */
	        this.message = message;

	        //Browsers such as IE don't have a stack property until you actually throw the error.
	        var stack;
	        try {
	            throw new Error();
	        } catch (e) {
	            stack = e.stack;
	        }

	        /**
	         * The stack trace of this exception, if available.
	         * @type {String}
	         * @readonly
	         */
	        this.stack = stack;
	    };

	    DeveloperError.prototype.toString = function() {
	        var str = this.name + ': ' + this.message;

	        if (defined(this.stack)) {
	            str += '\n' + this.stack.toString();
	        }

	        return str;
	    };

	    /**
	     * @private
	     */
	    DeveloperError.throwInstantiationError = function() {
	        throw new DeveloperError('This function defines an interface and should not be called directly.');
	    };

	    return DeveloperError;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Returns the first parameter if not undefined, otherwise the second parameter.
	     * Useful for setting a default value for a parameter.
	     *
	     * @exports defaultValue
	     *
	     * @example
	     * param = Cesium.defaultValue(param, 'default');
	     */
	    var defaultValue = function(a, b) {
	        if (a !== undefined) {
	            return a;
	        }
	        return b;
	    };

	    /**
	     * A frozen empty object that can be used as the default value for options passed as
	     * an object literal.
	     */
	    defaultValue.EMPTY_OBJECT = freezeObject({});

	    return defaultValue;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined) {
	    "use strict";

	    var definePropertyWorks = (function() {
	        try {
	            return 'x' in Object.defineProperty({}, 'x', {});
	        } catch (e) {
	            return false;
	        }
	    })();

	    /**
	     * Defines properties on an object, using Object.defineProperties if available,
	     * otherwise returns the object unchanged.  This function should be used in
	     * setup code to prevent errors from completely halting JavaScript execution
	     * in legacy browsers.
	     *
	     * @private
	     *
	     * @exports defineProperties
	     */
	    var defineProperties = Object.defineProperties;
	    if (!definePropertyWorks || !defined(defineProperties)) {
	        defineProperties = function(o) {
	            return o;
	        };
	    }

	    return defineProperties;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global = typeof self != 'undefined' ? self : Function('return this')()
	  , core   = {}
	  , defineProperty = Object.defineProperty
	  , hasOwnProperty = {}.hasOwnProperty
	  , ceil  = Math.ceil
	  , floor = Math.floor
	  , max   = Math.max
	  , min   = Math.min;
	// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
	var DESC = !!function(){
	  try {
	    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;
	  } catch(e){ /* empty */ }
	}();
	var hide = createDefiner(1);
	// 7.1.4 ToInteger
	function toInteger(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	}
	function desc(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	}
	function simpleSet(object, key, value){
	  object[key] = value;
	  return object;
	}
	function createDefiner(bitmap){
	  return DESC ? function(object, key, value){
	    return $.setDesc(object, key, desc(bitmap, value));
	  } : simpleSet;
	}

	function isObject(it){
	  return it !== null && (typeof it == 'object' || typeof it == 'function');
	}
	function isFunction(it){
	  return typeof it == 'function';
	}
	function assertDefined(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	}

	var $ = module.exports = __webpack_require__(72)({
	  g: global,
	  core: core,
	  html: global.document && document.documentElement,
	  // http://jsperf.com/core-js-isobject
	  isObject:   isObject,
	  isFunction: isFunction,
	  it: function(it){
	    return it;
	  },
	  that: function(){
	    return this;
	  },
	  // 7.1.4 ToInteger
	  toInteger: toInteger,
	  // 7.1.15 ToLength
	  toLength: function(it){
	    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	  },
	  toIndex: function(index, length){
	    index = toInteger(index);
	    return index < 0 ? max(index + length, 0) : min(index, length);
	  },
	  has: function(it, key){
	    return hasOwnProperty.call(it, key);
	  },
	  create:     Object.create,
	  getProto:   Object.getPrototypeOf,
	  DESC:       DESC,
	  desc:       desc,
	  getDesc:    Object.getOwnPropertyDescriptor,
	  setDesc:    defineProperty,
	  setDescs:   Object.defineProperties,
	  getKeys:    Object.keys,
	  getNames:   Object.getOwnPropertyNames,
	  getSymbols: Object.getOwnPropertySymbols,
	  assertDefined: assertDefined,
	  // Dummy, fix for not array-like ES3 string in es5 module
	  ES5Object: Object,
	  toObject: function(it){
	    return $.ES5Object(assertDefined(it));
	  },
	  hide: hide,
	  def: createDefiner(0),
	  set: global.Symbol ? simpleSet : hide,
	  mix: function(target, src){
	    for(var key in src)hide(target, key, src[key]);
	    return target;
	  },
	  each: [].forEach
	});
	/* eslint-disable no-undef */
	if(typeof __e != 'undefined')__e = core;
	if(typeof __g != 'undefined')__g = global;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError) {
	    "use strict";

	    /**
	     * A generic utility class for managing subscribers for a particular event.
	     * This class is usually instantiated inside of a container class and
	     * exposed as a property for others to subscribe to.
	     *
	     * @alias Event
	     * @constructor
	     *
	     * @example
	     * MyObject.prototype.myListener = function(arg1, arg2) {
	     *     this.myArg1Copy = arg1;
	     *     this.myArg2Copy = arg2;
	     * }
	     *
	     * var myObjectInstance = new MyObject();
	     * var evt = new Cesium.Event();
	     * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
	     * evt.raiseEvent('1', '2');
	     * evt.removeEventListener(MyObject.prototype.myListener);
	     */
	    var Event = function() {
	        this._listeners = [];
	        this._scopes = [];
	        this._toRemove = [];
	        this._insideRaiseEvent = false;
	    };

	    defineProperties(Event.prototype, {
	        /**
	         * The number of listeners currently subscribed to the event.
	         * @memberof Event.prototype
	         * @type {Number}
	         */
	        numberOfListeners : {
	            get : function() {
	                return this._listeners.length - this._toRemove.length;
	            }
	        }
	    });

	    /**
	     * Registers a callback function to be executed whenever the event is raised.
	     * An optional scope can be provided to serve as the <code>this</code> pointer
	     * in which the function will execute.
	     *
	     * @param {Function} listener The function to be executed when the event is raised.
	     * @param {Object} [scope] An optional object scope to serve as the <code>this</code>
	     *        pointer in which the listener function will execute.
	     * @returns {Event~RemoveCallback} A function that will remove this event listener when invoked.
	     *
	     * @see Event#raiseEvent
	     * @see Event#removeEventListener
	     */
	    Event.prototype.addEventListener = function(listener, scope) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof listener !== 'function') {
	            throw new DeveloperError('listener is required and must be a function.');
	        }
	        //>>includeEnd('debug');

	        this._listeners.push(listener);
	        this._scopes.push(scope);

	        var event = this;
	        return function() {
	            event.removeEventListener(listener, scope);
	        };
	    };

	    /**
	     * Unregisters a previously registered callback.
	     *
	     * @param {Function} listener The function to be unregistered.
	     * @param {Object} [scope] The scope that was originally passed to addEventListener.
	     * @returns {Boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.
	     *
	     * @see Event#addEventListener
	     * @see Event#raiseEvent
	     */
	    Event.prototype.removeEventListener = function(listener, scope) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof listener !== 'function') {
	            throw new DeveloperError('listener is required and must be a function.');
	        }
	        //>>includeEnd('debug');

	        var listeners = this._listeners;
	        var scopes = this._scopes;

	        var index = -1;
	        for (var i = 0; i < listeners.length; i++) {
	            if (listeners[i] === listener && scopes[i] === scope) {
	                index = i;
	                break;
	            }
	        }

	        if (index !== -1) {
	            if (this._insideRaiseEvent) {
	                //In order to allow removing an event subscription from within
	                //a callback, we don't actually remove the items here.  Instead
	                //remember the index they are at and undefined their value.
	                this._toRemove.push(index);
	                listeners[index] = undefined;
	                scopes[index] = undefined;
	            } else {
	                listeners.splice(index, 1);
	                scopes.splice(index, 1);
	            }
	            return true;
	        }

	        return false;
	    };

	    /**
	     * Raises the event by calling each registered listener with all supplied arguments.
	     *
	     * @param {*} arguments This method takes any number of parameters and passes them through to the listener functions.
	     *
	     * @see Event#addEventListener
	     * @see Event#removeEventListener
	     */
	    Event.prototype.raiseEvent = function() {
	        this._insideRaiseEvent = true;

	        var i;
	        var listeners = this._listeners;
	        var scopes = this._scopes;
	        var length = listeners.length;

	        for (i = 0; i < length; i++) {
	            var listener = listeners[i];
	            if (defined(listener)) {
	                listeners[i].apply(scopes[i], arguments);
	            }
	        }

	        //Actually remove items removed in removeEventListener.
	        var toRemove = this._toRemove;
	        length = toRemove.length;
	        for (i = 0; i < length; i++) {
	            var index = toRemove[i];
	            listeners.splice(index, 1);
	            scopes.splice(index, 1);
	        }
	        toRemove.length = 0;

	        this._insideRaiseEvent = false;
	    };

	    /**
	     * A function that removes a listener.
	     * @callback Event~RemoveCallback
	     */

	    return Event;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined) {
	    "use strict";

	    /**
	     * Freezes an object, using Object.freeze if available, otherwise returns
	     * the object unchanged.  This function should be used in setup code to prevent
	     * errors from completely halting JavaScript execution in legacy browsers.
	     *
	     * @private
	     *
	     * @exports freezeObject
	     */
	    var freezeObject = Object.freeze;
	    if (!defined(freezeObject)) {
	        freezeObject = function(o) {
	            return o;
	        };
	    }

	    return freezeObject;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(56)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        ConstantProperty) {
	    "use strict";

	    function createProperty(name, privateName, subscriptionName, configurable, createPropertyCallback) {
	        return {
	            configurable : configurable,
	            get : function() {
	                return this[privateName];
	            },
	            set : function(value) {
	                var oldValue = this[privateName];
	                var subscription = this[subscriptionName];
	                if (defined(subscription)) {
	                    subscription();
	                    this[subscriptionName] = undefined;
	                }

	                var hasValue = defined(value);
	                if (hasValue && !defined(value.getValue) && defined(createPropertyCallback)) {
	                    value = createPropertyCallback(value);
	                }

	                if (oldValue !== value) {
	                    this[privateName] = value;
	                    this._definitionChanged.raiseEvent(this, name, value, oldValue);
	                }

	                if (defined(value) && defined(value.definitionChanged)) {
	                    this[subscriptionName] = value.definitionChanged.addEventListener(function() {
	                        this._definitionChanged.raiseEvent(this, name, value, value);
	                    }, this);
	                }
	            }
	        };
	    }

	    function createConstantProperty(value) {
	        return new ConstantProperty(value);
	    }

	    /**
	     * Used to consistently define all DataSources graphics objects.
	     * This is broken into two functions because the Chrome profiler does a better
	     * job of optimizing lookups if it notices that the string is constant throughout the function.
	     * @private
	     */
	    function createPropertyDescriptor(name, configurable, createPropertyCallback) {
	        //Safari 8.0.3 has a JavaScript bug that causes it to confuse two variables and treat them as the same.
	        //The two extra toString calls work around the issue.
	        return createProperty(name, '_' + name.toString(), '_' + name.toString() + 'Subscription', defaultValue(configurable, false), defaultValue(createPropertyCallback, createConstantProperty));
	    }

	    return createPropertyDescriptor;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(76)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Iso8601) {
	    "use strict";

	    /**
	     * The interface for all properties, which represent a value that can optionally vary over time.
	     * This type defines an interface and cannot be instantiated directly.
	     *
	     * @alias Property
	     * @constructor
	     *
	     * @see CompositeProperty
	     * @see ConstantProperty
	     * @see SampledProperty
	     * @see TimeIntervalCollectionProperty
	     * @see MaterialProperty
	     * @see PositionProperty
	     * @see ReferenceProperty
	     */
	    var Property = function() {
	        DeveloperError.throwInstantiationError();
	    };

	    defineProperties(Property.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof Property.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof Property.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : DeveloperError.throwInstantiationError
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time.
	     * @function
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    Property.prototype.getValue = DeveloperError.throwInstantiationError;

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     * @function
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Property.prototype.equals = DeveloperError.throwInstantiationError;

	    /**
	     * @private
	     */
	    Property.equals = function(left, right) {
	        return left === right || (defined(left) && left.equals(right));
	    };

	    /**
	     * @private
	     */
	    Property.arrayEquals = function(left, right) {
	        if (left === right) {
	            return true;
	        }
	        if ((!defined(left) || !defined(right)) || (left.length !== right.length)) {
	            return false;
	        }
	        var length = left.length;
	        for (var i = 0; i < length; i++) {
	            if (!Property.equals(left[i], right[i])) {
	                return false;
	            }
	        }
	        return true;
	    };

	    /**
	     * @private
	     */
	    Property.isConstant = function(property) {
	        return !defined(property) || property.isConstant;
	    };

	    /**
	     * @private
	     */
	    Property.getValueOrUndefined = function(property, time, result) {
	        return defined(property) ? property.getValue(time, result) : undefined;
	    };

	    /**
	     * @private
	     */
	    Property.getValueOrDefault = function(property, time, valueDefault, result) {
	        return defined(property) ? defaultValue(property.getValue(time, result), valueDefault) : valueDefault;
	    };

	    /**
	     * @private
	     */
	    Property.getValueOrClonedDefault = function(property, time, valueDefault, result) {
	        var value;
	        if (defined(property)) {
	            value = property.getValue(time, result);
	        }
	        if (!defined(value)) {
	            value = valueDefault.clone(value);
	        }
	        return value;
	    };

	    return Property;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(206),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        MersenneTwister,
	        defaultValue,
	        defined,
	        DeveloperError) {
	    "use strict";

	    /**
	     * Math functions.
	     *
	     * @namespace
	     * @alias CesiumMath
	     */
	    var CesiumMath = {};

	    /**
	     * 0.1
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON1 = 0.1;

	    /**
	     * 0.01
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON2 = 0.01;

	    /**
	     * 0.001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON3 = 0.001;

	    /**
	     * 0.0001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON4 = 0.0001;

	    /**
	     * 0.00001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON5 = 0.00001;

	    /**
	     * 0.000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON6 = 0.000001;

	    /**
	     * 0.0000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON7 = 0.0000001;

	    /**
	     * 0.00000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON8 = 0.00000001;

	    /**
	     * 0.000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON9 = 0.000000001;

	    /**
	     * 0.0000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON10 = 0.0000000001;

	    /**
	     * 0.00000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON11 = 0.00000000001;

	    /**
	     * 0.000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON12 = 0.000000000001;

	    /**
	     * 0.0000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON13 = 0.0000000000001;

	    /**
	     * 0.00000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON14 = 0.00000000000001;

	    /**
	     * 0.000000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON15 = 0.000000000000001;

	    /**
	     * 0.0000000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON16 = 0.0000000000000001;

	    /**
	     * 0.00000000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON17 = 0.00000000000000001;

	    /**
	     * 0.000000000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON18 = 0.000000000000000001;

	    /**
	     * 0.0000000000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON19 = 0.0000000000000000001;

	    /**
	     * 0.00000000000000000001
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.EPSILON20 = 0.00000000000000000001;

	    /**
	     * 3.986004418e14
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;

	    /**
	     * Radius of the sun in meters: 6.955e8
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.SOLAR_RADIUS = 6.955e8;

	    /**
	     * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
	     * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
	     * Celestial Mechanics 82: 83-110, 2002.
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.LUNAR_RADIUS = 1737400.0;

	    /**
	     * 64 * 1024
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;

	    /**
	     * Returns the sign of the value; 1 if the value is positive, -1 if the value is
	     * negative, or 0 if the value is 0.
	     *
	     * @param {Number} value The value to return the sign of.
	     * @returns {Number} The sign of value.
	     */
	    CesiumMath.sign = function(value) {
	        if (value > 0) {
	            return 1;
	        }
	        if (value < 0) {
	            return -1;
	        }

	        return 0;
	    };

	    /**
	     * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
	     * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of
	     * 0.0 when the input value is 0.0.
	     * @param {Number} value The value to return the sign of.
	     * @returns {Number} The sign of value.
	     */
	    CesiumMath.signNotZero = function(value) {
	        return value < 0.0 ? -1.0 : 1.0;
	    };

	    /**
	     * Converts a scalar value in the range [-1.0, 1.0] to a 8-bit 2's complement number.
	     * @param {Number} value The scalar value in the range [-1.0, 1.0]
	     * @returns {Number} The 8-bit 2's complement number, where 0 maps to -1.0 and 255 maps to 1.0.
	     *
	     * @see CesiumMath.fromSNorm
	     */
	    CesiumMath.toSNorm = function(value) {
	        return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * 255.0);
	    };

	    /**
	     * Converts a SNORM value in the range [0, 255] to a scalar in the range [-1.0, 1.0].
	     * @param {Number} value SNORM value in the range [0, 255]
	     * @returns {Number} Scalar in the range [-1.0, 1.0].
	     *
	     * @see CesiumMath.toSNorm
	     */
	    CesiumMath.fromSNorm = function(value) {
	        return CesiumMath.clamp(value, 0.0, 255.0) / 255.0 * 2.0 - 1.0;
	    };

	    /**
	     * Returns the hyperbolic sine of a number.
	     * The hyperbolic sine of <em>value</em> is defined to be
	     * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
	     * where <i>e</i> is Euler's number, approximately 2.71828183.
	     *
	     * <p>Special cases:
	     *   <ul>
	     *     <li>If the argument is NaN, then the result is NaN.</li>
	     *
	     *     <li>If the argument is infinite, then the result is an infinity
	     *     with the same sign as the argument.</li>
	     *
	     *     <li>If the argument is zero, then the result is a zero with the
	     *     same sign as the argument.</li>
	     *   </ul>
	     *</p>
	     *
	     * @param {Number} value The number whose hyperbolic sine is to be returned.
	     * @returns The hyperbolic sine of <code>value</code>.
	     */
	    CesiumMath.sinh = function(value) {
	        var part1 = Math.pow(Math.E, value);
	        var part2 = Math.pow(Math.E, -1.0 * value);

	        return (part1 - part2) * 0.5;
	    };

	    /**
	     * Returns the hyperbolic cosine of a number.
	     * The hyperbolic cosine of <strong>value</strong> is defined to be
	     * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
	     * where <i>e</i> is Euler's number, approximately 2.71828183.
	     *
	     * <p>Special cases:
	     *   <ul>
	     *     <li>If the argument is NaN, then the result is NaN.</li>
	     *
	     *     <li>If the argument is infinite, then the result is positive infinity.</li>
	     *
	     *     <li>If the argument is zero, then the result is 1.0.</li>
	     *   </ul>
	     *</p>
	     *
	     * @param {Number} value The number whose hyperbolic cosine is to be returned.
	     * @returns The hyperbolic cosine of <code>value</code>.
	     */
	    CesiumMath.cosh = function(value) {
	        var part1 = Math.pow(Math.E, value);
	        var part2 = Math.pow(Math.E, -1.0 * value);

	        return (part1 + part2) * 0.5;
	    };

	    /**
	     * Computes the linear interpolation of two values.
	     *
	     * @param {Number} p The start value to interpolate.
	     * @param {Number} q The end value to interpolate.
	     * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
	     * @returns {Number} The linearly interpolated value.
	     *
	     * @example
	     * var n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
	     */
	    CesiumMath.lerp = function(p, q, time) {
	        return ((1.0 - time) * p) + (time * q);
	    };

	    /**
	     * pi
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.PI = Math.PI;

	    /**
	     * 1/pi
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;

	    /**
	     * pi/2
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.PI_OVER_TWO = Math.PI * 0.5;

	    /**
	     * pi/3
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.PI_OVER_THREE = Math.PI / 3.0;

	    /**
	     * pi/4
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;

	    /**
	     * pi/6
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.PI_OVER_SIX = Math.PI / 6.0;

	    /**
	     * 3pi/2
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) * 0.5;

	    /**
	     * 2pi
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.TWO_PI = 2.0 * Math.PI;

	    /**
	     * 1/2pi
	     *
	     * @type {Number}
	     * @constant
	     */
	    CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);

	    /**
	     * The number of radians in a degree.
	     *
	     * @type {Number}
	     * @constant
	     * @default Math.PI / 180.0
	     */
	    CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;

	    /**
	     * The number of degrees in a radian.
	     *
	     * @type {Number}
	     * @constant
	     * @default 180.0 / Math.PI
	     */
	    CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;

	    /**
	     * The number of radians in an arc second.
	     *
	     * @type {Number}
	     * @constant
	     * @default {@link CesiumMath.RADIANS_PER_DEGREE} / 3600.0
	     */
	    CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;

	    /**
	     * Converts degrees to radians.
	     * @param {Number} degrees The angle to convert in degrees.
	     * @returns {Number} The corresponding angle in radians.
	     */
	    CesiumMath.toRadians = function(degrees) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(degrees)) {
	            throw new DeveloperError('degrees is required.');
	        }
	        //>>includeEnd('debug');
	        return degrees * CesiumMath.RADIANS_PER_DEGREE;
	    };

	    /**
	     * Converts radians to degrees.
	     * @param {Number} radians The angle to convert in radians.
	     * @returns {Number} The corresponding angle in degrees.
	     */
	    CesiumMath.toDegrees = function(radians) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(radians)) {
	            throw new DeveloperError('radians is required.');
	        }
	        //>>includeEnd('debug');
	        return radians * CesiumMath.DEGREES_PER_RADIAN;
	    };

	    /**
	     * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
	     *
	     * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
	     * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
	     *
	     * @example
	     * // Convert 270 degrees to -90 degrees longitude
	     * var longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));
	     */
	    CesiumMath.convertLongitudeRange = function(angle) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(angle)) {
	            throw new DeveloperError('angle is required.');
	        }
	        //>>includeEnd('debug');
	        var twoPi = CesiumMath.TWO_PI;

	        var simplified = angle - Math.floor(angle / twoPi) * twoPi;

	        if (simplified < -Math.PI) {
	            return simplified + twoPi;
	        }
	        if (simplified >= Math.PI) {
	            return simplified - twoPi;
	        }

	        return simplified;
	    };

	    /**
	     * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
	     *
	     * @param {Number} angle in radians
	     * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].
	     */
	    CesiumMath.negativePiToPi = function(x) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(x)) {
	            throw new DeveloperError('x is required.');
	        }
	        //>>includeEnd('debug');
	        return CesiumMath.zeroToTwoPi(x + CesiumMath.PI) - CesiumMath.PI;
	    };

	    /**
	     * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
	     *
	     * @param {Number} angle in radians
	     * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].
	     */
	    CesiumMath.zeroToTwoPi = function(x) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(x)) {
	            throw new DeveloperError('x is required.');
	        }
	        //>>includeEnd('debug');
	        var mod = CesiumMath.mod(x, CesiumMath.TWO_PI);
	        if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(x) > CesiumMath.EPSILON14) {
	            return CesiumMath.TWO_PI;
	        }
	        return mod;
	    };

	    /**
	     * The modulo operation that also works for negative dividends.
	     *
	     * @param {Number} m The dividend.
	     * @param {Number} n The divisor.
	     * @returns {Number} The remainder.
	     */
	    CesiumMath.mod = function(m, n) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(m)) {
	            throw new DeveloperError('m is required.');
	        }
	        if (!defined(n)) {
	            throw new DeveloperError('n is required.');
	        }
	        //>>includeEnd('debug');
	        return ((m % n) + n) % n;
	    };

	    /**
	     * Determines if two values are equal using an absolute or relative tolerance test. This is useful
	     * to avoid problems due to roundoff error when comparing floating-point values directly. The values are
	     * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
	     * Use this test if you are unsure of the magnitudes of left and right.
	     *
	     * @param {Number} left The first value to compare.
	     * @param {Number} right The other value to compare.
	     * @param {Number} relativeEpsilon The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
	     * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
	     * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.
	     *
	     * @example
	     * var a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true
	     * var b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false
	     * var c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true
	     * var d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false
	     */
	    CesiumMath.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required.');
	        }
	        if (!defined(relativeEpsilon)) {
	            throw new DeveloperError('relativeEpsilon is required.');
	        }
	        //>>includeEnd('debug');
	        absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);
	        var absDiff = Math.abs(left - right);
	        return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));
	    };

	    var factorials = [1];

	    /**
	     * Computes the factorial of the provided number.
	     *
	     * @param {Number} n The number whose factorial is to be computed.
	     * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.
	     *
	     * @exception {DeveloperError} A number greater than or equal to 0 is required.
	     *
	     * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}
	     *
	     * @example
	     * //Compute 7!, which is equal to 5040
	     * var computedFactorial = Cesium.Math.factorial(7);
	     */
	    CesiumMath.factorial = function(n) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof n !== 'number' || n < 0) {
	            throw new DeveloperError('A number greater than or equal to 0 is required.');
	        }
	        //>>includeEnd('debug');

	        var length = factorials.length;
	        if (n >= length) {
	            var sum = factorials[length - 1];
	            for (var i = length; i <= n; i++) {
	                factorials.push(sum * i);
	            }
	        }
	        return factorials[n];
	    };

	    /**
	     * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
	     *
	     * @param {Number} [n] The number to be incremented.
	     * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.
	     * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.
	     * @returns {Number} The incremented number.
	     *
	     * @exception {DeveloperError} Maximum value must be greater than minimum value.
	     *
	     * @example
	     * var n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6
	     * var n = Cesium.Math.incrementWrap(10, 10, 0); // returns 0
	     */
	    CesiumMath.incrementWrap = function(n, maximumValue, minimumValue) {
	        minimumValue = defaultValue(minimumValue, 0.0);

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(n)) {
	            throw new DeveloperError('n is required.');
	        }
	        if (maximumValue <= minimumValue) {
	            throw new DeveloperError('maximumValue must be greater than minimumValue.');
	        }
	        //>>includeEnd('debug');

	        ++n;
	        if (n > maximumValue) {
	            n = minimumValue;
	        }
	        return n;
	    };

	    /**
	     * Determines if a positive integer is a power of two.
	     *
	     * @param {Number} n The positive integer to test.
	     * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
	     *
	     * @exception {DeveloperError} A number greater than or equal to 0 is required.
	     *
	     * @example
	     * var t = Cesium.Math.isPowerOfTwo(16); // true
	     * var f = Cesium.Math.isPowerOfTwo(20); // false
	     */
	    CesiumMath.isPowerOfTwo = function(n) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof n !== 'number' || n < 0) {
	            throw new DeveloperError('A number greater than or equal to 0 is required.');
	        }
	        //>>includeEnd('debug');

	        return (n !== 0) && ((n & (n - 1)) === 0);
	    };

	    /**
	     * Computes the next power-of-two integer greater than or equal to the provided positive integer.
	     *
	     * @param {Number} n The positive integer to test.
	     * @returns {Number} The next power-of-two integer.
	     *
	     * @exception {DeveloperError} A number greater than or equal to 0 is required.
	     *
	     * @example
	     * var n = Cesium.Math.nextPowerOfTwo(29); // 32
	     * var m = Cesium.Math.nextPowerOfTwo(32); // 32
	     */
	    CesiumMath.nextPowerOfTwo = function(n) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof n !== 'number' || n < 0) {
	            throw new DeveloperError('A number greater than or equal to 0 is required.');
	        }
	        //>>includeEnd('debug');

	        // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
	        --n;
	        n |= n >> 1;
	        n |= n >> 2;
	        n |= n >> 4;
	        n |= n >> 8;
	        n |= n >> 16;
	        ++n;

	        return n;
	    };

	    /**
	     * Constraint a value to lie between two values.
	     *
	     * @param {Number} value The value to constrain.
	     * @param {Number} min The minimum value.
	     * @param {Number} max The maximum value.
	     * @returns {Number} The value clamped so that min <= value <= max.
	     */
	    CesiumMath.clamp = function(value, min, max) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }
	        if (!defined(min)) {
	            throw new DeveloperError('min is required.');
	        }
	        if (!defined(max)) {
	            throw new DeveloperError('max is required.');
	        }
	        //>>includeEnd('debug');
	        return value < min ? min : value > max ? max : value;
	    };

	    var randomNumberGenerator = new MersenneTwister();

	    /**
	     * Sets the seed used by the random number generator
	     * in {@link CesiumMath#nextRandomNumber}.
	     *
	     * @param {Number} seed An integer used as the seed.
	     */
	    CesiumMath.setRandomNumberSeed = function(seed) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(seed)) {
	            throw new DeveloperError('seed is required.');
	        }
	        //>>includeEnd('debug');

	        randomNumberGenerator = new MersenneTwister(seed);
	    };

	    /**
	     * Generates a random number in the range of [0.0, 1.0)
	     * using a Mersenne twister.
	     *
	     * @returns {Number} A random number in the range of [0.0, 1.0).
	     *
	     * @see CesiumMath.setRandomNumberSeed
	     * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}
	     */
	    CesiumMath.nextRandomNumber = function() {
	        return randomNumberGenerator.random();
	    };

	    /**
	     * Computes <code>Math.acos(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]
	     * so that the function will never return NaN.
	     *
	     * @param {Number} value The value for which to compute acos.
	     * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,
	     *          whichever is closer, if the value is outside the range.
	     */
	    CesiumMath.acosClamped = function(value) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required.');
	        }
	        //>>includeEnd('debug');
	        return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));
	    };

	    /**
	     * Computes <code>Math.asin(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]
	     * so that the function will never return NaN.
	     *
	     * @param {Number} value The value for which to compute asin.
	     * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,
	     *          whichever is closer, if the value is outside the range.
	     */
	    CesiumMath.asinClamped = function(value) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required.');
	        }
	        //>>includeEnd('debug');
	        return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));
	    };

	    /**
	     * Finds the chord length between two points given the circle's radius and the angle between the points.
	     *
	     * @param {Number} angle The angle between the two points.
	     * @param {Number} radius The radius of the circle.
	     * @returns {Number} The chord length.
	     */
	    CesiumMath.chordLength = function(angle, radius) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(angle)) {
	            throw new DeveloperError('angle is required.');
	        }
	        if (!defined(radius)) {
	            throw new DeveloperError('radius is required.');
	        }
	        //>>includeEnd('debug');
	        return 2.0 * radius * Math.sin(angle * 0.5);
	    };

	    return CesiumMath;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    /**
	     * A 3D Cartesian point.
	     * @alias Cartesian3
	     * @constructor
	     *
	     * @param {Number} [x=0.0] The X component.
	     * @param {Number} [y=0.0] The Y component.
	     * @param {Number} [z=0.0] The Z component.
	     *
	     * @see Cartesian2
	     * @see Cartesian4
	     * @see Packable
	     */
	    var Cartesian3 = function(x, y, z) {
	        /**
	         * The X component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.x = defaultValue(x, 0.0);

	        /**
	         * The Y component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.y = defaultValue(y, 0.0);

	        /**
	         * The Z component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.z = defaultValue(z, 0.0);
	    };

	    /**
	     * Converts the provided Spherical into Cartesian3 coordinates.
	     *
	     * @param {Spherical} spherical The Spherical to be converted to Cartesian3.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	     */
	    Cartesian3.fromSpherical = function(spherical, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(spherical)) {
	            throw new DeveloperError('spherical is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            result = new Cartesian3();
	        }

	        var clock = spherical.clock;
	        var cone = spherical.cone;
	        var magnitude = defaultValue(spherical.magnitude, 1.0);
	        var radial = magnitude * Math.sin(cone);
	        result.x = radial * Math.cos(clock);
	        result.y = radial * Math.sin(clock);
	        result.z = magnitude * Math.cos(cone);
	        return result;
	    };

	    /**
	     * Creates a Cartesian3 instance from x, y and z coordinates.
	     *
	     * @param {Number} x The x coordinate.
	     * @param {Number} y The y coordinate.
	     * @param {Number} z The z coordinate.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	     */
	    Cartesian3.fromElements = function(x, y, z, result) {
	        if (!defined(result)) {
	            return new Cartesian3(x, y, z);
	        }

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Duplicates a Cartesian3 instance.
	     *
	     * @param {Cartesian3} cartesian The Cartesian to duplicate.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)
	     */
	    Cartesian3.clone = function(cartesian, result) {
	        if (!defined(cartesian)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
	        }

	        result.x = cartesian.x;
	        result.y = cartesian.y;
	        result.z = cartesian.z;
	        return result;
	    };

	    /**
	     * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
	     * x, y, and z properties of the Cartesian4 and drops w.
	     * @function
	     *
	     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	     */
	    Cartesian3.fromCartesian4 = Cartesian3.clone;

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Cartesian3.packedLength = 3;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Cartesian3} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Cartesian3.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }

	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value.x;
	        array[startingIndex++] = value.y;
	        array[startingIndex] = value.z;
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Cartesian3} [result] The object into which to store the result.
	     */
	    Cartesian3.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Cartesian3();
	        }
	        result.x = array[startingIndex++];
	        result.y = array[startingIndex++];
	        result.z = array[startingIndex];
	        return result;
	    };

	    /**
	     * Creates a Cartesian3 from three consecutive elements in an array.
	     * @function
	     *
	     * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.
	     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	     *
	     * @example
	     * // Create a Cartesian3 with (1.0, 2.0, 3.0)
	     * var v = [1.0, 2.0, 3.0];
	     * var p = Cesium.Cartesian3.fromArray(v);
	     *
	     * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array
	     * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];
	     * var p2 = Cesium.Cartesian3.fromArray(v2, 2);
	     */
	    Cartesian3.fromArray = Cartesian3.unpack;

	    /**
	     * Computes the value of the maximum component for the supplied Cartesian.
	     *
	     * @param {Cartesian3} cartesian The cartesian to use.
	     * @returns {Number} The value of the maximum component.
	     */
	    Cartesian3.maximumComponent = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return Math.max(cartesian.x, cartesian.y, cartesian.z);
	    };

	    /**
	     * Computes the value of the minimum component for the supplied Cartesian.
	     *
	     * @param {Cartesian3} cartesian The cartesian to use.
	     * @returns {Number} The value of the minimum component.
	     */
	    Cartesian3.minimumComponent = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return Math.min(cartesian.x, cartesian.y, cartesian.z);
	    };

	    /**
	     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
	     *
	     * @param {Cartesian3} first A cartesian to compare.
	     * @param {Cartesian3} second A cartesian to compare.
	     * @param {Cartesian3} result The object into which to store the result.
	     * @returns {Cartesian3} A cartesian with the minimum components.
	     */
	    Cartesian3.minimumByComponent = function(first, second, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(first)) {
	            throw new DeveloperError('first is required.');
	        }
	        if (!defined(second)) {
	            throw new DeveloperError('second is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.min(first.x, second.x);
	        result.y = Math.min(first.y, second.y);
	        result.z = Math.min(first.z, second.z);

	        return result;
	    };

	    /**
	     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
	     *
	     * @param {Cartesian3} first A cartesian to compare.
	     * @param {Cartesian3} second A cartesian to compare.
	     * @param {Cartesian3} result The object into which to store the result.
	     * @returns {Cartesian3} A cartesian with the maximum components.
	     */
	    Cartesian3.maximumByComponent = function(first, second, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(first)) {
	            throw new DeveloperError('first is required.');
	        }
	        if (!defined(second)) {
	            throw new DeveloperError('second is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.max(first.x, second.x);
	        result.y = Math.max(first.y, second.y);
	        result.z = Math.max(first.z, second.z);
	        return result;
	    };

	    /**
	     * Computes the provided Cartesian's squared magnitude.
	     *
	     * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.
	     * @returns {Number} The squared magnitude.
	     */
	    Cartesian3.magnitudeSquared = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
	    };

	    /**
	     * Computes the Cartesian's magnitude (length).
	     *
	     * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.
	     * @returns {Number} The magnitude.
	     */
	    Cartesian3.magnitude = function(cartesian) {
	        return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
	    };

	    var distanceScratch = new Cartesian3();

	    /**
	     * Computes the distance between two points.
	     *
	     * @param {Cartesian3} left The first point to compute the distance from.
	     * @param {Cartesian3} right The second point to compute the distance to.
	     * @returns {Number} The distance between two points.
	     *
	     * @example
	     * // Returns 1.0
	     * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));
	     */
	    Cartesian3.distance = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left) || !defined(right)) {
	            throw new DeveloperError('left and right are required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian3.subtract(left, right, distanceScratch);
	        return Cartesian3.magnitude(distanceScratch);
	    };

	    /**
	     * Computes the squared distance between two points.  Comparing squared distances
	     * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.
	     *
	     * @param {Cartesian3} left The first point to compute the distance from.
	     * @param {Cartesian3} right The second point to compute the distance to.
	     * @returns {Number} The distance between two points.
	     *
	     * @example
	     * // Returns 4.0, not 2.0
	     * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));
	     */
	    Cartesian3.distanceSquared = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left) || !defined(right)) {
	            throw new DeveloperError('left and right are required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian3.subtract(left, right, distanceScratch);
	        return Cartesian3.magnitudeSquared(distanceScratch);
	    };

	    /**
	     * Computes the normalized form of the supplied Cartesian.
	     *
	     * @param {Cartesian3} cartesian The Cartesian to be normalized.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.normalize = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var magnitude = Cartesian3.magnitude(cartesian);

	        result.x = cartesian.x / magnitude;
	        result.y = cartesian.y / magnitude;
	        result.z = cartesian.z / magnitude;
	        return result;
	    };

	    /**
	     * Computes the dot (scalar) product of two Cartesians.
	     *
	     * @param {Cartesian3} left The first Cartesian.
	     * @param {Cartesian3} right The second Cartesian.
	     * @returns {Number} The dot product.
	     */
	    Cartesian3.dot = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        //>>includeEnd('debug');

	        return left.x * right.x + left.y * right.y + left.z * right.z;
	    };

	    /**
	     * Computes the componentwise product of two Cartesians.
	     *
	     * @param {Cartesian3} left The first Cartesian.
	     * @param {Cartesian3} right The second Cartesian.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.multiplyComponents = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x * right.x;
	        result.y = left.y * right.y;
	        result.z = left.z * right.z;
	        return result;
	    };

	    /**
	     * Computes the componentwise sum of two Cartesians.
	     *
	     * @param {Cartesian3} left The first Cartesian.
	     * @param {Cartesian3} right The second Cartesian.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.add = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x + right.x;
	        result.y = left.y + right.y;
	        result.z = left.z + right.z;
	        return result;
	    };

	    /**
	     * Computes the componentwise difference of two Cartesians.
	     *
	     * @param {Cartesian3} left The first Cartesian.
	     * @param {Cartesian3} right The second Cartesian.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.subtract = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x - right.x;
	        result.y = left.y - right.y;
	        result.z = left.z - right.z;
	        return result;
	    };

	    /**
	     * Multiplies the provided Cartesian componentwise by the provided scalar.
	     *
	     * @param {Cartesian3} cartesian The Cartesian to be scaled.
	     * @param {Number} scalar The scalar to multiply with.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = cartesian.x * scalar;
	        result.y = cartesian.y * scalar;
	        result.z = cartesian.z * scalar;
	        return result;
	    };

	    /**
	     * Divides the provided Cartesian componentwise by the provided scalar.
	     *
	     * @param {Cartesian3} cartesian The Cartesian to be divided.
	     * @param {Number} scalar The scalar to divide by.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.divideByScalar = function(cartesian, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = cartesian.x / scalar;
	        result.y = cartesian.y / scalar;
	        result.z = cartesian.z / scalar;
	        return result;
	    };

	    /**
	     * Negates the provided Cartesian.
	     *
	     * @param {Cartesian3} cartesian The Cartesian to be negated.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.negate = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = -cartesian.x;
	        result.y = -cartesian.y;
	        result.z = -cartesian.z;
	        return result;
	    };

	    /**
	     * Computes the absolute value of the provided Cartesian.
	     *
	     * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.abs = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.abs(cartesian.x);
	        result.y = Math.abs(cartesian.y);
	        result.z = Math.abs(cartesian.z);
	        return result;
	    };

	    var lerpScratch = new Cartesian3();
	    /**
	     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
	     *
	     * @param {Cartesian3} start The value corresponding to t at 0.0.
	     * @param {Cartesian3} end The value corresponding to t at 1.0.
	     * @param {Number} t The point along t at which to interpolate.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Cartesian3.lerp = function(start, end, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(start)) {
	            throw new DeveloperError('start is required.');
	        }
	        if (!defined(end)) {
	            throw new DeveloperError('end is required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian3.multiplyByScalar(end, t, lerpScratch);
	        result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
	        return Cartesian3.add(lerpScratch, result, result);
	    };

	    var angleBetweenScratch = new Cartesian3();
	    var angleBetweenScratch2 = new Cartesian3();
	    /**
	     * Returns the angle, in radians, between the provided Cartesians.
	     *
	     * @param {Cartesian3} left The first Cartesian.
	     * @param {Cartesian3} right The second Cartesian.
	     * @returns {Number} The angle between the Cartesians.
	     */
	    Cartesian3.angleBetween = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        //>>includeEnd('debug');

	        Cartesian3.normalize(left, angleBetweenScratch);
	        Cartesian3.normalize(right, angleBetweenScratch2);
	        var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
	        var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));
	        return Math.atan2(sine, cosine);
	    };

	    var mostOrthogonalAxisScratch = new Cartesian3();
	    /**
	     * Returns the axis that is most orthogonal to the provided Cartesian.
	     *
	     * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The most orthogonal axis.
	     */
	    Cartesian3.mostOrthogonalAxis = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);
	        Cartesian3.abs(f, f);

	        if (f.x <= f.y) {
	            if (f.x <= f.z) {
	                result = Cartesian3.clone(Cartesian3.UNIT_X, result);
	            } else {
	                result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
	            }
	        } else {
	            if (f.y <= f.z) {
	                result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
	            } else {
	                result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
	            }
	        }

	        return result;
	    };

	    /**
	     * Compares the provided Cartesians componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartesian3} [left] The first Cartesian.
	     * @param {Cartesian3} [right] The second Cartesian.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Cartesian3.equals = function(left, right) {
	            return (left === right) ||
	              ((defined(left)) &&
	               (defined(right)) &&
	               (left.x === right.x) &&
	               (left.y === right.y) &&
	               (left.z === right.z));
	    };

	    /**
	     * @private
	     */
	    Cartesian3.equalsArray = function(cartesian, array, offset) {
	        return cartesian.x === array[offset] &&
	               cartesian.y === array[offset + 1] &&
	               cartesian.z === array[offset + 2];
	    };

	    /**
	     * Compares the provided Cartesians componentwise and returns
	     * <code>true</code> if they pass an absolute or relative tolerance test,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartesian3} [left] The first Cartesian.
	     * @param {Cartesian3} [right] The second Cartesian.
	     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
	     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartesian3.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	        return (left === right) ||
	               (defined(left) &&
	                defined(right) &&
	                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&
	                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) &&
	                CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon));
	    };

	    /**
	     * Computes the cross (outer) product of two Cartesians.
	     *
	     * @param {Cartesian3} left The first Cartesian.
	     * @param {Cartesian3} right The second Cartesian.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The cross product.
	     */
	    Cartesian3.cross = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var leftX = left.x;
	        var leftY = left.y;
	        var leftZ = left.z;
	        var rightX = right.x;
	        var rightY = right.y;
	        var rightZ = right.z;

	        var x = leftY * rightZ - leftZ * rightY;
	        var y = leftZ * rightX - leftX * rightZ;
	        var z = leftX * rightY - leftY * rightX;

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Returns a Cartesian3 position from longitude and latitude values given in degrees.
	     *
	     * @param {Number} longitude The longitude, in degrees
	     * @param {Number} latitude The latitude, in degrees
	     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The position
	     *
	     * @example
	     * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);
	     */
	    Cartesian3.fromDegrees = function(longitude, latitude, height, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(longitude)) {
	            throw new DeveloperError('longitude is required');
	        }
	        if (!defined(latitude)) {
	            throw new DeveloperError('latitude is required');
	        }
	        //>>includeEnd('debug');

	        var lon = CesiumMath.toRadians(longitude);
	        var lat = CesiumMath.toRadians(latitude);
	        return Cartesian3.fromRadians(lon, lat, height, ellipsoid, result);
	    };

	    var scratchN = new Cartesian3();
	    var scratchK = new Cartesian3();
	    var wgs84RadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);

	    /**
	     * Returns a Cartesian3 position from longitude and latitude values given in radians.
	     *
	     * @param {Number} longitude The longitude, in radians
	     * @param {Number} latitude The latitude, in radians
	     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The position
	     *
	     * @example
	     * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);
	     */
	    Cartesian3.fromRadians = function(longitude, latitude, height, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(longitude)) {
	            throw new DeveloperError('longitude is required');
	        }
	        if (!defined(latitude)) {
	            throw new DeveloperError('latitude is required');
	        }
	        //>>includeEnd('debug');

	        height = defaultValue(height, 0.0);
	        var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;

	        var cosLatitude = Math.cos(latitude);
	        scratchN.x = cosLatitude * Math.cos(longitude);
	        scratchN.y = cosLatitude * Math.sin(longitude);
	        scratchN.z = Math.sin(latitude);
	        scratchN = Cartesian3.normalize(scratchN, scratchN);

	        Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
	        var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
	        scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
	        scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);

	        if (!defined(result)) {
	            result = new Cartesian3();
	        }
	        return Cartesian3.add(scratchK, scratchN, result);
	    };

	    /**
	     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.
	     *
	     * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.
	     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	     * @returns {Cartesian3[]} The array of positions.
	     *
	     * @example
	     * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);
	     */
	    Cartesian3.fromDegreesArray = function(coordinates, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(coordinates)) {
	            throw new DeveloperError('positions is required.');
	        }
	        //>>includeEnd('debug');

	        var pos = new Array(coordinates.length);
	        for (var i = 0; i < coordinates.length; i++) {
	            pos[i] = CesiumMath.toRadians(coordinates[i]);
	        }

	        return Cartesian3.fromRadiansArray(pos, ellipsoid, result);
	    };

	    /**
	     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.
	     *
	     * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.
	     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	     * @returns {Cartesian3[]} The array of positions.
	     *
	     * @example
	     * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);
	     */
	    Cartesian3.fromRadiansArray = function(coordinates, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(coordinates)) {
	            throw new DeveloperError('positions is required.');
	        }
	        if (coordinates.length < 2) {
	            throw new DeveloperError('positions length cannot be less than 2.');
	        }
	        if (coordinates.length % 2 !== 0) {
	            throw new DeveloperError('positions length must be a multiple of 2.');
	        }
	        //>>includeEnd('debug');

	        var length = coordinates.length;
	        if (!defined(result)) {
	            result = new Array(length/2);
	        } else {
	            result.length = length/2;
	        }

	        for ( var i = 0; i < length; i+=2) {
	            var lon = coordinates[i];
	            var lat = coordinates[i+1];
	            result[i/2] = Cartesian3.fromRadians(lon, lat, 0, ellipsoid, result[i/2]);
	        }

	        return result;
	    };

	    /**
	     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.
	     *
	     * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height,, longitude, latitude, height...].
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
	     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	     * @returns {Cartesian3[]} The array of positions.
	     *
	     * @example
	     * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);
	     */
	    Cartesian3.fromDegreesArrayHeights = function(coordinates, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(coordinates)) {
	            throw new DeveloperError('positions is required.');
	        }
	        if (coordinates.length < 3) {
	            throw new DeveloperError('positions length cannot be less than 3.');
	        }
	        if (coordinates.length % 3 !== 0) {
	            throw new DeveloperError('positions length must be a multiple of 3.');
	        }
	        //>>includeEnd('debug');

	        var pos = new Array(coordinates.length);
	        for (var i = 0; i < coordinates.length; i+=3) {
	            pos[i] = CesiumMath.toRadians(coordinates[i]);
	            pos[i+1] = CesiumMath.toRadians(coordinates[i+1]);
	            pos[i+2] = coordinates[i+2];
	        }

	        return Cartesian3.fromRadiansArrayHeights(pos, ellipsoid, result);
	    };

	    /**
	     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.
	     *
	     * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height,, longitude, latitude, height...].
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
	     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
	     * @returns {Cartesian3[]} The array of positions.
	     *
	     * @example
	     * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);
	     */
	    Cartesian3.fromRadiansArrayHeights = function(coordinates, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(coordinates)) {
	            throw new DeveloperError('positions is required.');
	        }
	        if (coordinates.length < 3) {
	            throw new DeveloperError('positions length cannot be less than 3.');
	        }
	        if (coordinates.length % 3 !== 0) {
	            throw new DeveloperError('positions length must be a multiple of 3.');
	        }
	        //>>includeEnd('debug');

	        var length = coordinates.length;
	        if (!defined(result)) {
	            result = new Array(length/3);
	        } else {
	            result.length = length/3;
	        }

	        for ( var i = 0; i < length; i+=3) {
	            var lon = coordinates[i];
	            var lat = coordinates[i+1];
	            var alt = coordinates[i+2];
	            result[i/3] = Cartesian3.fromRadians(lon, lat, alt, ellipsoid, result[i/3]);
	        }

	        return result;
	    };

	    /**
	     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
	     *
	     * @type {Cartesian3}
	     * @constant
	     */
	    Cartesian3.ZERO = freezeObject(new Cartesian3(0.0, 0.0, 0.0));

	    /**
	     * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
	     *
	     * @type {Cartesian3}
	     * @constant
	     */
	    Cartesian3.UNIT_X = freezeObject(new Cartesian3(1.0, 0.0, 0.0));

	    /**
	     * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
	     *
	     * @type {Cartesian3}
	     * @constant
	     */
	    Cartesian3.UNIT_Y = freezeObject(new Cartesian3(0.0, 1.0, 0.0));

	    /**
	     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
	     *
	     * @type {Cartesian3}
	     * @constant
	     */
	    Cartesian3.UNIT_Z = freezeObject(new Cartesian3(0.0, 0.0, 1.0));

	    /**
	     * Duplicates this Cartesian3 instance.
	     *
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	     */
	    Cartesian3.prototype.clone = function(result) {
	        return Cartesian3.clone(this, result);
	    };

	    /**
	     * Compares this Cartesian against the provided Cartesian componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartesian3} [right] The right hand side Cartesian.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    Cartesian3.prototype.equals = function(right) {
	        return Cartesian3.equals(this, right);
	    };

	    /**
	     * Compares this Cartesian against the provided Cartesian componentwise and returns
	     * <code>true</code> if they pass an absolute or relative tolerance test,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartesian3} [right] The right hand side Cartesian.
	     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
	     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartesian3.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
	        return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
	    };

	    /**
	     * Creates a string representing this Cartesian in the format '(x, y, z)'.
	     *
	     * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.
	     */
	    Cartesian3.prototype.toString = function() {
	        return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
	    };

	    return Cartesian3;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $                 = __webpack_require__(5)
	  , cof               = __webpack_require__(30)
	  , assertObject      = __webpack_require__(20).obj
	  , SYMBOL_ITERATOR   = __webpack_require__(14)('iterator')
	  , FF_ITERATOR       = '@@iterator'
	  , Iterators         = {}
	  , IteratorPrototype = {};
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	setIterator(IteratorPrototype, $.that);
	function setIterator(O, value){
	  $.hide(O, SYMBOL_ITERATOR, value);
	  // Add iterator for FF iterator protocol
	  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);
	}

	module.exports = {
	  // Safari has buggy iterators w/o `next`
	  BUGGY: 'keys' in [] && !('next' in [].keys()),
	  Iterators: Iterators,
	  step: function(done, value){
	    return {value: value, done: !!done};
	  },
	  is: function(it){
	    var O      = Object(it)
	      , Symbol = $.g.Symbol
	      , SYM    = Symbol && Symbol.iterator || FF_ITERATOR;
	    return SYM in O || SYMBOL_ITERATOR in O || $.has(Iterators, cof.classof(O));
	  },
	  get: function(it){
	    var Symbol  = $.g.Symbol
	      , ext     = it[Symbol && Symbol.iterator || FF_ITERATOR]
	      , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[cof.classof(it)];
	    return assertObject(getIter.call(it));
	  },
	  set: setIterator,
	  create: function(Constructor, NAME, next, proto){
	    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
	    cof.set(Constructor, NAME + ' Iterator');
	  }
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5).g
	  , store  = {};
	module.exports = function(name){
	  return store[name] || (store[name] =
	    global.Symbol && global.Symbol[name] || __webpack_require__(24).safe('Symbol.' + name));
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	// import a subset of Cesium modules
	// TODO:  we probably want to import all the Cesium modules in Core and Datasources (so we can easily document what we include)
	'use strict';

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _cesiumSourceCoreBinarySearch = __webpack_require__(45);

	var _cesiumSourceCoreBinarySearch2 = _interopRequireDefault(_cesiumSourceCoreBinarySearch);

	var _cesiumSourceCoreCreateGuid = __webpack_require__(46);

	var _cesiumSourceCoreCreateGuid2 = _interopRequireDefault(_cesiumSourceCoreCreateGuid);

	var _cesiumSourceCoreDefined = __webpack_require__(1);

	var _cesiumSourceCoreDefined2 = _interopRequireDefault(_cesiumSourceCoreDefined);

	var _cesiumSourceCoreDefaultValue = __webpack_require__(3);

	var _cesiumSourceCoreDefaultValue2 = _interopRequireDefault(_cesiumSourceCoreDefaultValue);

	var _cesiumSourceCoreClock = __webpack_require__(115);

	var _cesiumSourceCoreClock2 = _interopRequireDefault(_cesiumSourceCoreClock);

	var _cesiumSourceCoreClockStep = __webpack_require__(74);

	var _cesiumSourceCoreClockStep2 = _interopRequireDefault(_cesiumSourceCoreClockStep);

	var _cesiumSourceCoreCartesian2 = __webpack_require__(34);

	var _cesiumSourceCoreCartesian22 = _interopRequireDefault(_cesiumSourceCoreCartesian2);

	var _cesiumSourceCoreCartesian3 = __webpack_require__(12);

	var _cesiumSourceCoreCartesian32 = _interopRequireDefault(_cesiumSourceCoreCartesian3);

	var _cesiumSourceCoreCartesian4 = __webpack_require__(51);

	var _cesiumSourceCoreCartesian42 = _interopRequireDefault(_cesiumSourceCoreCartesian4);

	var _cesiumSourceCoreQuaternion = __webpack_require__(35);

	var _cesiumSourceCoreQuaternion2 = _interopRequireDefault(_cesiumSourceCoreQuaternion);

	var _cesiumSourceCoreJulianDate = __webpack_require__(16);

	var _cesiumSourceCoreJulianDate2 = _interopRequireDefault(_cesiumSourceCoreJulianDate);

	var _cesiumSourceCoreEllipsoid = __webpack_require__(43);

	var _cesiumSourceCoreEllipsoid2 = _interopRequireDefault(_cesiumSourceCoreEllipsoid);

	var _cesiumSourceCoreHermitePolynomialApproximation = __webpack_require__(120);

	var _cesiumSourceCoreHermitePolynomialApproximation2 = _interopRequireDefault(_cesiumSourceCoreHermitePolynomialApproximation);

	var _cesiumSourceCoreExtrapolationType = __webpack_require__(75);

	var _cesiumSourceCoreExtrapolationType2 = _interopRequireDefault(_cesiumSourceCoreExtrapolationType);

	var _cesiumSourceCoreMatrix3 = __webpack_require__(29);

	var _cesiumSourceCoreMatrix32 = _interopRequireDefault(_cesiumSourceCoreMatrix3);

	var _cesiumSourceCoreMatrix4 = __webpack_require__(44);

	var _cesiumSourceCoreMatrix42 = _interopRequireDefault(_cesiumSourceCoreMatrix4);

	var _cesiumSourceCoreMath = __webpack_require__(11);

	var _cesiumSourceCoreMath2 = _interopRequireDefault(_cesiumSourceCoreMath);

	var _cesiumSourceCoreTransforms = __webpack_require__(55);

	var _cesiumSourceCoreTransforms2 = _interopRequireDefault(_cesiumSourceCoreTransforms);

	var _cesiumSourceCoreReferenceFrame = __webpack_require__(21);

	var _cesiumSourceCoreReferenceFrame2 = _interopRequireDefault(_cesiumSourceCoreReferenceFrame);

	var _cesiumSourceCoreDeveloperError = __webpack_require__(2);

	var _cesiumSourceCoreDeveloperError2 = _interopRequireDefault(_cesiumSourceCoreDeveloperError);

	var _cesiumSourceCoreGeographicProjection = __webpack_require__(164);

	var _cesiumSourceCoreGeographicProjection2 = _interopRequireDefault(_cesiumSourceCoreGeographicProjection);

	var _cesiumSourceDataSourcesCzmlDataSource = __webpack_require__(188);

	var _cesiumSourceDataSourcesCzmlDataSource2 = _interopRequireDefault(_cesiumSourceDataSourcesCzmlDataSource);

	var _cesiumSourceDataSourcesEntity = __webpack_require__(82);

	var _cesiumSourceDataSourcesEntity2 = _interopRequireDefault(_cesiumSourceDataSourcesEntity);

	var _cesiumSourceDataSourcesEntityCollection = __webpack_require__(83);

	var _cesiumSourceDataSourcesEntityCollection2 = _interopRequireDefault(_cesiumSourceDataSourcesEntityCollection);

	var _cesiumSourceDataSourcesCompositeEntityCollection = __webpack_require__(183);

	var _cesiumSourceDataSourcesCompositeEntityCollection2 = _interopRequireDefault(_cesiumSourceDataSourcesCompositeEntityCollection);

	var _cesiumSourceDataSourcesProperty = __webpack_require__(10);

	var _cesiumSourceDataSourcesProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesProperty);

	var _cesiumSourceDataSourcesConstantProperty = __webpack_require__(56);

	var _cesiumSourceDataSourcesConstantProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesConstantProperty);

	var _cesiumSourceDataSourcesCallbackProperty = __webpack_require__(182);

	var _cesiumSourceDataSourcesCallbackProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesCallbackProperty);

	var _cesiumSourceDataSourcesReferenceProperty = __webpack_require__(137);

	var _cesiumSourceDataSourcesReferenceProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesReferenceProperty);

	var _cesiumSourceDataSourcesReferenceEntity = __webpack_require__(136);

	var _cesiumSourceDataSourcesReferenceEntity2 = _interopRequireDefault(_cesiumSourceDataSourcesReferenceEntity);

	var _cesiumSourceDataSourcesPositionProperty = __webpack_require__(57);

	var _cesiumSourceDataSourcesPositionProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesPositionProperty);

	var _cesiumSourceDataSourcesOrientationProperty = __webpack_require__(192);

	var _cesiumSourceDataSourcesOrientationProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesOrientationProperty);

	var _cesiumSourceDataSourcesConstantPositionProperty = __webpack_require__(81);

	var _cesiumSourceDataSourcesConstantPositionProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesConstantPositionProperty);

	var _cesiumSourceDataSourcesSampledProperty = __webpack_require__(84);

	var _cesiumSourceDataSourcesSampledProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesSampledProperty);

	var _cesiumSourceDataSourcesSampledPositionProperty = __webpack_require__(138);

	var _cesiumSourceDataSourcesSampledPositionProperty2 = _interopRequireDefault(_cesiumSourceDataSourcesSampledPositionProperty);

	var _cesiumSourceScenePerspectiveFrustum = __webpack_require__(203);

	var _cesiumSourceScenePerspectiveFrustum2 = _interopRequireDefault(_cesiumSourceScenePerspectiveFrustum);

	exports['default'] = {
	  binarySearch: _cesiumSourceCoreBinarySearch2['default'],
	  createGuid: _cesiumSourceCoreCreateGuid2['default'],
	  defined: _cesiumSourceCoreDefined2['default'],
	  defaultValue: _cesiumSourceCoreDefaultValue2['default'],
	  Clock: _cesiumSourceCoreClock2['default'],
	  ClockStep: _cesiumSourceCoreClockStep2['default'],
	  Cartesian2: _cesiumSourceCoreCartesian22['default'],
	  Cartesian3: _cesiumSourceCoreCartesian32['default'],
	  Cartesian4: _cesiumSourceCoreCartesian42['default'],
	  Quaternion: _cesiumSourceCoreQuaternion2['default'],
	  JulianDate: _cesiumSourceCoreJulianDate2['default'],
	  Ellipsoid: _cesiumSourceCoreEllipsoid2['default'],
	  HermitePolynomialApproximation: _cesiumSourceCoreHermitePolynomialApproximation2['default'],
	  ExtrapolationType: _cesiumSourceCoreExtrapolationType2['default'],
	  Matrix3: _cesiumSourceCoreMatrix32['default'],
	  Matrix4: _cesiumSourceCoreMatrix42['default'],
	  Math: _cesiumSourceCoreMath2['default'],
	  Transforms: _cesiumSourceCoreTransforms2['default'],
	  ReferenceFrame: _cesiumSourceCoreReferenceFrame2['default'],
	  DeveloperError: _cesiumSourceCoreDeveloperError2['default'],
	  GeographicProjection: _cesiumSourceCoreGeographicProjection2['default'],
	  CzmlDataSource: _cesiumSourceDataSourcesCzmlDataSource2['default'],
	  Entity: _cesiumSourceDataSourcesEntity2['default'],
	  EntityCollection: _cesiumSourceDataSourcesEntityCollection2['default'],
	  CompositeEntityCollection: _cesiumSourceDataSourcesCompositeEntityCollection2['default'],
	  Property: _cesiumSourceDataSourcesProperty2['default'],
	  ConstantProperty: _cesiumSourceDataSourcesConstantProperty2['default'],
	  CallbackProperty: _cesiumSourceDataSourcesCallbackProperty2['default'],
	  ReferenceProperty: _cesiumSourceDataSourcesReferenceProperty2['default'],
	  ReferenceEntity: _cesiumSourceDataSourcesReferenceEntity2['default'],
	  PositionProperty: _cesiumSourceDataSourcesPositionProperty2['default'],
	  OrientationProperty: _cesiumSourceDataSourcesOrientationProperty2['default'],
	  ConstantPositionProperty: _cesiumSourceDataSourcesConstantPositionProperty2['default'],
	  SampledProperty: _cesiumSourceDataSourcesSampledProperty2['default'],
	  SampledPositionProperty: _cesiumSourceDataSourcesSampledPositionProperty2['default'],
	  PerspectiveFrustum: _cesiumSourceScenePerspectiveFrustum2['default'] };

	window.CESIUM_BASE_URL = '';

	_cesiumSourceCoreTransforms2['default'].iau2006XysData._totalSamples = 0;
	_cesiumSourceCoreTransforms2['default'].iau2006XysData._samples = null;

	// add a length property so that these classes produce instances that are array-like
	_cesiumSourceCoreMatrix42['default'].prototype.length = 16;
	_cesiumSourceCoreMatrix32['default'].prototype.length = 9;
	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(207),
	        __webpack_require__(45),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(165),
	        __webpack_require__(177),
	        __webpack_require__(122),
	        __webpack_require__(77),
	        __webpack_require__(78)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        sprintf,
	        binarySearch,
	        defaultValue,
	        defined,
	        DeveloperError,
	        GregorianDate,
	        isLeapYear,
	        LeapSecond,
	        TimeConstants,
	        TimeStandard) {
	    "use strict";

	    var gregorianDateScratch = new GregorianDate();
	    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	    var daysInLeapFeburary = 29;

	    function compareLeapSecondDates(leapSecond, dateToFind) {
	        return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);
	    }

	    // we don't really need a leap second instance, anything with a julianDate property will do
	    var binarySearchScratchLeapSecond = new LeapSecond();

	    function convertUtcToTai(julianDate) {
	        //Even though julianDate is in UTC, we'll treat it as TAI and
	        //search the leap second table for it.
	        binarySearchScratchLeapSecond.julianDate = julianDate;
	        var leapSeconds = JulianDate.leapSeconds;
	        var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);

	        if (index < 0) {
	            index = ~index;
	        }

	        if (index >= leapSeconds.length) {
	            index = leapSeconds.length - 1;
	        }

	        var offset = leapSeconds[index].offset;
	        if (index > 0) {
	            //Now we have the index of the closest leap second that comes on or after our UTC time.
	            //However, if the difference between the UTC date being converted and the TAI
	            //defined leap second is greater than the offset, we are off by one and need to use
	            //the previous leap second.
	            var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
	            if (difference > offset) {
	                index--;
	                offset = leapSeconds[index].offset;
	            }
	        }

	        JulianDate.addSeconds(julianDate, offset, julianDate);
	    }

	    function convertTaiToUtc(julianDate, result) {
	        binarySearchScratchLeapSecond.julianDate = julianDate;
	        var leapSeconds = JulianDate.leapSeconds;
	        var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
	        if (index < 0) {
	            index = ~index;
	        }

	        //All times before our first leap second get the first offset.
	        if (index === 0) {
	            return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);
	        }

	        //All times after our leap second get the last offset.
	        if (index >= leapSeconds.length) {
	            return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);
	        }

	        //Compute the difference between the found leap second and the time we are converting.
	        var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);

	        if (difference === 0) {
	            //The date is in our leap second table.
	            return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);
	        }

	        if (difference <= 1.0) {
	            //The requested date is during the moment of a leap second, then we cannot convert to UTC
	            return undefined;
	        }

	        //The time is in between two leap seconds, index is the leap second after the date
	        //we're converting, so we subtract one to get the correct LeapSecond instance.
	        return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);
	    }

	    function setComponents(wholeDays, secondsOfDay, julianDate) {
	        var extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;
	        wholeDays += extraDays;
	        secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;

	        if (secondsOfDay < 0) {
	            wholeDays--;
	            secondsOfDay += TimeConstants.SECONDS_PER_DAY;
	        }

	        julianDate.dayNumber = wholeDays;
	        julianDate.secondsOfDay = secondsOfDay;
	        return julianDate;
	    }

	    function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
	        // Algorithm from page 604 of the Explanatory Supplement to the
	        // Astronomical Almanac (Seidelmann 1992).

	        var a = ((month - 14) / 12) | 0;
	        var b = year + 4800 + a;
	        var dayNumber = (((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) - (((3 * ((b + 100) / 100)) / 4) | 0) + day - 32075;

	        // JulianDates are noon-based
	        hour = hour - 12;
	        if (hour < 0) {
	            hour += 24;
	        }

	        var secondsOfDay = second + ((hour * TimeConstants.SECONDS_PER_HOUR) + (minute * TimeConstants.SECONDS_PER_MINUTE) + (millisecond * TimeConstants.SECONDS_PER_MILLISECOND));

	        if (secondsOfDay >= 43200.0) {
	            dayNumber -= 1;
	        }

	        return [dayNumber, secondsOfDay];
	    }

	    //Regular expressions used for ISO8601 date parsing.
	    //YYYY
	    var matchCalendarYear = /^(\d{4})$/;
	    //YYYY-MM (YYYYMM is invalid)
	    var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
	    //YYYY-DDD or YYYYDDD
	    var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
	    //YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD
	    var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
	    //YYYY-MM-DD or YYYYMMDD
	    var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
	    // Match utc offset
	    var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
	    // Match hours HH or HH.xxxxx
	    var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
	    // Match hours/minutes HH:MM HHMM.xxxxx
	    var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
	    // Match hours/minutes HH:MM:SS HHMMSS.xxxxx
	    var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;

	    var iso8601ErrorMessage = 'Invalid ISO 8601 date.';

	    /**
	     * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
	     * For increased precision, this class stores the whole number part of the date and the seconds
	     * part of the date in separate components.  In order to be safe for arithmetic and represent
	     * leap seconds, the date is always stored in the International Atomic Time standard
	     * {@link TimeStandard.TAI}.
	     * @alias JulianDate
	     * @constructor
	     *
	     * @param {Number} julianDayNumber The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
	     * @param {Number} secondsOfDay The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
	     * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.
	     */
	    var JulianDate = function(julianDayNumber, secondsOfDay, timeStandard) {
	        /**
	         * Gets or sets the number of whole days.
	         * @type {Number}
	         */
	        this.dayNumber = undefined;

	        /**
	         * Gets or sets the number of seconds into the current day.
	         * @type {Number}
	         */
	        this.secondsOfDay = undefined;

	        julianDayNumber = defaultValue(julianDayNumber, 0.0);
	        secondsOfDay = defaultValue(secondsOfDay, 0.0);
	        timeStandard = defaultValue(timeStandard, TimeStandard.UTC);

	        //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.
	        var wholeDays = julianDayNumber | 0;
	        secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;

	        setComponents(wholeDays, secondsOfDay, this);

	        if (timeStandard === TimeStandard.UTC) {
	            convertUtcToTai(this);
	        }
	    };

	    /**
	     * Creates a new instance from a JavaScript Date.
	     *
	     * @param {Date} date A JavaScript Date.
	     * @param {JulianDate} [result] An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	     *
	     * @exception {DeveloperError} date must be a valid JavaScript Date.
	     */
	    JulianDate.fromDate = function(date, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!(date instanceof Date) || isNaN(date.getTime())) {
	            throw new DeveloperError('date must be a valid JavaScript Date.');
	        }
	        //>>includeEnd('debug');

	        var components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
	        if (!defined(result)) {
	            return new JulianDate(components[0], components[1], TimeStandard.UTC);
	        }
	        setComponents(components[0], components[1], result);
	        convertUtcToTai(result);
	        return result;
	    };

	    /**
	     * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.
	     * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601
	     * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.
	     *
	     * @param {String} iso8601String An ISO 8601 date.
	     * @param {JulianDate} [result] An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	     *
	     * @exception {DeveloperError} Invalid ISO 8601 date.
	     */
	    JulianDate.fromIso8601 = function(iso8601String, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof iso8601String !== 'string') {
	            throw new DeveloperError(iso8601ErrorMessage);
	        }
	        //>>includeEnd('debug');

	        //Comma and decimal point both indicate a fractional number according to ISO 8601,
	        //start out by blanket replacing , with . which is the only valid such symbol in JS.
	        iso8601String = iso8601String.replace(',', '.');

	        //Split the string into its date and time components, denoted by a mandatory T
	        var tokens = iso8601String.split('T');
	        var year;
	        var month = 1;
	        var day = 1;
	        var hour = 0;
	        var minute = 0;
	        var second = 0;
	        var millisecond = 0;

	        //Lacking a time is okay, but a missing date is illegal.
	        var date = tokens[0];
	        var time = tokens[1];
	        var tmp;
	        var inLeapYear;
	        if (!defined(date)) {
	            throw new DeveloperError(iso8601ErrorMessage);
	        }

	        var dashCount;

	        //First match the date against possible regular expressions.
	        tokens = date.match(matchCalendarDate);
	        if (tokens !== null) {
	            dashCount = date.split('-').length - 1;
	            if (dashCount > 0 && dashCount !== 2) {
	                throw new DeveloperError(iso8601ErrorMessage);
	            }
	            year = +tokens[1];
	            month = +tokens[2];
	            day = +tokens[3];
	        } else {
	            tokens = date.match(matchCalendarMonth);
	            if (tokens !== null) {
	                year = +tokens[1];
	                month = +tokens[2];
	            } else {
	                tokens = date.match(matchCalendarYear);
	                if (tokens !== null) {
	                    year = +tokens[1];
	                } else {
	                    //Not a year/month/day so it must be an ordinal date.
	                    var dayOfYear;
	                    tokens = date.match(matchOrdinalDate);
	                    if (tokens !== null) {

	                        year = +tokens[1];
	                        dayOfYear = +tokens[2];
	                        inLeapYear = isLeapYear(year);

	                        //This validation is only applicable for this format.
	                        if (dayOfYear < 1 || (inLeapYear && dayOfYear > 366) || (!inLeapYear && dayOfYear > 365)) {
	                            throw new DeveloperError(iso8601ErrorMessage);
	                        }
	                    } else {
	                        tokens = date.match(matchWeekDate);
	                        if (tokens !== null) {
	                            //ISO week date to ordinal date from
	                            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775
	                            year = +tokens[1];
	                            var weekNumber = +tokens[2];
	                            var dayOfWeek = +tokens[3] || 0;

	                            dashCount = date.split('-').length - 1;
	                            if (dashCount > 0 &&
	                               ((!defined(tokens[3]) && dashCount !== 1) ||
	                               (defined(tokens[3]) && dashCount !== 2))) {
	                                throw new DeveloperError(iso8601ErrorMessage);
	                            }

	                            var january4 = new Date(Date.UTC(year, 0, 4));
	                            dayOfYear = (weekNumber * 7) + dayOfWeek - january4.getUTCDay() - 3;
	                        } else {
	                            //None of our regular expressions succeeded in parsing the date properly.
	                            throw new DeveloperError(iso8601ErrorMessage);
	                        }
	                    }
	                    //Split an ordinal date into month/day.
	                    tmp = new Date(Date.UTC(year, 0, 1));
	                    tmp.setUTCDate(dayOfYear);
	                    month = tmp.getUTCMonth() + 1;
	                    day = tmp.getUTCDate();
	                }
	            }
	        }

	        //Now that we have all of the date components, validate them to make sure nothing is out of range.
	        inLeapYear = isLeapYear(year);
	        if (month < 1 || month > 12 || day < 1 || ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) || (inLeapYear && month === 2 && day > daysInLeapFeburary)) {
	            throw new DeveloperError(iso8601ErrorMessage);
	        }

	        //Not move onto the time string, which is much simpler.
	        var offsetIndex;
	        if (defined(time)) {
	            tokens = time.match(matchHoursMinutesSeconds);
	            if (tokens !== null) {
	                dashCount = time.split(':').length - 1;
	                if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {
	                    throw new DeveloperError(iso8601ErrorMessage);
	                }

	                hour = +tokens[1];
	                minute = +tokens[2];
	                second = +tokens[3];
	                millisecond = +(tokens[4] || 0) * 1000.0;
	                offsetIndex = 5;
	            } else {
	                tokens = time.match(matchHoursMinutes);
	                if (tokens !== null) {
	                    dashCount = time.split(':').length - 1;
	                    if (dashCount > 0 && dashCount !== 1) {
	                        throw new DeveloperError(iso8601ErrorMessage);
	                    }

	                    hour = +tokens[1];
	                    minute = +tokens[2];
	                    second = +(tokens[3] || 0) * 60.0;
	                    offsetIndex = 4;
	                } else {
	                    tokens = time.match(matchHours);
	                    if (tokens !== null) {
	                        hour = +tokens[1];
	                        minute = +(tokens[2] || 0) * 60.0;
	                        offsetIndex = 3;
	                    } else {
	                        throw new DeveloperError(iso8601ErrorMessage);
	                    }
	                }
	            }

	            //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.
	            if (minute >= 60 || second >= 61 || hour > 24 || (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))) {
	                throw new DeveloperError(iso8601ErrorMessage);
	            }

	            //Check the UTC offset value, if no value exists, use local time
	            //a Z indicates UTC, + or - are offsets.
	            var offset = tokens[offsetIndex];
	            var offsetHours = +(tokens[offsetIndex + 1]);
	            var offsetMinutes = +(tokens[offsetIndex + 2] || 0);
	            switch (offset) {
	            case '+':
	                hour = hour - offsetHours;
	                minute = minute - offsetMinutes;
	                break;
	            case '-':
	                hour = hour + offsetHours;
	                minute = minute + offsetMinutes;
	                break;
	            case 'Z':
	                break;
	            default:
	                minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();
	                break;
	            }
	        } else {
	            //If no time is specified, it is considered the beginning of the day, local time.
	            minute = minute + new Date(year, month - 1, day).getTimezoneOffset();
	        }

	        //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.
	        //If that's the case, we need to temporarily subtract a second in order to build a UTC date.
	        //Then we add it back in after converting to TAI.
	        var isLeapSecond = second === 60;
	        if (isLeapSecond) {
	            second--;
	        }

	        //Even if we successfully parsed the string into its components, after applying UTC offset or
	        //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.

	        //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes
	        while (minute >= 60) {
	            minute -= 60;
	            hour++;
	        }

	        while (hour >= 24) {
	            hour -= 24;
	            day++;
	        }

	        tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
	        while (day > tmp) {
	            day -= tmp;
	            month++;

	            if (month > 12) {
	                month -= 12;
	                year++;
	            }

	            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
	        }

	        //If UTC offset is at the beginning/end of the day, minutes can be negative.
	        while (minute < 0) {
	            minute += 60;
	            hour--;
	        }

	        while (hour < 0) {
	            hour += 24;
	            day--;
	        }

	        while (day < 1) {
	            month--;
	            if (month < 1) {
	                month += 12;
	                year--;
	            }

	            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
	            day += tmp;
	        }

	        //Now create the JulianDate components from the Gregorian date and actually create our instance.
	        var components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);

	        if (!defined(result)) {
	            result = new JulianDate(components[0], components[1], TimeStandard.UTC);
	        } else {
	            setComponents(components[0], components[1], result);
	            convertUtcToTai(result);
	        }

	        //If we were on a leap second, add it back.
	        if (isLeapSecond) {
	            JulianDate.addSeconds(result, 1, result);
	        }

	        return result;
	    };

	    /**
	     * Creates a new instance that represents the current system time.
	     * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.
	     *
	     * @param {JulianDate} [result] An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	     */
	    JulianDate.now = function(result) {
	        return JulianDate.fromDate(new Date(), result);
	    };

	    var toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);

	    /**
	     * Creates a {@link GregorianDate} from the provided instance.
	     *
	     * @param {JulianDate} julianDate The date to be converted.
	     * @param {GregorianDate} [result] An existing instance to use for the result.
	     * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.
	     */
	    JulianDate.toGregorianDate = function(julianDate, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        //>>includeEnd('debug');

	        var isLeapSecond = false;
	        var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);
	        if (!defined(thisUtc)) {
	            //Conversion to UTC will fail if we are during a leap second.
	            //If that's the case, subtract a second and convert again.
	            //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.
	            JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);
	            thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);
	            isLeapSecond = true;
	        }

	        var julianDayNumber = thisUtc.dayNumber;
	        var secondsOfDay = thisUtc.secondsOfDay;

	        if (secondsOfDay >= 43200.0) {
	            julianDayNumber += 1;
	        }

	        // Algorithm from page 604 of the Explanatory Supplement to the
	        // Astronomical Almanac (Seidelmann 1992).
	        var L = (julianDayNumber + 68569) | 0;
	        var N = (4 * L / 146097) | 0;
	        L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
	        var I = ((4000 * (L + 1)) / 1461001) | 0;
	        L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
	        var J = ((80 * L) / 2447) | 0;
	        var day = (L - (((2447 * J) / 80) | 0)) | 0;
	        L = (J / 11) | 0;
	        var month = (J + 2 - 12 * L) | 0;
	        var year = (100 * (N - 49) + I + L) | 0;

	        var hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;
	        var remainingSeconds = secondsOfDay - (hour * TimeConstants.SECONDS_PER_HOUR);
	        var minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;
	        remainingSeconds = remainingSeconds - (minute * TimeConstants.SECONDS_PER_MINUTE);
	        var second = remainingSeconds | 0;
	        var millisecond = ((remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND);

	        // JulianDates are noon-based
	        hour += 12;
	        if (hour > 23) {
	            hour -= 24;
	        }

	        //If we were on a leap second, add it back.
	        if (isLeapSecond) {
	            second += 1;
	        }

	        if (!defined(result)) {
	            return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);
	        }

	        result.year = year;
	        result.month = month;
	        result.day = day;
	        result.hour = hour;
	        result.minute = minute;
	        result.second = second;
	        result.millisecond = millisecond;
	        result.isLeapSecond = isLeapSecond;
	        return result;
	    };

	    /**
	     * Creates a JavaScript Date from the provided instance.
	     * Since JavaScript dates are only accurate to the nearest millisecond and
	     * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.
	     * If the provided JulianDate is during a leap second, the previous second is used.
	     *
	     * @param {JulianDate} julianDate The date to be converted.
	     * @returns {Date} A new instance representing the provided date.
	     */
	    JulianDate.toDate = function(julianDate) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        //>>includeEnd('debug');

	        var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
	        var second = gDate.second;
	        if (gDate.isLeapSecond) {
	            second -= 1;
	        }
	        return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));
	    };

	    /**
	     * Creates an ISO8601 representation of the provided date.
	     *
	     * @param {JulianDate} julianDate The date to be converted.
	     * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
	     * @returns {String} The ISO8601 representation of the provided date.
	     */
	    JulianDate.toIso8601 = function(julianDate, precision) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        //>>includeEnd('debug');

	        var gDate = JulianDate.toGregorianDate(julianDate, gDate);
	        var millisecondStr;

	        if (!defined(precision) && gDate.millisecond !== 0) {
	            //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.
	            millisecondStr = (gDate.millisecond * 0.01).toString().replace('.', '');
	            return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
	        }

	        //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely
	        if (!defined(precision) || precision === 0) {
	            return sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second);
	        }

	        //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.
	        millisecondStr = (gDate.millisecond * 0.01).toFixed(precision).replace('.', '').slice(0, precision);
	        return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
	    };

	    /**
	     * Duplicates a JulianDate instance.
	     *
	     * @param {JulianDate} julianDate The date to duplicate.
	     * @param {JulianDate} [result] An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.
	     */
	    JulianDate.clone = function(julianDate, result) {
	        if (!defined(julianDate)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);
	        }
	        result.dayNumber = julianDate.dayNumber;
	        result.secondsOfDay = julianDate.secondsOfDay;
	        return result;
	    };

	    /**
	     * Compares two instances.
	     *
	     * @param {JulianDate} left The first instance.
	     * @param {JulianDate} right The second instance.
	     * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.
	     */
	    JulianDate.compare = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required.');
	        }
	        //>>includeEnd('debug');

	        var julianDayNumberDifference = left.dayNumber - right.dayNumber;
	        if (julianDayNumberDifference !== 0) {
	            return julianDayNumberDifference;
	        }
	        return left.secondsOfDay - right.secondsOfDay;
	    };

	    /**
	     * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {JulianDate} [left] The first instance.
	     * @param {JulianDate} [right] The second instance.
	     * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
	     */
	    JulianDate.equals = function(left, right) {
	        return (left === right) ||
	               (defined(left) &&
	                defined(right) &&
	                left.dayNumber === right.dayNumber &&
	                left.secondsOfDay === right.secondsOfDay);
	    };

	    /**
	     * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
	     * each other.  That is, in order for the dates to be considered equal (and for
	     * this function to return <code>true</code>), the absolute value of the difference between them, in
	     * seconds, must be less than <code>epsilon</code>.
	     *
	     * @param {JulianDate} [left] The first instance.
	     * @param {JulianDate} [right] The second instance.
	     * @param {Number} epsilon The maximum number of seconds that should separate the two instances.
	     * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
	     */
	    JulianDate.equalsEpsilon = function(left, right, epsilon) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(epsilon)) {
	            throw new DeveloperError('epsilon is required.');
	        }
	        //>>includeEnd('debug');

	        return (left === right) ||
	               (defined(left) &&
	                defined(right) &&
	                Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon);
	    };

	    /**
	     * Computes the total number of whole and fractional days represented by the provided instance.
	     *
	     * @param {JulianDate} julianDate The date.
	     * @returns {Number} The Julian date as single floating point number.
	     */
	    JulianDate.totalDays = function(julianDate) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        //>>includeEnd('debug');
	        return julianDate.dayNumber + (julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY);
	    };

	    /**
	     * Computes the difference in seconds between the provided instance.
	     *
	     * @param {JulianDate} left The first instance.
	     * @param {JulianDate} right The second instance.
	     * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.
	     */
	    JulianDate.secondsDifference = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required.');
	        }
	        //>>includeEnd('debug');

	        var dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;
	        return (dayDifference + (left.secondsOfDay - right.secondsOfDay));
	    };

	    /**
	     * Computes the difference in days between the provided instance.
	     *
	     * @param {JulianDate} left The first instance.
	     * @param {JulianDate} right The second instance.
	     * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.
	     */
	    JulianDate.daysDifference = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required.');
	        }
	        //>>includeEnd('debug');

	        var dayDifference = (left.dayNumber - right.dayNumber);
	        var secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
	        return dayDifference + secondDifference;
	    };

	    /**
	     * Computes the number of seconds the provided instance is ahead of UTC.
	     *
	     * @param {JulianDate} julianDate The date.
	     * @returns {Number} The number of seconds the provided instance is ahead of UTC
	     */
	    JulianDate.computeTaiMinusUtc = function(julianDate) {
	        binarySearchScratchLeapSecond.julianDate = julianDate;
	        var leapSeconds = JulianDate.leapSeconds;
	        var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
	        if (index < 0) {
	            index = ~index;
	            --index;
	            if (index < 0) {
	                index = 0;
	            }
	        }
	        return leapSeconds[index].offset;
	    };

	    /**
	     * Adds the provided number of seconds to the provided date instance.
	     *
	     * @param {JulianDate} julianDate The date.
	     * @param {Number} seconds The number of seconds to add or subtract.
	     * @param {JulianDate} result An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter.
	     */
	    JulianDate.addSeconds = function(julianDate, seconds, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        if (!defined(seconds)) {
	            throw new DeveloperError('seconds is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);
	    };

	    /**
	     * Adds the provided number of minutes to the provided date instance.
	     *
	     * @param {JulianDate} julianDate The date.
	     * @param {Number} minutes The number of minutes to add or subtract.
	     * @param {JulianDate} result An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter.
	     */
	    JulianDate.addMinutes = function(julianDate, minutes, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        if (!defined(minutes)) {
	            throw new DeveloperError('minutes is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        var newSecondsOfDay = julianDate.secondsOfDay + (minutes * TimeConstants.SECONDS_PER_MINUTE);
	        return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
	    };

	    /**
	     * Adds the provided number of hours to the provided date instance.
	     *
	     * @param {JulianDate} julianDate The date.
	     * @param {Number} hours The number of hours to add or subtract.
	     * @param {JulianDate} result An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter.
	     */
	    JulianDate.addHours = function(julianDate, hours, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        if (!defined(hours)) {
	            throw new DeveloperError('hours is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        var newSecondsOfDay = julianDate.secondsOfDay + (hours * TimeConstants.SECONDS_PER_HOUR);
	        return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
	    };

	    /**
	     * Adds the provided number of days to the provided date instance.
	     *
	     * @param {JulianDate} julianDate The date.
	     * @param {Number} days The number of days to add or subtract.
	     * @param {JulianDate} result An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter.
	     */
	    JulianDate.addDays = function(julianDate, days, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        if (!defined(days)) {
	            throw new DeveloperError('days is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        var newJulianDayNumber = julianDate.dayNumber + days;
	        return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);
	    };

	    /**
	     * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
	     *
	     * @param {JulianDate} left The first instance.
	     * @param {JulianDate} right The second instance.
	     * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
	     */
	    JulianDate.lessThan = function(left, right) {
	        return JulianDate.compare(left, right) < 0;
	    };

	    /**
	     * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
	     *
	     * @param {JulianDate} left The first instance.
	     * @param {JulianDate} right The second instance.
	     * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
	     */
	    JulianDate.lessThanOrEquals = function(left, right) {
	        return JulianDate.compare(left, right) <= 0;
	    };

	    /**
	     * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
	     *
	     * @param {JulianDate} left The first instance.
	     * @param {JulianDate} right The second instance.
	     * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
	     */
	    JulianDate.greaterThan = function(left, right) {
	        return JulianDate.compare(left, right) > 0;
	    };

	    /**
	     * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
	     *
	     * @param {JulianDate} left The first instance.
	     * @param {JulianDate} right The second instance.
	     * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
	     */
	    JulianDate.greaterThanOrEquals = function(left, right) {
	        return JulianDate.compare(left, right) >= 0;
	    };

	    /**
	     * Duplicates this instance.
	     *
	     * @param {JulianDate} [result] An existing instance to use for the result.
	     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
	     */
	    JulianDate.prototype.clone = function(result) {
	        return JulianDate.clone(this, result);
	    };

	    /**
	     * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {JulianDate} [right] The second instance.
	     * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
	     */
	    JulianDate.prototype.equals = function(right) {
	        return JulianDate.equals(this, right);
	    };

	    /**
	     * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of
	     * each other.  That is, in order for the dates to be considered equal (and for
	     * this function to return <code>true</code>), the absolute value of the difference between them, in
	     * seconds, must be less than <code>epsilon</code>.
	     *
	     * @param {JulianDate} [right] The second instance.
	     * @param {Number} epsilon The maximum number of seconds that should separate the two instances.
	     * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
	     */
	    JulianDate.prototype.equalsEpsilon = function(right, epsilon) {
	        return JulianDate.equalsEpsilon(this, right, epsilon);
	    };

	    /**
	     * Creates a string representing this date in ISO8601 format.
	     *
	     * @returns {String} A string representing this date in ISO8601 format.
	     */
	    JulianDate.prototype.toString = function() {
	        return JulianDate.toIso8601(this);
	    };

	    /**
	     * Gets or sets the list of leap seconds used throughout Cesium.
	     * @memberof JulianDate
	     * @type {LeapSecond[]}
	     */
	    JulianDate.leapSeconds = [
	                               new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC
	                               new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35)  // July 1, 2012 00:00:00 UTC
	                             ];

	    return JulianDate;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2014 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 2.9.25
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function (promises) {
	    return any(promises);
	};

	Promise.prototype.any = function () {
	    return any(this);
	};

	};

	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule.js");
	var Queue = _dereq_("./queue.js");
	var util = _dereq_("./util.js");

	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}

	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};

	Async.prototype.enableTrampoline = function() {
	    if (!this._trampolineEnabled) {
	        this._trampolineEnabled = true;
	        this._schedule = function(fn) {
	            setTimeout(fn, 0);
	        };
	    }
	};

	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};

	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};

	Async.prototype._getDomain = function() {};

	if (false) {
	if (util.isNode) {
	    var EventsModule = _dereq_("events");

	    var domainGetter = function() {
	        var domain = process.domain;
	        if (domain === null) return undefined;
	        return domain;
	    };

	    if (EventsModule.usingDomains) {
	        Async.prototype._getDomain = domainGetter;
	    } else {
	        var descriptor =
	            Object.getOwnPropertyDescriptor(EventsModule, "usingDomains");

	        if (descriptor) {
	            if (!descriptor.configurable) {
	                process.on("domainsActivated", function() {
	                    Async.prototype._getDomain = domainGetter;
	                });
	            } else {
	                var usingDomains = false;
	                Object.defineProperty(EventsModule, "usingDomains", {
	                    configurable: false,
	                    enumerable: true,
	                    get: function() {
	                        return usingDomains;
	                    },
	                    set: function(value) {
	                        if (usingDomains || !value) return;
	                        usingDomains = true;
	                        Async.prototype._getDomain = domainGetter;
	                        util.toFastProperties(process);
	                        process.emit("domainsActivated");
	                    }
	                });
	            }
	        }
	    }
	}
	}

	function AsyncInvokeLater(fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncInvoke(fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncSettlePromises(promise) {
	    var domain = this._getDomain();
	    if (domain !== undefined) {
	        var fn = domain.bind(promise._settlePromises);
	        this._normalQueue.push(fn, promise, undefined);
	    } else {
	        this._normalQueue._pushOne(promise);
	    }
	    this._queueTick();
	}

	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            setTimeout(function() {
	                fn.call(receiver, arg);
	            }, 100);
	        }
	    };

	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            setTimeout(function() {
	                fn.call(receiver, arg);
	            }, 0);
	        }
	    };

	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            setTimeout(function() {
	                promise._settlePromises();
	            }, 0);
	        }
	    };
	}

	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};

	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};

	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};

	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};

	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};

	module.exports = new Async();
	module.exports.firstLineError = firstLineError;

	},{"./queue.js":28,"./schedule.js":31,"./util.js":38,"events":39}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	var rejectThis = function(_, e) {
	    this._reject(e);
	};

	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};

	var bindingResolved = function(thisArg, context) {
	    this._setBoundTo(thisArg);
	    if (this._isPending()) {
	        this._resolveCallback(context.target);
	    }
	};

	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};

	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, ret._progress, ret, context);
	    } else {
	        ret._setBoundTo(thisArg);
	        ret._resolveCallback(target);
	    }
	    return ret;
	};

	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 131072;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~131072);
	    }
	};

	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};

	Promise.bind = function (thisArg, value) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);

	    if (maybePromise instanceof Promise) {
	        maybePromise._then(function(thisArg) {
	            ret._setBoundTo(thisArg);
	            ret._resolveCallback(value);
	        }, ret._reject, ret._progress, ret, null);
	    } else {
	        ret._setBoundTo(thisArg);
	        ret._resolveCallback(value);
	    }
	    return ret;
	};
	};

	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise.js")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;

	},{"./promise.js":23}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}

	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};

	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};

	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};

	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};

	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}

	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}

	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};

	},{"./util.js":38}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var errors = _dereq_("./errors.js");
	var async = _dereq_("./async.js");
	var CancellationError = errors.CancellationError;

	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};

	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};

	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    async.enableTrampoline();
	    this._setCancellable();
	    this._cancellationParent = undefined;
	    return this;
	};

	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};

	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);

	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};

	},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;

	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);

	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};

	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};

	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};

	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};

	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];

	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};

	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}

	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}

	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;

	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }

	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}

	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}

	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}

	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};

	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};

	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};

	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};

	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }

	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }

	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }

	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }

	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};

	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;

	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }

	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow) {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }

	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    return null;

	})([]);

	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }

	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }

	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();

	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();

	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}

	return CapturedTrace;
	};

	},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util.js");
	var errors = _dereq_("./errors.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = _dereq_("./es5.js").keys;
	var TypeError = errors.TypeError;

	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}

	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);

	    if (retfilter === errorObj) return retfilter;

	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}

	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundTo;
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);

	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};

	return CatchFilter;
	};

	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};

	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};

	function createContext() {
	    if (isDebugging()) return new Context();
	}

	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}

	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;

	return createContext;
	};

	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var async = _dereq_("./async.js");
	var Warning = _dereq_("./errors.js").Warning;
	var util = _dereq_("./util.js");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));

	if (debugging) {
	    async.disableTrampolineIfNecessary();
	}

	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};

	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};

	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};

	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};

	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};

	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};

	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};

	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};

	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};

	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	};

	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};

	Promise.onPossiblyUnhandledRejection = function (fn) {
	    possiblyUnhandledRejection = typeof fn === "function" ? fn : undefined;
	};

	Promise.onUnhandledRejectionHandled = function (fn) {
	    unhandledRejectionHandled = typeof fn === "function" ? fn : undefined;
	};

	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	    if (debugging) {
	        async.disableTrampolineIfNecessary();
	    }
	};

	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};

	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}

	return function() {
	    return debugging;
	};
	};

	},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;

	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};

	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};


	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};

	},{"./util.js":38}],12:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;

	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};

	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};

	},{}],13:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util.js");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};

	},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };

	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };

	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };

	    var ObjectFreeze = function (obj) {
	        return obj;
	    };

	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };

	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}

	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};

	},{}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = _dereq_("./util.js");
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;

	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}

	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo)
	                    : handler();

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }

	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}

	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo, value)
	                    : handler(value);

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}

	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();

	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };

	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};

	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};

	},{"./util.js":38}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = _dereq_("./errors.js");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}

	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};

	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};

	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};

	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};

	},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;

	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }

	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };

	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };

	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}

	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};

	};

	},{"./util.js":38}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._callback = fn;
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    async.invoke(init, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	function init() {this._init$(undefined, -2);}

	MappingPromiseArray.prototype._init = function () {};

	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var callback = this._callback;
	        var receiver = this._promise._boundTo;
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }

	    }
	};

	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}

	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

	    return map(this, fn, options, null).promise();
	};

	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};


	};

	},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;

	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};

	},{"./util.js":38}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundTo;
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundTo, reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	Promise.prototype.asCallback = 
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};

	},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};

	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);

	};

	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};

	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;

	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};


	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }

	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};

	},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var errors = _dereq_("./errors.js");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array.js")(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = _dereq_("./captured_trace.js")();
	var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
	var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
	var PromiseResolver = _dereq_("./promise_resolver.js");
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};

	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};

	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};

	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};

	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};

	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};

	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};

	Promise.is = function (val) {
	    return val instanceof Promise;
	};

	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};

	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};

	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};

	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }

	    var target = this._target();
	    if (target !== this) {
	        if (receiver === undefined) receiver = this._boundTo;
	        if (!haveInternalData) ret._setIsMigrated();
	    }

	    var callbackIndex =
	        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);

	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }

	    return ret;
	};

	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};

	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};

	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};

	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};

	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};

	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};

	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};

	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};

	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};

	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};

	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};

	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};

	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};

	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === undefined && this._isBound()) {
	        return this._boundTo;
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};

	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};

	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};

	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) promise._setIsMigrated();
	    this._addCallbacks(fulfill, reject, progress, promise, receiver);
	};

	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver
	) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
	            this._fulfillmentHandler0 = fulfill;
	        if (typeof reject === "function") this._rejectionHandler0 = reject;
	        if (typeof progress === "function") this._progressHandler0 = progress;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function")
	            this[base + 0] = fulfill;
	        if (typeof reject === "function")
	            this[base + 1] = reject;
	        if (typeof progress === "function")
	            this[base + 2] = progress;
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};

	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};

	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};

	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, hasStack ? undefined : trace);
	};

	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();

	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};

	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundTo, value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();

	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};

	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};

	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};

	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};

	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};

	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};

	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};

	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};

	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;

	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);

	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);


	    this._clearCallbackDataAtIndex(index);

	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }

	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};

	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};

	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};

	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};

	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};

	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};

	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};

	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};

	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();

	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }

	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};

	Promise._makeSelfResolutionError = makeSelfResolutionError;
	_dereq_("./progress.js")(Promise, PromiseArray);
	_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
	_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
	_dereq_("./direct_resolve.js")(Promise);
	_dereq_("./synchronous_inspection.js")(Promise);
	_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./cancel.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./settle.js')(Promise, PromiseArray);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./timers.js')(Promise, INTERNAL);
	_dereq_('./filter.js')(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          

	};

	},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = _dereq_("./util.js");
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};

	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};

	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._unsetRejectionIsUnhandled();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};

	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};

	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};


	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};

	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};

	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};

	return PromiseArray;
	};

	},{"./util.js":38}],25:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors.js");
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = _dereq_("./es5.js");

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}

	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;

	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }

	        promise = null;
	    };
	}


	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}

	PromiseResolver._nodebackForPromise = nodebackForPromise;

	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};

	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};

	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};

	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};

	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};

	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};

	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};

	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};

	module.exports = PromiseResolver;

	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util.js");
	var nodebackForPromise = _dereq_("./promise_resolver.js")
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyPropsPattern =
	    /^(?:length|name|arguments|caller|callee|prototype|__isPromisified__)$/;
	var defaultFilter = function(name, func) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        !util.isClass(func);
	};

	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};

	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};

	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};

	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};

	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};

	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }

	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";

	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        ret.__isPromisified__ = true;                                        \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            INTERNAL
	        );
	};
	}

	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    promisified.__isPromisified__ = true;
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        obj[promisifiedKey] = promisifier === makeNodePromisified
	                ? makeNodePromisified(key, THIS, key, fn, suffix)
	                : promisifier(fn, function() {
	                    return makeNodePromisified(key, THIS, key, fn, suffix);
	                });
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}

	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};

	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }

	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};


	},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5.js");

	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};

	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};

	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};

	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};

	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}

	Promise.prototype.props = function () {
	    return props(this);
	};

	Promise.props = function (promises) {
	    return props(promises);
	};
	};

	},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}

	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};

	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};

	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];

	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function () {
	    return this._length;
	};

	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};

	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};

	module.exports = Queue;

	},{}],29:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = _dereq_("./util.js").isArray;

	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};

	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === undefined && !(i in promises)) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}

	Promise.race = function (promises) {
	    return race(promises, undefined);
	};

	Promise.prototype.race = function () {
	    return race(this, undefined);
	};

	};

	},{"./util.js":38}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    this._callback = fn;
	    this._accum = accum;
	    if (!rejected) async.invoke(init, this, undefined);
	}
	function init() {
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._init = function () {};

	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};

	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];

	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;

	    var callback = this._callback;
	    var receiver = this._promise._boundTo;
	    var ret;

	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();

	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }

	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }

	    this._resolve(isEach ? preservedValues : this._accum);
	};

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};

	},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
	"use strict";
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	};
	if (_dereq_("./util.js").isNode) {
	    var version = process.versions.node.split(".").map(Number);
	    schedule = (version[0] === 0 && version[1] > 10) || (version[0] > 0)
	        ? global.setImmediate : process.nextTick;

	    if (!schedule) {
	        if (typeof setImmediate !== "undefined") {
	            schedule = setImmediate;
	        } else if (typeof setTimeout !== "undefined") {
	            schedule = setTimeout;
	        } else {
	            schedule = noAsyncScheduler;
	        }
	    }
	} else if (typeof MutationObserver !== "undefined") {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;

	},{"./util.js":38}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util.js");

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};

	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};

	},{"./util.js":38}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util.js");
	var RangeError = _dereq_("./errors.js").RangeError;
	var AggregateError = _dereq_("./errors.js").AggregateError;
	var isArray = util.isArray;


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};

	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }

	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};

	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};

	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};

	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};

	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};

	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};

	},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}

	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};

	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};

	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};

	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};

	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};

	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};

	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};

	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};

	Promise.prototype._value = function() {
	    return this._settledValue;
	};

	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};

	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};

	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};


	Promise.PromiseInspection = PromiseInspection;
	};

	},{}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}

	function getThen(obj) {
	    return obj.then;
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}

	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }

	    function resolveFromThenable(value) {
	        if (!promise) return;
	        if (x === value) {
	            promise._rejectCallback(
	                Promise._makeSelfResolutionError(), false, true);
	        } else {
	            promise._resolveCallback(value);
	        }
	        promise = null;
	    }

	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }

	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}

	return tryConvertToPromise;
	};

	},{"./util.js":38}],36:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var TimeoutError = Promise.TimeoutError;

	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    if (typeof message !== "string") {
	        message = "operation timed out";
	    }
	    var err = new TimeoutError(message);
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};

	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};

	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};

	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}

	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}

	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};

	};

	},{"./util.js":38}],37:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = _dereq_("./errors.js").TypeError;
	    var inherits = _dereq_("./util.js").inherits;
	    var PromiseInspection = Promise.PromiseInspection;

	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }

	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }

	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }

	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }

	    Disposer.prototype.data = function () {
	        return this._data;
	    };

	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };

	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };

	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }

	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	        len--;
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = arguments[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }

	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = fn.apply(undefined, vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };

	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };

	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };

	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };

	};

	},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }

	})();

	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};


	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return !isPrimitive(value);
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(safeToString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}


	var wrapsPrimitiveReceiver = (function() {
	    return this !== "string";
	}).call("string");

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    if (es5.isES5) {
	        var oProto = Object.prototype;
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && obj !== oProto) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        return function(obj) {
	            var ret = [];
	            /*jshint forin:false */
	            for (var key in obj) {
	                ret.push(key);
	            }
	            return ret;
	        };
	    }

	})();

	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	            if (es5.isES5) return keys.length > 1;
	            return keys.length > 0 &&
	                   !(keys.length === 1 && keys[0] === "constructor");
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function f() {}
	    f.prototype = obj;
	    var l = 8;
	    while (l--) new f();
	    return obj;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}

	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}

	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();

	function classString(obj) {
	    return {}.toString.call(obj);
	}

	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            es5.defineProperty(to, key, es5.getDescriptor(from, key));
	        }
	    }
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]"
	};
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;

	},{"./es5.js":14}],39:[function(_dereq_,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	},{}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(215), (function() { return this; }()), __webpack_require__(86).setImmediate))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$defineProperty = __webpack_require__(59)['default'];

	exports.__esModule = true;
	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	var Platform = {};

	/*@const*/
	_Object$defineProperty(Platform, 'isManager', {
	  value: !!window.__ARGON_MANAGER
	});
	/*@const*/
	_Object$defineProperty(Platform, 'isChannel', {
	  value: !!window.__ARGON_CHANNEL
	});
	/*@const*/
	_Object$defineProperty(Platform, 'isRunningInTopFrame', {
	  value: window.top === window.self
	});
	/*@const*/
	_Object$defineProperty(Platform, 'isRunningInIFrame', {
	  value: !Platform.isRunningInTopFrame
	});
	/*@const*/
	_Object$defineProperty(Platform, 'isRunningInArgonApp', {
	  value: navigator.userAgent.indexOf('Argon') !== -1
	});
	/*@const*/
	_Object$defineProperty(Platform, 'isRunningInMobileBrowser', {
	  value: navigator.userAgent.indexOf('Mobile') !== -1
	});
	/*@const*/
	_Object$defineProperty(Platform, 'isRunningInDesktopBrowser', {
	  value: !Platform.isRunningOnMobileDevice
	});

	_Object$defineProperty(Platform, 'supportsDeviceOrientation', {
	  value: Platform.isRunningInArgonApp || window.DeviceOrientationEvent
	});

	exports['default'] = Platform;
	module.exports = exports['default'];

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(2),
	        __webpack_require__(125),
	        __webpack_require__(8),
	        __webpack_require__(128)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Color,
	        DeveloperError,
	        ColorMaterialProperty,
	        createPropertyDescriptor,
	        ImageMaterialProperty) {
	    "use strict";

	    function createMaterialProperty(value) {
	        if (value instanceof Color) {
	            return new ColorMaterialProperty(value);
	        }

	        if (typeof value === 'string') {
	            var result = new ImageMaterialProperty();
	            result.image = value;
	            return result;
	        }

	        //>>includeStart('debug', pragmas.debug);
	        throw new DeveloperError('Unable to infer material type: ' + value);
	        //>>includeEnd('debug');
	    }

	    /**
	     * @private
	     */
	    function createMaterialPropertyDescriptor(name, configurable) {
	        return createPropertyDescriptor(name, configurable, createMaterialProperty);
	    }

	    return createMaterialPropertyDescriptor;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(5);
	function assert(condition, msg1, msg2){
	  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
	}
	assert.def = $.assertDefined;
	assert.fn = function(it){
	  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');
	  return it;
	};
	assert.obj = function(it){
	  if(!$.isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};
	assert.inst = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};
	module.exports = assert;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Constants for identifying well-known reference frames.
	     *
	     * @namespace
	     * @alias ReferenceFrame
	     */
	    var ReferenceFrame = {
	        /**
	         * The fixed frame.
	         *
	         * @type {Number}
	         * @constant
	         */
	        FIXED : 0,

	        /**
	         * The inertial frame.
	         *
	         * @type {Number}
	         * @constant
	         */
	        INERTIAL : 1
	    };

	    return freezeObject(ReferenceFrame);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	var EventHandler = __webpack_require__(32).EventHandler;
	var OptionsManager = __webpack_require__(209);
	var Cesium = __webpack_require__(15);
	var OrientationProperty = Cesium.OrientationProperty;
	var Quaternion = Cesium.Quaternion;
	var Cartesian3 = Cesium.Cartesian3;
	var ReferenceFrame = Cesium.ReferenceFrame;
	var Transforms = Cesium.Transforms;
	var Matrix4 = Cesium.Matrix4;

	var scratchCartesianPositionFIXED = new Cesium.Cartesian3();
	var scratchMatrix3 = new Cesium.Matrix3();
	var scratchMatrix4 = new Matrix4();

	var urlParser = document.createElement('a');

	var Util = {
		cuid: __webpack_require__(208),
		resolveURL: function resolveURL(inURL) {
			if (inURL === undefined) throw new Error('Expected inURL');
			urlParser.href = null;
			urlParser.href = inURL;
			return urlParser.href;
		},
		parseURL: function parseURL(inURL) {
			if (inURL === undefined) throw new Error('Expected inURL');
			urlParser.href = null;
			urlParser.href = inURL;
			return {
				href: urlParser.href,
				protocol: urlParser.protocol,
				hostname: urlParser.hostname,
				port: urlParser.port,
				pathname: urlParser.pathname,
				search: urlParser.search,
				hash: urlParser.hash,
				host: urlParser.host
			};
		},
		resolvePropertyPath: function resolvePropertyPath(path, obj) {
			return [obj || self].concat(path.split('.')).reduce(function (prev, curr) {
				return prev ? prev[curr] : undefined;
			});
		},
		dispatch: (function () {
			var immediateChannel = new MessageChannel();
			var taskQueue = [];
			immediateChannel.port1.onmessage = function () {
				if (taskQueue.length === 0) return;
				var q = taskQueue;
				taskQueue = [];
				while (q.length > 0) {
					q.shift()();
				}
			};
			return function (task) {
				taskQueue.push(task);
				immediateChannel.port2.postMessage(0);
			};
		})(),
		mixinEventHandler: function mixinEventHandler(obj) {
			obj._eventHandler = new EventHandler();
			EventHandler.setInputHandler(obj, obj._eventHandler);
			EventHandler.setOutputHandler(obj, obj._eventHandler);
			obj.emit = obj._eventHandler.emit.bind(obj._eventHandler);
		},
		mixinInputOutputEventHandlers: function mixinInputOutputEventHandlers(obj) {
			obj._eventInput = new EventHandler();
			obj._eventOutput = new EventHandler();
			EventHandler.setInputHandler(obj, obj._eventInput);
			EventHandler.setOutputHandler(obj, obj._eventOutput);
			obj._emit = obj._eventOutput.emit.bind(obj._eventOutput);
			obj._on = obj._eventInput.on.bind(obj._eventInput);
		},
		mixinOptionsManager: function mixinOptionsManager(obj) {
			obj.options = {};
			obj._optionsManager = new OptionsManager(obj.options);
			obj._optionsManager.pipe(obj._eventOutput);
			obj.set = obj._optionsManager.set.bind(obj._optionsManager);
			obj.get = obj._optionsManager.get.bind(obj._optionsManager);
			obj.getOptions = obj._optionsManager.getOptions.bind(obj._optionsManager);
			obj.setOptions = obj._optionsManager.setOptions.bind(obj._optionsManager);

			obj._optionsManager.on('change', function (event) {
				obj._emit('change:' + event.id, event);
			});
		},
		ancestorReferenceFrames: function ancestorReferenceFrames(frame) {
			var frames = [];
			while (frame !== undefined && frame !== null) {
				frames.unshift(frame);
				frame = frame.position && frame.position.referenceFrame;
			}
			return frames;
		},
		rootReferenceFrame: function rootReferenceFrame(frame) {
			return Util.ancestorReferenceFrames(frame)[0];
		},
		getEntityPositionInReferenceFrame: function getEntityPositionInReferenceFrame(entity, time, referenceFrame, result) {
			return entity.position && entity.position.getValueInReferenceFrame(time, referenceFrame, result);
		},
		getEntityOrientationInReferenceFrame: function getEntityOrientationInReferenceFrame(entity, time, referenceFrame, result) {
			var entityFrame = entity.position && entity.position.referenceFrame;
			if (entityFrame === undefined) return undefined;
			var orientation = entity.orientation && entity.orientation.getValue(time, result);
			if (!orientation) {
				var entityPositionFIXED = Util.getEntityPositionInReferenceFrame(entity, time, ReferenceFrame.FIXED, scratchCartesianPositionFIXED);
				if (!entityPositionFIXED) return Quaternion.clone(Quaternion.IDENTITY, result);
				if (Cartesian3.ZERO.equals(entityPositionFIXED)) throw new Error('invalid cartographic position');
				orientation = Transforms.headingPitchRollQuaternion(entityPositionFIXED, 0, 0, 0, undefined, result);
				return OrientationProperty.convertToReferenceFrame(time, orientation, ReferenceFrame.FIXED, referenceFrame, result);
			}
			return OrientationProperty.convertToReferenceFrame(time, orientation, entityFrame, referenceFrame, result);
		}
	};

	module.exports = Util;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _WeakMap = __webpack_require__(50)['default'];

	var _getIterator = __webpack_require__(67)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _asapBrowserRaw = __webpack_require__(58);

	var _asapBrowserRaw2 = _interopRequireDefault(_asapBrowserRaw);

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _Platform = __webpack_require__(18);

	var _managerPort = __webpack_require__(40);

	var _managerPort2 = _interopRequireDefault(_managerPort);

	var _Channel = __webpack_require__(38);

	var _Channel2 = _interopRequireDefault(_Channel);

	var _cesiumCzmlWriter = __webpack_require__(148);

	var _cesiumCzmlWriter2 = _interopRequireDefault(_cesiumCzmlWriter);

	var dataSource = new _cesiumCesiumImports2['default'].CzmlDataSource();
	dataSource.load({
	  id: 'document',
	  name: 'argonDataSource',
	  version: '1.0',
	  clock: {}
	});
	dataSource.clock.canAnimate = false;

	exports['default'] = dataSource;

	if (_Platform.isChannel) {
	  (function () {

	    var publicationRequests = new _WeakMap();
	    var subscriptionRequests = new _WeakMap();

	    dataSource.publishEntity = function publishEntity(entity) {
	      var request = publicationRequests.get(entity);
	      if (!request) {
	        request = _managerPort2['default'].request('dataSource.publish', { id: entity.id }).then(function () {
	          _cesiumCzmlWriter2['default'].observeEntity(entity, function (packet) {
	            _managerPort2['default'].emit('dataSource.packet', { packet: packet });
	          });
	        }).then(function () {
	          return entity;
	        });
	        publicationRequests.set(entity, request);
	      }
	      return request;
	    };

	    dataSource.subscribeToEntityById = function subscribeToEntityById(entityId) {
	      var entity = dataSource.entities.getOrCreateEntity(entityId);
	      var request = publicationRequests.get(entity);
	      if (!request) {
	        request = _managerPort2['default'].request('dataSource.subscribe', { id: entity.id }).then(function () {
	          return entity;
	        });
	        publicationRequests.set(entity, request);
	      }
	      return request;
	    };

	    _managerPort2['default'].on('dataSource.packet', function (e) {
	      dataSource.process(e.packet);
	    });
	  })();
	}

	if (_Platform.isManager) {
	  (function () {

	    var ownerMap = new _WeakMap();
	    var subscriptionMap = {};

	    _Channel2['default'].port.on('dataSource.packet', function (e) {
	      var channel = _Channel2['default'].eventMap.get(e);
	      var packet = e.packet;

	      dataSource.entities.suspendEvents();
	      if (Array.isArray(packet)) {
	        for (var _iterator = packet, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
	          if (_isArray) {
	            if (_i >= _iterator.length) break;
	            p = _iterator[_i++];
	          } else {
	            _i = _iterator.next();
	            if (_i.done) break;
	            p = _i.value;
	          }

	          tryProcessPacket(channel, p);
	        }
	      } else {
	        tryProcessPacket(channel, packet);
	      }
	      dataSource.entities.resumeEvents();
	    });

	    _Channel2['default'].requestHandler['dataSource.subscribe'] = function (_ref) {
	      var channel = _ref.channel;
	      var data = _ref.data;

	      var entityId = data.id;
	      var entity = dataSource.entities.getById(entityId);
	      if (entity) {
	        var _ret3 = (function () {
	          var subscriptions = subscriptionMap[channel.id] = subscriptionMap[channel.id] || {};
	          var channelHasSubscription = subscriptions[entityId];
	          if (!channelHasSubscription) {
	            (function () {
	              var unobserve = _cesiumCzmlWriter2['default'].observeEntity(entity, function (packet) {
	                channel.port.emit('dataSource.packet', { packet: packet });
	              });
	              channel.once('unload', function () {
	                unobserve();
	                delete subscriptions[entityId];
	              });
	              subscriptions[entityId] = true;
	            })();
	          }
	          return {
	            v: _bluebird2['default'].resolve()
	          };
	        })();

	        if (typeof _ret3 === 'object') return _ret3.v;
	      }
	      return _bluebird2['default'].reject('Unable to subscribe to Entity. EntityId \'' + entityId + '\' has not been published');
	    };

	    _Channel2['default'].requestHandler['dataSource.publish'] = function (_ref2) {
	      var channel = _ref2.channel;
	      var data = _ref2.data;

	      var entityId = data.id;
	      var existingEntity = dataSource.entities.getById(entityId);
	      if (existingEntity) {
	        return _bluebird2['default'].reject('Unable to publish Entity. EntityId: \'' + entityId + '\' has already been published');
	      }
	      var entity = dataSource.entities.add({ id: entityId });
	      ownerMap.set(entity, channel);
	      channel.once('unload', function removeEntity() {
	        dataSource.entities.remove(entity);
	      });
	    };

	    var tryProcessPacket = function tryProcessPacket(channel, packet) {
	      var entityId = packet.id;
	      var entity = dataSource.entities.getById(entityId);
	      var owner = ownerMap.get(entity);
	      var isOwner = owner === channel;
	      if (isOwner) {
	        dataSource.process(packet);
	      } else if (entity) {
	        channel.port.emit('dataSource.processPacketError', {
	          message: 'Entity ' + entityId + ' is not owned by this channel.'
	        });
	      } else {
	        channel.port.emit('dataSource.processPacketError', {
	          message: 'Entity ' + entityId + ' has not been published by any channels.'
	        });
	      }
	    };
	  })();
	}
	module.exports = exports['default'];

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var sid = 0;
	function uid(key){
	  return 'Symbol(' + key + ')_' + (++sid + Math.random()).toString(36);
	}
	uid.safe = __webpack_require__(5).g.Symbol || uid;
	module.exports = uid;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _createClass = __webpack_require__(69)['default'];

	var _classCallCheck = __webpack_require__(26)['default'];

	var _Object$values = __webpack_require__(154)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _Argon = __webpack_require__(65);

	var _Argon2 = _interopRequireDefault(_Argon);

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _Util = __webpack_require__(22);

	var _Util2 = _interopRequireDefault(_Util);

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _Platform = __webpack_require__(18);

	var _dataSource = __webpack_require__(23);

	var _dataSource2 = _interopRequireDefault(_dataSource);

	var _entitiesEye = __webpack_require__(150);

	var _entitiesEye2 = _interopRequireDefault(_entitiesEye);

	function startLoop(reality) {
	  reality._loopRunning = true;
	  var lastFrameTime = 0;
	  function step(frameTime) {
	    if (reality._autoTick) {
	      if (reality.enabled) {
	        var targetFrameRate = reality._targetFrameRate;
	        if (!targetFrameRate) {
	          reality.clock.tick();
	          requestAnimationFrame(step);
	        } else {
	          var interval = 1000 / targetFrameRate;
	          var delta = frameTime - lastFrameTime;

	          if (delta > interval) {
	            reality.clock.tick();
	            lastFrameTime = frameTime - delta % interval;
	          }
	          requestAnimationFrame(step);
	        }
	      } else {
	        // if we are disabled, we'll keep going, but not tick()
	        requestAnimationFrame(step);
	      }
	    } else {
	      reality._loopRunning = false;
	    }
	  }

	  requestAnimationFrame(step);
	}

	function rootReferenceFrame(frame) {
	  var frames = [];
	  while (defined(frame) && frame !== null) {
	    frames.unshift(frame);
	    frame = frame.position && frame.position.referenceFrame;
	  }
	  return frames[0];
	}

	var Reality = (function () {
	  function Reality() {
	    var _this = this;

	    var config = arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Reality);

	    _Util2['default'].mixinInputOutputEventHandlers(this);
	    _Util2['default'].mixinOptionsManager(this);

	    this.id = config.id || _Util2['default'].cuid();
	    Reality.collection[this.id] = this;

	    this.type = config.type || undefined;
	    this.frustum = config.frustum || undefined;

	    this.eye = new _cesiumCesiumImports2['default'].Entity({
	      position: new _cesiumCesiumImports2['default'].ConstantPositionProperty(_cesiumCesiumImports2['default'].Cartesian3.ZERO, _entitiesEye2['default']),
	      orientation: new _cesiumCesiumImports2['default'].ConstantProperty(_cesiumCesiumImports2['default'].Quaternion.IDENTITY)
	    });
	    if (_Platform.isChannel) _dataSource2['default'].publishEntity(this.eye);

	    this.clock = new _cesiumCesiumImports2['default'].Clock();
	    this.clock.canAnimate = false;
	    this.clock.clockStep = _cesiumCesiumImports2['default'].ClockStep.SYSTEM_CLOCK;
	    this.clock.onTick.addEventListener(function (clock) {
	      if (_this.options.enabled) _this._emit('tick', { time: clock.currentTime });
	    });

	    this.cssDeps = config.cssDeps;
	    this.jsDeps = config.jsDeps;
	    this.renderScript = (config.renderScript || function () {}).toString();

	    if (config.options) this.setOptions(config.options);
	    if (config.init instanceof Function) config.init.call(this, _Argon2['default']);

	    this.autoTick = !!config.autoTick;
	    this.trusted = true;
	  }

	  Reality.prototype.getCSSResources = function getCSSResources() {
	    return getResources(this.cssDeps);
	  };

	  Reality.prototype.getJSResources = function getJSResources() {
	    return getResources(this.jsDeps);
	  };

	  Reality.prototype.destroy = function destroy() {
	    delete Reality.collection[this.id];
	  };

	  _createClass(Reality, [{
	    key: 'enabled',
	    set: function (value) {
	      this.set('enabled', value);
	    },
	    get: function () {
	      return this.options.enabled;
	    }
	  }, {
	    key: 'autoTick',
	    set: function (value) {
	      if (this._autoTick !== value) {
	        this._autoTick = value;
	        this.clock.canAnimate = value;
	        if (value) {
	          startLoop(this);
	        }
	      }
	    },
	    get: function () {
	      return this._autoTick;
	    }
	  }, {
	    key: 'configuration',
	    get: function () {
	      return {
	        id: this.id,
	        type: this.type,
	        cssDeps: this.cssDeps,
	        jsDeps: this.jsDeps,
	        renderScript: this.renderScript,
	        options: this.options
	      };
	    }
	  }]);

	  return Reality;
	})();

	exports['default'] = Reality;

	Reality.collection = {};

	Reality.query = function (identifier) {
	  // TODO
	  // const results = []
	  // for (const b in Reality.collection) {
	  //   if (b.type === identifier.type) results.push(b)
	  // }
	  return _Object$values(Reality.collection);
	};

	Reality.getById = function (id) {
	  return Reality.collection[id];
	};

	Reality.getOrCreate = function (id) {
	  return Reality.collection[id] || new Reality({ id: id });
	};

	Reality.fromConfiguration = function (config) {
	  var id = config.id;
	  var type = config.type;
	  var reality = Reality.collection[id];
	  if (!reality) {
	    var RealityType = Reality[type];
	    if (RealityType) {
	      reality = new RealityType(config);
	    } else {
	      reality = new Reality(config);
	      reality.trusted = false // unknown type, so use slower but secure messaging
	      ;
	    }
	  }
	  return reality;
	};

	function getResources() {
	  var deps = arguments[0] === undefined ? [] : arguments[0];

	  basket.clear(true); // clear expired files
	  return _bluebird2['default'].resolve(basket.require.apply(basket, deps.map(function (dep) {
	    return { url: dep, execute: false };
	  }))).then(function () {
	    return deps.map(function (dep) {
	      return basket.get(dep).data;
	    });
	  })['catch'](function (e) {
	    throw new Error('Unable to load resources: ' + e.toString());
	  });
	}
	module.exports = exports['default'];

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports["default"] = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	exports.__esModule = true;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(5)
	  , global     = $.g
	  , core       = $.core
	  , isFunction = $.isFunction;
	function ctx(fn, that){
	  return function(){
	    return fn.apply(that, arguments);
	  };
	}
	// type bitmap
	$def.F = 1;  // forced
	$def.G = 2;  // global
	$def.S = 4;  // static
	$def.P = 8;  // proto
	$def.B = 16; // bind
	$def.W = 32; // wrap
	function $def(type, name, source){
	  var key, own, out, exp
	    , isGlobal = type & $def.G
	    , target   = isGlobal ? global : type & $def.S
	        ? global[name] : (global[name] || {}).prototype
	    , exports  = isGlobal ? core : core[name] || (core[name] = {});
	  if(isGlobal)source = name;
	  for(key in source){
	    // contains in native
	    own = !(type & $def.F) && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    if(isGlobal && !isFunction(target[key]))exp = source[key];
	    // bind timers to global for call from export context
	    else if(type & $def.B && own)exp = ctx(out, global);
	    // wrap global constructors for prevent change them in library
	    else if(type & $def.W && target[key] == out)!function(C){
	      exp = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      exp.prototype = C.prototype;
	    }(out);
	    else exp = type & $def.P && isFunction(out) ? ctx(Function.call, out) : out;
	    // export
	    $.hide(exports, key, exp);
	  }
	}
	module.exports = $def;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(119),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError,
	        FeatureDetection,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    function hue2rgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        if (h > 1) {
	            h -= 1;
	        }
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * 6 * h;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	        }
	        return m1;
	    }

	    /**
	     * A color, specified using red, green, blue, and alpha values,
	     * which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
	     * @param {Number} [red=1.0] The red component.
	     * @param {Number} [green=1.0] The green component.
	     * @param {Number} [blue=1.0] The blue component.
	     * @param {Number} [alpha=1.0] The alpha component.
	     *
	     * @constructor
	     * @alias Color
	     *
	     * @see Packable
	     */
	    var Color = function(red, green, blue, alpha) {
	        /**
	         * The red component.
	         * @type {Number}
	         * @default 1.0
	         */
	        this.red = defaultValue(red, 1.0);
	        /**
	         * The green component.
	         * @type {Number}
	         * @default 1.0
	         */
	        this.green = defaultValue(green, 1.0);
	        /**
	         * The blue component.
	         * @type {Number}
	         * @default 1.0
	         */
	        this.blue = defaultValue(blue, 1.0);
	        /**
	         * The alpha component.
	         * @type {Number}
	         * @default 1.0
	         */
	        this.alpha = defaultValue(alpha, 1.0);
	    };

	    /**
	     * Creates a Color instance from a {@link Cartesian4}. <code>x</code>, <code>y</code>, <code>z</code>,
	     * and <code>w</code> map to <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>, respectively.
	     *
	     * @param {Cartesian4} cartesian The source cartesian.
	     * @param {Color} [result] The object onto which to store the result.
	     * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
	     */
	    Color.fromCartesian4 = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Color(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	        }

	        result.red = cartesian.x;
	        result.green = cartesian.y;
	        result.blue = cartesian.z;
	        result.alpha = cartesian.w;
	        return result;
	    };

	    /**
	     * Creates a new Color specified using red, green, blue, and alpha values
	     * that are in the range of 0 to 255, converting them internally to a range of 0.0 to 1.0.
	     *
	     * @param {Number} [red=255] The red component.
	     * @param {Number} [green=255] The green component.
	     * @param {Number} [blue=255] The blue component.
	     * @param {Number} [alpha=255] The alpha component.
	     * @param {Color} [result] The object onto which to store the result.
	     * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
	     */
	    Color.fromBytes = function(red, green, blue, alpha, result) {
	        red = Color.byteToFloat(defaultValue(red, 255.0));
	        green = Color.byteToFloat(defaultValue(green, 255.0));
	        blue = Color.byteToFloat(defaultValue(blue, 255.0));
	        alpha = Color.byteToFloat(defaultValue(alpha, 255.0));

	        if (!defined(result)) {
	            return new Color(red, green, blue, alpha);
	        }

	        result.red = red;
	        result.green = green;
	        result.blue = blue;
	        result.alpha = alpha;
	        return result;
	    };

	    /**
	     * Creates a new Color that has the same red, green, and blue components
	     * of the specified color, but with the specified alpha value.
	     *
	     * @param {Color} color The base color
	     * @param {Number} alpha The new alpha component.
	     * @param {Color} [result] The object onto which to store the result.
	     * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
	     *
	     * @example var translucentRed = Cesium.Color.fromColor(Cesium.Color.RED, 0.9);
	     */
	    Color.fromAlpha = function(color, alpha, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(color)) {
	            throw new DeveloperError('color is required');
	        }
	        if (!defined(alpha)) {
	            throw new DeveloperError('alpha is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Color(color.red, color.green, color.blue, alpha);
	        }

	        result.red = color.red;
	        result.green = color.green;
	        result.blue = color.blue;
	        result.alpha = alpha;
	        return result;
	    };

	    var scratchArrayBuffer;
	    var scratchUint32Array;
	    var scratchUint8Array;
	    if (FeatureDetection.supportsTypedArrays()) {
	        scratchArrayBuffer = new ArrayBuffer(4);
	        scratchUint32Array = new Uint32Array(scratchArrayBuffer);
	        scratchUint8Array = new Uint8Array(scratchArrayBuffer);
	    }

	    /**
	     * Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness
	     * of the system.
	     *
	     * @param {Number} rgba A single numeric unsigned 32-bit RGBA value.
	     * @returns {Color} A new color instance.
	     *
	     * @example
	     * var color = Cesium.Color.fromRgba(0x67ADDFFF);
	     *
	     * @see Color#toRgba
	     */
	    Color.fromRgba = function(rgba) {
	        // scratchUint32Array and scratchUint8Array share an underlying array buffer
	        scratchUint32Array[0] = rgba;
	        return Color.fromBytes(scratchUint8Array[0], scratchUint8Array[1], scratchUint8Array[2], scratchUint8Array[3]);
	    };

	    /**
	     * Creates a Color instance from hue, saturation, and lightness.
	     *
	     * @param {Number} [hue=0] The hue angle 0...1
	     * @param {Number} [saturation=0] The saturation value 0...1
	     * @param {Number} [lightness=0] The lightness value 0...1
	     * @param {Number} [alpha=1.0] The alpha component 0...1
	     * @returns {Color} The color object.
	     *
	     * @see {@link http://www.w3.org/TR/css3-color/#hsl-color|CSS color values}
	     */
	    Color.fromHsl = function(hue, saturation, lightness, alpha) {
	        hue = defaultValue(hue, 0.0) % 1.0;
	        saturation = defaultValue(saturation, 0.0);
	        lightness = defaultValue(lightness, 0.0);
	        alpha = defaultValue(alpha, 1.0);

	        var red = lightness;
	        var green = lightness;
	        var blue = lightness;

	        if (saturation !== 0) {
	            var m2;
	            if (lightness < 0.5) {
	                m2 = lightness * (1 + saturation);
	            } else {
	                m2 = lightness + saturation - lightness * saturation;
	            }

	            var m1 = 2.0 * lightness - m2;
	            red = hue2rgb(m1, m2, hue + 1 / 3);
	            green = hue2rgb(m1, m2, hue);
	            blue = hue2rgb(m1, m2, hue - 1 / 3);
	        }

	        return new Color(red, green, blue, alpha);
	    };

	    /**
	     * Creates a random color using the provided options. For reproducible random colors, you should
	     * call {@link CesiumMath#setRandomNumberSeed} once at the beginning of your application.
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Number} [options.red] If specified, the red component to use instead of a randomized value.
	     * @param {Number} [options.minimumRed=0.0] The maximum red value to generate if none was specified.
	     * @param {Number} [options.maximumRed=1.0] The minimum red value to generate if none was specified.
	     * @param {Number} [options.green] If specified, the green component to use instead of a randomized value.
	     * @param {Number} [options.minimumGreen=0.0] The maximum green value to generate if none was specified.
	     * @param {Number} [options.maximumGreen=1.0] The minimum green value to generate if none was specified.
	     * @param {Number} [options.blue] If specified, the blue component to use instead of a randomized value.
	     * @param {Number} [options.minimumBlue=0.0] The maximum blue value to generate if none was specified.
	     * @param {Number} [options.maximumBlue=1.0] The minimum blue value to generate if none was specified.
	     * @param {Number} [options.alpha] If specified, the alpha component to use instead of a randomized value.
	     * @param {Number} [options.minimumAlpha=0.0] The maximum alpha value to generate if none was specified.
	     * @param {Number} [options.maximumAlpha=1.0] The minimum alpha value to generate if none was specified.
	     * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
	     * @returns {Color} The modified result parameter or a new instance if result was undefined.
	     *
	     * @exception {DeveloperError} minimumRed must be less than or equal to maximumRed.
	     * @exception {DeveloperError} minimumGreen must be less than or equal to maximumGreen.
	     * @exception {DeveloperError} minimumBlue must be less than or equal to maximumBlue.
	     * @exception {DeveloperError} minimumAlpha must be less than or equal to maximumAlpha.
	     *
	     * @example
	     * //Create a completely random color
	     * var color = Cesium.Color.fromRandom();
	     *
	     * //Create a random shade of yellow.
	     * var color = Cesium.Color.fromRandom({
	     *     red : 1.0,
	     *     green : 1.0,
	     *     alpha : 1.0
	     * });
	     *
	     * //Create a random bright color.
	     * var color = Cesium.Color.fromRandom({
	     *     minimumRed : 0.75,
	     *     minimumGreen : 0.75,
	     *     minimumBlue : 0.75,
	     *     alpha : 1.0
	     * });
	     */
	    Color.fromRandom = function(options, result) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        var red = options.red;
	        if (!defined(red)) {
	            var minimumRed = defaultValue(options.minimumRed, 0);
	            var maximumRed = defaultValue(options.maximumRed, 1.0);

	            //>>includeStart('debug', pragmas.debug);
	            if (minimumRed > maximumRed) {
	                throw new DeveloperError("minimumRed must be less than or equal to maximumRed");
	            }
	            //>>includeEnd('debug');

	            red = minimumRed + (CesiumMath.nextRandomNumber() * (maximumRed - minimumRed));
	        }

	        var green = options.green;
	        if (!defined(green)) {
	            var minimumGreen = defaultValue(options.minimumGreen, 0);
	            var maximumGreen = defaultValue(options.maximumGreen, 1.0);

	            //>>includeStart('debug', pragmas.debug);
	            if (minimumGreen > maximumGreen) {
	                throw new DeveloperError("minimumGreen must be less than or equal to maximumGreen");
	            }
	            //>>includeEnd('debug');

	            green = minimumGreen + (CesiumMath.nextRandomNumber() * (maximumGreen - minimumGreen));
	        }

	        var blue = options.blue;
	        if (!defined(blue)) {
	            var minimumBlue = defaultValue(options.minimumBlue, 0);
	            var maximumBlue = defaultValue(options.maximumBlue, 1.0);

	            //>>includeStart('debug', pragmas.debug);
	            if (minimumBlue > maximumBlue) {
	                throw new DeveloperError("minimumBlue must be less than or equal to maximumBlue");
	            }
	            //>>includeEnd('debug');

	            blue = minimumBlue + (CesiumMath.nextRandomNumber() * (maximumBlue - minimumBlue));
	        }

	        var alpha = options.alpha;
	        if (!defined(alpha)) {
	            var minimumAlpha = defaultValue(options.minimumAlpha, 0);
	            var maximumAlpha = defaultValue(options.maximumAlpha, 1.0);

	            //>>includeStart('debug', pragmas.debug);
	            if (minimumAlpha > maximumAlpha) {
	                throw new DeveloperError("minimumAlpha must be less than or equal to maximumAlpha");
	            }
	            //>>includeEnd('debug');

	            alpha = minimumAlpha + (CesiumMath.nextRandomNumber() * (maximumAlpha - minimumAlpha));
	        }

	        if (!defined(result)) {
	            return new Color(red, green, blue, alpha);
	        }

	        result.red = red;
	        result.green = green;
	        result.blue = blue;
	        result.alpha = alpha;
	        return result;
	    };

	    //#rgb
	    var rgbMatcher = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i;
	    //#rrggbb
	    var rrggbbMatcher = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;
	    //rgb(), rgba(), or rgb%()
	    var rgbParenthesesMatcher = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
	    //hsl(), hsla(), or hsl%()
	    var hslParenthesesMatcher = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;

	    /**
	     * Creates a Color instance from a CSS color value.
	     *
	     * @param {String} color The CSS color value in #rgb, #rrggbb, rgb(), rgba(), hsl(), or hsla() format.
	     * @returns {Color} The color object, or undefined if the string was not a valid CSS color.
	     *
	     * @see {@link http://www.w3.org/TR/css3-color|CSS color values}
	     *
	     * @example
	     * var cesiumBlue = Cesium.Color.fromCssColorString('#67ADDF');
	     * var green = Cesium.Color.fromCssColorString('green');
	     */
	    Color.fromCssColorString = function(color) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(color)) {
	            throw new DeveloperError('color is required');
	        }
	        //>>includeEnd('debug');

	        var namedColor = Color[color.toUpperCase()];
	        if (defined(namedColor)) {
	            return Color.clone(namedColor);
	        }

	        var matches = rgbMatcher.exec(color);
	        if (matches !== null) {
	            return new Color(parseInt(matches[1], 16) / 15.0,
	                             parseInt(matches[2], 16) / 15.0,
	                             parseInt(matches[3], 16) / 15.0);
	        }

	        matches = rrggbbMatcher.exec(color);
	        if (matches !== null) {
	            return new Color(parseInt(matches[1], 16) / 255.0,
	                             parseInt(matches[2], 16) / 255.0,
	                             parseInt(matches[3], 16) / 255.0);
	        }

	        matches = rgbParenthesesMatcher.exec(color);
	        if (matches !== null) {
	            return new Color(parseFloat(matches[1]) / ('%' === matches[1].substr(-1) ? 100.0 : 255.0),
	                             parseFloat(matches[2]) / ('%' === matches[2].substr(-1) ? 100.0 : 255.0),
	                             parseFloat(matches[3]) / ('%' === matches[3].substr(-1) ? 100.0 : 255.0),
	                             parseFloat(defaultValue(matches[4], '1.0')));
	        }

	        matches = hslParenthesesMatcher.exec(color);
	        if (matches !== null) {
	            return Color.fromHsl(parseFloat(matches[1]) / 360.0,
	                                 parseFloat(matches[2]) / 100.0,
	                                 parseFloat(matches[3]) / 100.0,
	                                 parseFloat(defaultValue(matches[4], '1.0')));
	        }

	        return undefined;
	    };

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Color.packedLength = 4;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Color} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Color.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);
	        array[startingIndex++] = value.red;
	        array[startingIndex++] = value.green;
	        array[startingIndex++] = value.blue;
	        array[startingIndex] = value.alpha;
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Color} [result] The object into which to store the result.
	     */
	    Color.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);
	        if (!defined(result)) {
	            result = new Color();
	        }
	        result.red = array[startingIndex++];
	        result.green = array[startingIndex++];
	        result.blue = array[startingIndex++];
	        result.alpha = array[startingIndex];
	        return result;
	    };

	    /**
	     * Converts a 'byte' color component in the range of 0 to 255 into
	     * a 'float' color component in the range of 0 to 1.0.
	     *
	     * @param {Number} number The number to be converted.
	     * @returns {Number} The converted number.
	     */
	    Color.byteToFloat = function(number) {
	        return number / 255.0;
	    };

	    /**
	     * Converts a 'float' color component in the range of 0 to 1.0 into
	     * a 'byte' color component in the range of 0 to 255.
	     *
	     * @param {Number} number The number to be converted.
	     * @returns {Number} The converted number.
	     */
	    Color.floatToByte = function(number) {
	        return number === 1.0 ? 255.0 : (number * 256.0) | 0;
	    };

	    /**
	     * Duplicates a Color.
	     *
	     * @param {Color} color The Color to duplicate.
	     * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
	     * @returns {Color} The modified result parameter or a new instance if result was undefined. (Returns undefined if color is undefined)
	     */
	    Color.clone = function(color, result) {
	        if (!defined(color)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new Color(color.red, color.green, color.blue, color.alpha);
	        }
	        result.red = color.red;
	        result.green = color.green;
	        result.blue = color.blue;
	        result.alpha = color.alpha;
	        return result;
	    };

	    /**
	     * Returns true if the first Color equals the second color.
	     *
	     * @param {Color} left The first Color to compare for equality.
	     * @param {Color} right The second Color to compare for equality.
	     * @returns {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
	     */
	    Color.equals = function(left, right) {
	        return (left === right) || //
	               (defined(left) && //
	                defined(right) && //
	                left.red === right.red && //
	                left.green === right.green && //
	                left.blue === right.blue && //
	                left.alpha === right.alpha);
	    };

	    /**
	     * @private
	     */
	    Color.equalsArray = function(color, array, offset) {
	        return color.red === array[offset] &&
	               color.green === array[offset + 1] &&
	               color.blue === array[offset + 2] &&
	               color.alpha === array[offset + 3];
	    };

	    /**
	     * Returns a duplicate of a Color instance.
	     *
	     * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
	     * @returns {Color} The modified result parameter or a new instance if result was undefined.
	     */
	    Color.prototype.clone = function(result) {
	        return Color.clone(this, result);
	    };

	    /**
	     * Returns true if this Color equals other.
	     *
	     * @param {Color} other The Color to compare for equality.
	     * @returns {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
	     */
	    Color.prototype.equals = function(other) {
	        return Color.equals(this, other);
	    };

	    /**
	     * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
	     *
	     * @param {Color} other The Color to compare for equality.
	     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.
	     */
	    Color.prototype.equalsEpsilon = function(other, epsilon) {
	        return (this === other) || //
	               ((defined(other)) && //
	                (Math.abs(this.red - other.red) <= epsilon) && //
	                (Math.abs(this.green - other.green) <= epsilon) && //
	                (Math.abs(this.blue - other.blue) <= epsilon) && //
	                (Math.abs(this.alpha - other.alpha) <= epsilon));
	    };

	    /**
	     * Creates a string representing this Color in the format '(red, green, blue, alpha)'.
	     *
	     * @returns {String} A string representing this Color in the format '(red, green, blue, alpha)'.
	     */
	    Color.prototype.toString = function() {
	        return '(' + this.red + ', ' + this.green + ', ' + this.blue + ', ' + this.alpha + ')';
	    };

	    /**
	     * Creates a string containing the CSS color value for this color.
	     *
	     * @returns {String} The CSS equivalent of this color.
	     *
	     * @see {@link http://www.w3.org/TR/css3-color/#rgba-color|CSS RGB or RGBA color values}
	     */
	    Color.prototype.toCssColorString = function() {
	        var red = Color.floatToByte(this.red);
	        var green = Color.floatToByte(this.green);
	        var blue = Color.floatToByte(this.blue);
	        if (this.alpha === 1) {
	            return 'rgb(' + red + ',' + green + ',' + blue + ')';
	        }
	        return 'rgba(' + red + ',' + green + ',' + blue + ',' + this.alpha + ')';
	    };

	    /**
	     * Converts this color to an array of red, green, blue, and alpha values
	     * that are in the range of 0 to 255.
	     *
	     * @param {Number[]} [result] The array to store the result in, if undefined a new instance will be created.
	     * @returns {Number[]} The modified result parameter or a new instance if result was undefined.
	     */
	    Color.prototype.toBytes = function(result) {
	        var red = Color.floatToByte(this.red);
	        var green = Color.floatToByte(this.green);
	        var blue = Color.floatToByte(this.blue);
	        var alpha = Color.floatToByte(this.alpha);

	        if (!defined(result)) {
	            return [red, green, blue, alpha];
	        }
	        result[0] = red;
	        result[1] = green;
	        result[2] = blue;
	        result[3] = alpha;
	        return result;
	    };

	    /**
	     * Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness
	     * of the system.
	     *
	     * @returns {Number} A single numeric unsigned 32-bit RGBA value.
	     *
	     * @see Color.fromRgba
	     *
	     * @example
	     * var rgba = Cesium.Color.BLUE.toRgba();
	     */
	    Color.prototype.toRgba = function() {
	        // scratchUint32Array and scratchUint8Array share an underlying array buffer
	        scratchUint8Array[0] = Color.floatToByte(this.red);
	        scratchUint8Array[1] = Color.floatToByte(this.green);
	        scratchUint8Array[2] = Color.floatToByte(this.blue);
	        scratchUint8Array[3] = Color.floatToByte(this.alpha);
	        return scratchUint32Array[0];
	    };

	    /**
	     * Brightens this color by the provided magnitude.
	     *
	     * @param {Number} magnitude A positive number indicating the amount to brighten.
	     * @param {Color} result The object onto which to store the result.
	     * @returns {Color} The modified result parameter.
	     *
	     * @example
	     * var brightBlue = Cesium.Color.BLUE.brighten(0.5, new Color());
	     */
	    Color.prototype.brighten = function(magnitude, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(magnitude)) {
	            throw new DeveloperError('magnitude is required.');
	        }
	        if (magnitude < 0.0) {
	            throw new DeveloperError('magnitude must be positive.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        magnitude = (1.0 - magnitude);
	        result.red = 1.0 - ((1.0 - this.red) * magnitude);
	        result.green = 1.0 - ((1.0 - this.green) * magnitude);
	        result.blue = 1.0 - ((1.0 - this.blue) * magnitude);
	        result.alpha = this.alpha;
	        return result;
	    };

	    /**
	     * Darkens this color by the provided magnitude.
	     *
	     * @param {Number} magnitude A positive number indicating the amount to darken.
	     * @param {Color} result The object onto which to store the result.
	     * @returns {Color} The modified result parameter.
	     *
	     * @example
	     * var darkBlue = Cesium.Color.BLUE.darken(0.5, new Color());
	     */
	    Color.prototype.darken = function(magnitude, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(magnitude)) {
	            throw new DeveloperError('magnitude is required.');
	        }
	        if (magnitude < 0.0) {
	            throw new DeveloperError('magnitude must be positive.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        magnitude = (1.0 - magnitude);
	        result.red = this.red * magnitude;
	        result.green = this.green * magnitude;
	        result.blue = this.blue * magnitude;
	        result.alpha = this.alpha;
	        return result;
	    };

	    /**
	     * Creates a new Color that has the same red, green, and blue components
	     * as this Color, but with the specified alpha value.
	     *
	     * @param {Number} alpha The new alpha component.
	     * @param {Color} [result] The object onto which to store the result.
	     * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
	     *
	     * @example var translucentRed = Cesium.Color.RED.withAlpha(0.9);
	     */
	    Color.prototype.withAlpha = function(alpha, result) {
	        return Color.fromAlpha(this, alpha, result);
	    };

	    /**
	     * An immutable Color instance initialized to CSS color #F0F8FF
	     * <span class="colorSwath" style="background: #F0F8FF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.ALICEBLUE = freezeObject(Color.fromCssColorString('#F0F8FF'));

	    /**
	     * An immutable Color instance initialized to CSS color #FAEBD7
	     * <span class="colorSwath" style="background: #FAEBD7;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.ANTIQUEWHITE = freezeObject(Color.fromCssColorString('#FAEBD7'));

	    /**
	     * An immutable Color instance initialized to CSS color #00FFFF
	     * <span class="colorSwath" style="background: #00FFFF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.AQUA = freezeObject(Color.fromCssColorString('#00FFFF'));

	    /**
	     * An immutable Color instance initialized to CSS color #7FFFD4
	     * <span class="colorSwath" style="background: #7FFFD4;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.AQUAMARINE = freezeObject(Color.fromCssColorString('#7FFFD4'));

	    /**
	     * An immutable Color instance initialized to CSS color #F0FFFF
	     * <span class="colorSwath" style="background: #F0FFFF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.AZURE = freezeObject(Color.fromCssColorString('#F0FFFF'));

	    /**
	     * An immutable Color instance initialized to CSS color #F5F5DC
	     * <span class="colorSwath" style="background: #F5F5DC;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BEIGE = freezeObject(Color.fromCssColorString('#F5F5DC'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFE4C4
	     * <span class="colorSwath" style="background: #FFE4C4;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BISQUE = freezeObject(Color.fromCssColorString('#FFE4C4'));

	    /**
	     * An immutable Color instance initialized to CSS color #000000
	     * <span class="colorSwath" style="background: #000000;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BLACK = freezeObject(Color.fromCssColorString('#000000'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFEBCD
	     * <span class="colorSwath" style="background: #FFEBCD;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BLANCHEDALMOND = freezeObject(Color.fromCssColorString('#FFEBCD'));

	    /**
	     * An immutable Color instance initialized to CSS color #0000FF
	     * <span class="colorSwath" style="background: #0000FF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BLUE = freezeObject(Color.fromCssColorString('#0000FF'));

	    /**
	     * An immutable Color instance initialized to CSS color #8A2BE2
	     * <span class="colorSwath" style="background: #8A2BE2;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BLUEVIOLET = freezeObject(Color.fromCssColorString('#8A2BE2'));

	    /**
	     * An immutable Color instance initialized to CSS color #A52A2A
	     * <span class="colorSwath" style="background: #A52A2A;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BROWN = freezeObject(Color.fromCssColorString('#A52A2A'));

	    /**
	     * An immutable Color instance initialized to CSS color #DEB887
	     * <span class="colorSwath" style="background: #DEB887;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.BURLYWOOD = freezeObject(Color.fromCssColorString('#DEB887'));

	    /**
	     * An immutable Color instance initialized to CSS color #5F9EA0
	     * <span class="colorSwath" style="background: #5F9EA0;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CADETBLUE = freezeObject(Color.fromCssColorString('#5F9EA0'));
	    /**
	     * An immutable Color instance initialized to CSS color #7FFF00
	     * <span class="colorSwath" style="background: #7FFF00;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CHARTREUSE = freezeObject(Color.fromCssColorString('#7FFF00'));

	    /**
	     * An immutable Color instance initialized to CSS color #D2691E
	     * <span class="colorSwath" style="background: #D2691E;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CHOCOLATE = freezeObject(Color.fromCssColorString('#D2691E'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF7F50
	     * <span class="colorSwath" style="background: #FF7F50;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CORAL = freezeObject(Color.fromCssColorString('#FF7F50'));

	    /**
	     * An immutable Color instance initialized to CSS color #6495ED
	     * <span class="colorSwath" style="background: #6495ED;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CORNFLOWERBLUE = freezeObject(Color.fromCssColorString('#6495ED'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFF8DC
	     * <span class="colorSwath" style="background: #FFF8DC;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CORNSILK = freezeObject(Color.fromCssColorString('#FFF8DC'));

	    /**
	     * An immutable Color instance initialized to CSS color #DC143C
	     * <span class="colorSwath" style="background: #DC143C;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CRIMSON = freezeObject(Color.fromCssColorString('#DC143C'));

	    /**
	     * An immutable Color instance initialized to CSS color #00FFFF
	     * <span class="colorSwath" style="background: #00FFFF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.CYAN = freezeObject(Color.fromCssColorString('#00FFFF'));

	    /**
	     * An immutable Color instance initialized to CSS color #00008B
	     * <span class="colorSwath" style="background: #00008B;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKBLUE = freezeObject(Color.fromCssColorString('#00008B'));

	    /**
	     * An immutable Color instance initialized to CSS color #008B8B
	     * <span class="colorSwath" style="background: #008B8B;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKCYAN = freezeObject(Color.fromCssColorString('#008B8B'));

	    /**
	     * An immutable Color instance initialized to CSS color #B8860B
	     * <span class="colorSwath" style="background: #B8860B;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKGOLDENROD = freezeObject(Color.fromCssColorString('#B8860B'));

	    /**
	     * An immutable Color instance initialized to CSS color #A9A9A9
	     * <span class="colorSwath" style="background: #A9A9A9;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKGRAY = freezeObject(Color.fromCssColorString('#A9A9A9'));

	    /**
	     * An immutable Color instance initialized to CSS color #006400
	     * <span class="colorSwath" style="background: #006400;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKGREEN = freezeObject(Color.fromCssColorString('#006400'));

	    /**
	     * An immutable Color instance initialized to CSS color #A9A9A9
	     * <span class="colorSwath" style="background: #A9A9A9;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKGREY = Color.DARKGRAY;

	    /**
	     * An immutable Color instance initialized to CSS color #BDB76B
	     * <span class="colorSwath" style="background: #BDB76B;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKKHAKI = freezeObject(Color.fromCssColorString('#BDB76B'));

	    /**
	     * An immutable Color instance initialized to CSS color #8B008B
	     * <span class="colorSwath" style="background: #8B008B;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKMAGENTA = freezeObject(Color.fromCssColorString('#8B008B'));

	    /**
	     * An immutable Color instance initialized to CSS color #556B2F
	     * <span class="colorSwath" style="background: #556B2F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKOLIVEGREEN = freezeObject(Color.fromCssColorString('#556B2F'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF8C00
	     * <span class="colorSwath" style="background: #FF8C00;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKORANGE = freezeObject(Color.fromCssColorString('#FF8C00'));

	    /**
	     * An immutable Color instance initialized to CSS color #9932CC
	     * <span class="colorSwath" style="background: #9932CC;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKORCHID = freezeObject(Color.fromCssColorString('#9932CC'));

	    /**
	     * An immutable Color instance initialized to CSS color #8B0000
	     * <span class="colorSwath" style="background: #8B0000;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKRED = freezeObject(Color.fromCssColorString('#8B0000'));

	    /**
	     * An immutable Color instance initialized to CSS color #E9967A
	     * <span class="colorSwath" style="background: #E9967A;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKSALMON = freezeObject(Color.fromCssColorString('#E9967A'));

	    /**
	     * An immutable Color instance initialized to CSS color #8FBC8F
	     * <span class="colorSwath" style="background: #8FBC8F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKSEAGREEN = freezeObject(Color.fromCssColorString('#8FBC8F'));

	    /**
	     * An immutable Color instance initialized to CSS color #483D8B
	     * <span class="colorSwath" style="background: #483D8B;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKSLATEBLUE = freezeObject(Color.fromCssColorString('#483D8B'));

	    /**
	     * An immutable Color instance initialized to CSS color #2F4F4F
	     * <span class="colorSwath" style="background: #2F4F4F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKSLATEGRAY = freezeObject(Color.fromCssColorString('#2F4F4F'));

	    /**
	     * An immutable Color instance initialized to CSS color #2F4F4F
	     * <span class="colorSwath" style="background: #2F4F4F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKSLATEGREY = Color.DARKSLATEGRAY;

	    /**
	     * An immutable Color instance initialized to CSS color #00CED1
	     * <span class="colorSwath" style="background: #00CED1;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKTURQUOISE = freezeObject(Color.fromCssColorString('#00CED1'));

	    /**
	     * An immutable Color instance initialized to CSS color #9400D3
	     * <span class="colorSwath" style="background: #9400D3;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DARKVIOLET = freezeObject(Color.fromCssColorString('#9400D3'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF1493
	     * <span class="colorSwath" style="background: #FF1493;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DEEPPINK = freezeObject(Color.fromCssColorString('#FF1493'));

	    /**
	     * An immutable Color instance initialized to CSS color #00BFFF
	     * <span class="colorSwath" style="background: #00BFFF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DEEPSKYBLUE = freezeObject(Color.fromCssColorString('#00BFFF'));

	    /**
	     * An immutable Color instance initialized to CSS color #696969
	     * <span class="colorSwath" style="background: #696969;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DIMGRAY = freezeObject(Color.fromCssColorString('#696969'));

	    /**
	     * An immutable Color instance initialized to CSS color #696969
	     * <span class="colorSwath" style="background: #696969;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DIMGREY = Color.DIMGRAY;

	    /**
	     * An immutable Color instance initialized to CSS color #1E90FF
	     * <span class="colorSwath" style="background: #1E90FF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.DODGERBLUE = freezeObject(Color.fromCssColorString('#1E90FF'));

	    /**
	     * An immutable Color instance initialized to CSS color #B22222
	     * <span class="colorSwath" style="background: #B22222;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.FIREBRICK = freezeObject(Color.fromCssColorString('#B22222'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFFAF0
	     * <span class="colorSwath" style="background: #FFFAF0;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.FLORALWHITE = freezeObject(Color.fromCssColorString('#FFFAF0'));

	    /**
	     * An immutable Color instance initialized to CSS color #228B22
	     * <span class="colorSwath" style="background: #228B22;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.FORESTGREEN = freezeObject(Color.fromCssColorString('#228B22'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF00FF
	     * <span class="colorSwath" style="background: #FF00FF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.FUSCHIA = freezeObject(Color.fromCssColorString('#FF00FF'));

	    /**
	     * An immutable Color instance initialized to CSS color #DCDCDC
	     * <span class="colorSwath" style="background: #DCDCDC;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GAINSBORO = freezeObject(Color.fromCssColorString('#DCDCDC'));

	    /**
	     * An immutable Color instance initialized to CSS color #F8F8FF
	     * <span class="colorSwath" style="background: #F8F8FF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GHOSTWHITE = freezeObject(Color.fromCssColorString('#F8F8FF'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFD700
	     * <span class="colorSwath" style="background: #FFD700;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GOLD = freezeObject(Color.fromCssColorString('#FFD700'));

	    /**
	     * An immutable Color instance initialized to CSS color #DAA520
	     * <span class="colorSwath" style="background: #DAA520;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GOLDENROD = freezeObject(Color.fromCssColorString('#DAA520'));

	    /**
	     * An immutable Color instance initialized to CSS color #808080
	     * <span class="colorSwath" style="background: #808080;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GRAY = freezeObject(Color.fromCssColorString('#808080'));

	    /**
	     * An immutable Color instance initialized to CSS color #008000
	     * <span class="colorSwath" style="background: #008000;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GREEN = freezeObject(Color.fromCssColorString('#008000'));

	    /**
	     * An immutable Color instance initialized to CSS color #ADFF2F
	     * <span class="colorSwath" style="background: #ADFF2F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GREENYELLOW = freezeObject(Color.fromCssColorString('#ADFF2F'));

	    /**
	     * An immutable Color instance initialized to CSS color #808080
	     * <span class="colorSwath" style="background: #808080;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.GREY = Color.GRAY;

	    /**
	     * An immutable Color instance initialized to CSS color #F0FFF0
	     * <span class="colorSwath" style="background: #F0FFF0;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.HONEYDEW = freezeObject(Color.fromCssColorString('#F0FFF0'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF69B4
	     * <span class="colorSwath" style="background: #FF69B4;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.HOTPINK = freezeObject(Color.fromCssColorString('#FF69B4'));

	    /**
	     * An immutable Color instance initialized to CSS color #CD5C5C
	     * <span class="colorSwath" style="background: #CD5C5C;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.INDIANRED = freezeObject(Color.fromCssColorString('#CD5C5C'));

	    /**
	     * An immutable Color instance initialized to CSS color #4B0082
	     * <span class="colorSwath" style="background: #4B0082;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.INDIGO = freezeObject(Color.fromCssColorString('#4B0082'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFFFF0
	     * <span class="colorSwath" style="background: #FFFFF0;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.IVORY = freezeObject(Color.fromCssColorString('#FFFFF0'));

	    /**
	     * An immutable Color instance initialized to CSS color #F0E68C
	     * <span class="colorSwath" style="background: #F0E68C;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.KHAKI = freezeObject(Color.fromCssColorString('#F0E68C'));

	    /**
	     * An immutable Color instance initialized to CSS color #E6E6FA
	     * <span class="colorSwath" style="background: #E6E6FA;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LAVENDER = freezeObject(Color.fromCssColorString('#E6E6FA'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFF0F5
	     * <span class="colorSwath" style="background: #FFF0F5;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LAVENDAR_BLUSH = freezeObject(Color.fromCssColorString('#FFF0F5'));

	    /**
	     * An immutable Color instance initialized to CSS color #7CFC00
	     * <span class="colorSwath" style="background: #7CFC00;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LAWNGREEN = freezeObject(Color.fromCssColorString('#7CFC00'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFFACD
	     * <span class="colorSwath" style="background: #FFFACD;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LEMONCHIFFON = freezeObject(Color.fromCssColorString('#FFFACD'));

	    /**
	     * An immutable Color instance initialized to CSS color #ADD8E6
	     * <span class="colorSwath" style="background: #ADD8E6;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTBLUE = freezeObject(Color.fromCssColorString('#ADD8E6'));

	    /**
	     * An immutable Color instance initialized to CSS color #F08080
	     * <span class="colorSwath" style="background: #F08080;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTCORAL = freezeObject(Color.fromCssColorString('#F08080'));

	    /**
	     * An immutable Color instance initialized to CSS color #E0FFFF
	     * <span class="colorSwath" style="background: #E0FFFF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTCYAN = freezeObject(Color.fromCssColorString('#E0FFFF'));

	    /**
	     * An immutable Color instance initialized to CSS color #FAFAD2
	     * <span class="colorSwath" style="background: #FAFAD2;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTGOLDENRODYELLOW = freezeObject(Color.fromCssColorString('#FAFAD2'));

	    /**
	     * An immutable Color instance initialized to CSS color #D3D3D3
	     * <span class="colorSwath" style="background: #D3D3D3;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTGRAY = freezeObject(Color.fromCssColorString('#D3D3D3'));

	    /**
	     * An immutable Color instance initialized to CSS color #90EE90
	     * <span class="colorSwath" style="background: #90EE90;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTGREEN = freezeObject(Color.fromCssColorString('#90EE90'));

	    /**
	     * An immutable Color instance initialized to CSS color #D3D3D3
	     * <span class="colorSwath" style="background: #D3D3D3;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTGREY = Color.LIGHTGRAY;

	    /**
	     * An immutable Color instance initialized to CSS color #FFB6C1
	     * <span class="colorSwath" style="background: #FFB6C1;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTPINK = freezeObject(Color.fromCssColorString('#FFB6C1'));

	    /**
	     * An immutable Color instance initialized to CSS color #20B2AA
	     * <span class="colorSwath" style="background: #20B2AA;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTSEAGREEN = freezeObject(Color.fromCssColorString('#20B2AA'));

	    /**
	     * An immutable Color instance initialized to CSS color #87CEFA
	     * <span class="colorSwath" style="background: #87CEFA;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTSKYBLUE = freezeObject(Color.fromCssColorString('#87CEFA'));

	    /**
	     * An immutable Color instance initialized to CSS color #778899
	     * <span class="colorSwath" style="background: #778899;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTSLATEGRAY = freezeObject(Color.fromCssColorString('#778899'));

	    /**
	     * An immutable Color instance initialized to CSS color #778899
	     * <span class="colorSwath" style="background: #778899;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTSLATEGREY = Color.LIGHTSLATEGRAY;

	    /**
	     * An immutable Color instance initialized to CSS color #B0C4DE
	     * <span class="colorSwath" style="background: #B0C4DE;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTSTEELBLUE = freezeObject(Color.fromCssColorString('#B0C4DE'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFFFE0
	     * <span class="colorSwath" style="background: #FFFFE0;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIGHTYELLOW = freezeObject(Color.fromCssColorString('#FFFFE0'));

	    /**
	     * An immutable Color instance initialized to CSS color #00FF00
	     * <span class="colorSwath" style="background: #00FF00;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIME = freezeObject(Color.fromCssColorString('#00FF00'));

	    /**
	     * An immutable Color instance initialized to CSS color #32CD32
	     * <span class="colorSwath" style="background: #32CD32;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LIMEGREEN = freezeObject(Color.fromCssColorString('#32CD32'));

	    /**
	     * An immutable Color instance initialized to CSS color #FAF0E6
	     * <span class="colorSwath" style="background: #FAF0E6;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.LINEN = freezeObject(Color.fromCssColorString('#FAF0E6'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF00FF
	     * <span class="colorSwath" style="background: #FF00FF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MAGENTA = freezeObject(Color.fromCssColorString('#FF00FF'));

	    /**
	     * An immutable Color instance initialized to CSS color #800000
	     * <span class="colorSwath" style="background: #800000;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MAROON = freezeObject(Color.fromCssColorString('#800000'));

	    /**
	     * An immutable Color instance initialized to CSS color #66CDAA
	     * <span class="colorSwath" style="background: #66CDAA;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMAQUAMARINE = freezeObject(Color.fromCssColorString('#66CDAA'));

	    /**
	     * An immutable Color instance initialized to CSS color #0000CD
	     * <span class="colorSwath" style="background: #0000CD;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMBLUE = freezeObject(Color.fromCssColorString('#0000CD'));

	    /**
	     * An immutable Color instance initialized to CSS color #BA55D3
	     * <span class="colorSwath" style="background: #BA55D3;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMORCHID = freezeObject(Color.fromCssColorString('#BA55D3'));

	    /**
	     * An immutable Color instance initialized to CSS color #9370DB
	     * <span class="colorSwath" style="background: #9370DB;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMPURPLE = freezeObject(Color.fromCssColorString('#9370DB'));

	    /**
	     * An immutable Color instance initialized to CSS color #3CB371
	     * <span class="colorSwath" style="background: #3CB371;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMSEAGREEN = freezeObject(Color.fromCssColorString('#3CB371'));

	    /**
	     * An immutable Color instance initialized to CSS color #7B68EE
	     * <span class="colorSwath" style="background: #7B68EE;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMSLATEBLUE = freezeObject(Color.fromCssColorString('#7B68EE'));

	    /**
	     * An immutable Color instance initialized to CSS color #00FA9A
	     * <span class="colorSwath" style="background: #00FA9A;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMSPRINGGREEN = freezeObject(Color.fromCssColorString('#00FA9A'));

	    /**
	     * An immutable Color instance initialized to CSS color #48D1CC
	     * <span class="colorSwath" style="background: #48D1CC;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMTURQUOISE = freezeObject(Color.fromCssColorString('#48D1CC'));

	    /**
	     * An immutable Color instance initialized to CSS color #C71585
	     * <span class="colorSwath" style="background: #C71585;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MEDIUMVIOLETRED = freezeObject(Color.fromCssColorString('#C71585'));

	    /**
	     * An immutable Color instance initialized to CSS color #191970
	     * <span class="colorSwath" style="background: #191970;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MIDNIGHTBLUE = freezeObject(Color.fromCssColorString('#191970'));

	    /**
	     * An immutable Color instance initialized to CSS color #F5FFFA
	     * <span class="colorSwath" style="background: #F5FFFA;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MINTCREAM = freezeObject(Color.fromCssColorString('#F5FFFA'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFE4E1
	     * <span class="colorSwath" style="background: #FFE4E1;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MISTYROSE = freezeObject(Color.fromCssColorString('#FFE4E1'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFE4B5
	     * <span class="colorSwath" style="background: #FFE4B5;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.MOCCASIN = freezeObject(Color.fromCssColorString('#FFE4B5'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFDEAD
	     * <span class="colorSwath" style="background: #FFDEAD;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.NAVAJOWHITE = freezeObject(Color.fromCssColorString('#FFDEAD'));

	    /**
	     * An immutable Color instance initialized to CSS color #000080
	     * <span class="colorSwath" style="background: #000080;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.NAVY = freezeObject(Color.fromCssColorString('#000080'));

	    /**
	     * An immutable Color instance initialized to CSS color #FDF5E6
	     * <span class="colorSwath" style="background: #FDF5E6;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.OLDLACE = freezeObject(Color.fromCssColorString('#FDF5E6'));

	    /**
	     * An immutable Color instance initialized to CSS color #808000
	     * <span class="colorSwath" style="background: #808000;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.OLIVE = freezeObject(Color.fromCssColorString('#808000'));

	    /**
	     * An immutable Color instance initialized to CSS color #6B8E23
	     * <span class="colorSwath" style="background: #6B8E23;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.OLIVEDRAB = freezeObject(Color.fromCssColorString('#6B8E23'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFA500
	     * <span class="colorSwath" style="background: #FFA500;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.ORANGE = freezeObject(Color.fromCssColorString('#FFA500'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF4500
	     * <span class="colorSwath" style="background: #FF4500;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.ORANGERED = freezeObject(Color.fromCssColorString('#FF4500'));

	    /**
	     * An immutable Color instance initialized to CSS color #DA70D6
	     * <span class="colorSwath" style="background: #DA70D6;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.ORCHID = freezeObject(Color.fromCssColorString('#DA70D6'));

	    /**
	     * An immutable Color instance initialized to CSS color #EEE8AA
	     * <span class="colorSwath" style="background: #EEE8AA;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PALEGOLDENROD = freezeObject(Color.fromCssColorString('#EEE8AA'));

	    /**
	     * An immutable Color instance initialized to CSS color #98FB98
	     * <span class="colorSwath" style="background: #98FB98;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PALEGREEN = freezeObject(Color.fromCssColorString('#98FB98'));

	    /**
	     * An immutable Color instance initialized to CSS color #AFEEEE
	     * <span class="colorSwath" style="background: #AFEEEE;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PALETURQUOISE = freezeObject(Color.fromCssColorString('#AFEEEE'));

	    /**
	     * An immutable Color instance initialized to CSS color #DB7093
	     * <span class="colorSwath" style="background: #DB7093;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PALEVIOLETRED = freezeObject(Color.fromCssColorString('#DB7093'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFEFD5
	     * <span class="colorSwath" style="background: #FFEFD5;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PAPAYAWHIP = freezeObject(Color.fromCssColorString('#FFEFD5'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFDAB9
	     * <span class="colorSwath" style="background: #FFDAB9;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PEACHPUFF = freezeObject(Color.fromCssColorString('#FFDAB9'));

	    /**
	     * An immutable Color instance initialized to CSS color #CD853F
	     * <span class="colorSwath" style="background: #CD853F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PERU = freezeObject(Color.fromCssColorString('#CD853F'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFC0CB
	     * <span class="colorSwath" style="background: #FFC0CB;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PINK = freezeObject(Color.fromCssColorString('#FFC0CB'));

	    /**
	     * An immutable Color instance initialized to CSS color #DDA0DD
	     * <span class="colorSwath" style="background: #DDA0DD;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PLUM = freezeObject(Color.fromCssColorString('#DDA0DD'));

	    /**
	     * An immutable Color instance initialized to CSS color #B0E0E6
	     * <span class="colorSwath" style="background: #B0E0E6;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.POWDERBLUE = freezeObject(Color.fromCssColorString('#B0E0E6'));

	    /**
	     * An immutable Color instance initialized to CSS color #800080
	     * <span class="colorSwath" style="background: #800080;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.PURPLE = freezeObject(Color.fromCssColorString('#800080'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF0000
	     * <span class="colorSwath" style="background: #FF0000;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.RED = freezeObject(Color.fromCssColorString('#FF0000'));

	    /**
	     * An immutable Color instance initialized to CSS color #BC8F8F
	     * <span class="colorSwath" style="background: #BC8F8F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.ROSYBROWN = freezeObject(Color.fromCssColorString('#BC8F8F'));

	    /**
	     * An immutable Color instance initialized to CSS color #4169E1
	     * <span class="colorSwath" style="background: #4169E1;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.ROYALBLUE = freezeObject(Color.fromCssColorString('#4169E1'));

	    /**
	     * An immutable Color instance initialized to CSS color #8B4513
	     * <span class="colorSwath" style="background: #8B4513;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SADDLEBROWN = freezeObject(Color.fromCssColorString('#8B4513'));

	    /**
	     * An immutable Color instance initialized to CSS color #FA8072
	     * <span class="colorSwath" style="background: #FA8072;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SALMON = freezeObject(Color.fromCssColorString('#FA8072'));

	    /**
	     * An immutable Color instance initialized to CSS color #F4A460
	     * <span class="colorSwath" style="background: #F4A460;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SANDYBROWN = freezeObject(Color.fromCssColorString('#F4A460'));

	    /**
	     * An immutable Color instance initialized to CSS color #2E8B57
	     * <span class="colorSwath" style="background: #2E8B57;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SEAGREEN = freezeObject(Color.fromCssColorString('#2E8B57'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFF5EE
	     * <span class="colorSwath" style="background: #FFF5EE;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SEASHELL = freezeObject(Color.fromCssColorString('#FFF5EE'));

	    /**
	     * An immutable Color instance initialized to CSS color #A0522D
	     * <span class="colorSwath" style="background: #A0522D;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SIENNA = freezeObject(Color.fromCssColorString('#A0522D'));

	    /**
	     * An immutable Color instance initialized to CSS color #C0C0C0
	     * <span class="colorSwath" style="background: #C0C0C0;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SILVER = freezeObject(Color.fromCssColorString('#C0C0C0'));

	    /**
	     * An immutable Color instance initialized to CSS color #87CEEB
	     * <span class="colorSwath" style="background: #87CEEB;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SKYBLUE = freezeObject(Color.fromCssColorString('#87CEEB'));

	    /**
	     * An immutable Color instance initialized to CSS color #6A5ACD
	     * <span class="colorSwath" style="background: #6A5ACD;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SLATEBLUE = freezeObject(Color.fromCssColorString('#6A5ACD'));

	    /**
	     * An immutable Color instance initialized to CSS color #708090
	     * <span class="colorSwath" style="background: #708090;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SLATEGRAY = freezeObject(Color.fromCssColorString('#708090'));

	    /**
	     * An immutable Color instance initialized to CSS color #708090
	     * <span class="colorSwath" style="background: #708090;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SLATEGREY = Color.SLATEGRAY;

	    /**
	     * An immutable Color instance initialized to CSS color #FFFAFA
	     * <span class="colorSwath" style="background: #FFFAFA;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SNOW = freezeObject(Color.fromCssColorString('#FFFAFA'));

	    /**
	     * An immutable Color instance initialized to CSS color #00FF7F
	     * <span class="colorSwath" style="background: #00FF7F;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.SPRINGGREEN = freezeObject(Color.fromCssColorString('#00FF7F'));

	    /**
	     * An immutable Color instance initialized to CSS color #4682B4
	     * <span class="colorSwath" style="background: #4682B4;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.STEELBLUE = freezeObject(Color.fromCssColorString('#4682B4'));

	    /**
	     * An immutable Color instance initialized to CSS color #D2B48C
	     * <span class="colorSwath" style="background: #D2B48C;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.TAN = freezeObject(Color.fromCssColorString('#D2B48C'));

	    /**
	     * An immutable Color instance initialized to CSS color #008080
	     * <span class="colorSwath" style="background: #008080;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.TEAL = freezeObject(Color.fromCssColorString('#008080'));

	    /**
	     * An immutable Color instance initialized to CSS color #D8BFD8
	     * <span class="colorSwath" style="background: #D8BFD8;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.THISTLE = freezeObject(Color.fromCssColorString('#D8BFD8'));

	    /**
	     * An immutable Color instance initialized to CSS color #FF6347
	     * <span class="colorSwath" style="background: #FF6347;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.TOMATO = freezeObject(Color.fromCssColorString('#FF6347'));

	    /**
	     * An immutable Color instance initialized to CSS color #40E0D0
	     * <span class="colorSwath" style="background: #40E0D0;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.TURQUOISE = freezeObject(Color.fromCssColorString('#40E0D0'));

	    /**
	     * An immutable Color instance initialized to CSS color #EE82EE
	     * <span class="colorSwath" style="background: #EE82EE;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.VIOLET = freezeObject(Color.fromCssColorString('#EE82EE'));

	    /**
	     * An immutable Color instance initialized to CSS color #F5DEB3
	     * <span class="colorSwath" style="background: #F5DEB3;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.WHEAT = freezeObject(Color.fromCssColorString('#F5DEB3'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFFFFF
	     * <span class="colorSwath" style="background: #FFFFFF;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.WHITE = freezeObject(Color.fromCssColorString('#FFFFFF'));

	    /**
	     * An immutable Color instance initialized to CSS color #F5F5F5
	     * <span class="colorSwath" style="background: #F5F5F5;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.WHITESMOKE = freezeObject(Color.fromCssColorString('#F5F5F5'));

	    /**
	     * An immutable Color instance initialized to CSS color #FFFF00
	     * <span class="colorSwath" style="background: #FFFF00;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.YELLOW = freezeObject(Color.fromCssColorString('#FFFF00'));

	    /**
	     * An immutable Color instance initialized to CSS color #9ACD32
	     * <span class="colorSwath" style="background: #9ACD32;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.YELLOWGREEN = freezeObject(Color.fromCssColorString('#9ACD32'));

	    /**
	     * An immutable Color instance initialized to CSS transparent.
	     * <span class="colorSwath" style="background: transparent;"></span>
	     *
	     * @constant
	     * @type {Color}
	     */
	    Color.TRANSPARENT = freezeObject(new Color(0, 0, 0, 0));

	    return Color;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        defaultValue,
	        defined,
	        DeveloperError,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    /**
	     * A 3x3 matrix, indexable as a column-major order array.
	     * Constructor parameters are in row-major order for code readability.
	     * @alias Matrix3
	     * @constructor
	     *
	     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
	     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
	     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
	     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
	     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
	     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
	     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
	     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
	     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
	     *
	     * @see Matrix3.fromColumnMajorArray
	     * @see Matrix3.fromRowMajorArray
	     * @see Matrix3.fromQuaternion
	     * @see Matrix3.fromScale
	     * @see Matrix3.fromUniformScale
	     * @see Matrix2
	     * @see Matrix4
	     */
	    var Matrix3 = function(column0Row0, column1Row0, column2Row0,
	                           column0Row1, column1Row1, column2Row1,
	                           column0Row2, column1Row2, column2Row2) {
	        this[0] = defaultValue(column0Row0, 0.0);
	        this[1] = defaultValue(column0Row1, 0.0);
	        this[2] = defaultValue(column0Row2, 0.0);
	        this[3] = defaultValue(column1Row0, 0.0);
	        this[4] = defaultValue(column1Row1, 0.0);
	        this[5] = defaultValue(column1Row2, 0.0);
	        this[6] = defaultValue(column2Row0, 0.0);
	        this[7] = defaultValue(column2Row1, 0.0);
	        this[8] = defaultValue(column2Row2, 0.0);
	    };

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Matrix3.packedLength = 9;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Matrix3} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Matrix3.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }

	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value[0];
	        array[startingIndex++] = value[1];
	        array[startingIndex++] = value[2];
	        array[startingIndex++] = value[3];
	        array[startingIndex++] = value[4];
	        array[startingIndex++] = value[5];
	        array[startingIndex++] = value[6];
	        array[startingIndex++] = value[7];
	        array[startingIndex++] = value[8];
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Matrix3} [result] The object into which to store the result.
	     */
	    Matrix3.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Matrix3();
	        }

	        result[0] = array[startingIndex++];
	        result[1] = array[startingIndex++];
	        result[2] = array[startingIndex++];
	        result[3] = array[startingIndex++];
	        result[4] = array[startingIndex++];
	        result[5] = array[startingIndex++];
	        result[6] = array[startingIndex++];
	        result[7] = array[startingIndex++];
	        result[8] = array[startingIndex++];
	        return result;
	    };

	    /**
	     * Duplicates a Matrix3 instance.
	     *
	     * @param {Matrix3} matrix The matrix to duplicate.
	     * @param {Matrix3} [result] The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)
	     */
	    Matrix3.clone = function(values, result) {
	        if (!defined(values)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new Matrix3(values[0], values[3], values[6],
	                               values[1], values[4], values[7],
	                               values[2], values[5], values[8]);
	        }
	        result[0] = values[0];
	        result[1] = values[1];
	        result[2] = values[2];
	        result[3] = values[3];
	        result[4] = values[4];
	        result[5] = values[5];
	        result[6] = values[6];
	        result[7] = values[7];
	        result[8] = values[8];
	        return result;
	    };

	    /**
	     * Creates a Matrix3 from 9 consecutive elements in an array.
	     *
	     * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
	     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
	     * @param {Matrix3} [result] The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
	     *
	     * @example
	     * // Create the Matrix3:
	     * // [1.0, 2.0, 3.0]
	     * // [1.0, 2.0, 3.0]
	     * // [1.0, 2.0, 3.0]
	     *
	     * var v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
	     * var m = Cesium.Matrix3.fromArray(v);
	     *
	     * // Create same Matrix3 with using an offset into an array
	     * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
	     * var m2 = Cesium.Matrix3.fromArray(v2, 2);
	     */
	    Matrix3.fromArray = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Matrix3();
	        }

	        result[0] = array[startingIndex];
	        result[1] = array[startingIndex + 1];
	        result[2] = array[startingIndex + 2];
	        result[3] = array[startingIndex + 3];
	        result[4] = array[startingIndex + 4];
	        result[5] = array[startingIndex + 5];
	        result[6] = array[startingIndex + 6];
	        result[7] = array[startingIndex + 7];
	        result[8] = array[startingIndex + 8];
	        return result;
	    };

	    /**
	     * Creates a Matrix3 instance from a column-major order array.
	     *
	     * @param {Number[]} values The column-major order array.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     */
	    Matrix3.fromColumnMajorArray = function(values, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(values)) {
	            throw new DeveloperError('values parameter is required');
	        }
	        //>>includeEnd('debug');

	        return Matrix3.clone(values, result);
	    };

	    /**
	     * Creates a Matrix3 instance from a row-major order array.
	     * The resulting matrix will be in column-major order.
	     *
	     * @param {Number[]} values The row-major order array.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     */
	    Matrix3.fromRowMajorArray = function(values, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(values)) {
	            throw new DeveloperError('values is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Matrix3(values[0], values[1], values[2],
	                               values[3], values[4], values[5],
	                               values[6], values[7], values[8]);
	        }
	        result[0] = values[0];
	        result[1] = values[3];
	        result[2] = values[6];
	        result[3] = values[1];
	        result[4] = values[4];
	        result[5] = values[7];
	        result[6] = values[2];
	        result[7] = values[5];
	        result[8] = values[8];
	        return result;
	    };

	    /**
	     * Computes a 3x3 rotation matrix from the provided quaternion.
	     *
	     * @param {Quaternion} quaternion the quaternion to use.
	     * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.
	     */
	    Matrix3.fromQuaternion = function(quaternion, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        //>>includeEnd('debug');

	        var x2 = quaternion.x * quaternion.x;
	        var xy = quaternion.x * quaternion.y;
	        var xz = quaternion.x * quaternion.z;
	        var xw = quaternion.x * quaternion.w;
	        var y2 = quaternion.y * quaternion.y;
	        var yz = quaternion.y * quaternion.z;
	        var yw = quaternion.y * quaternion.w;
	        var z2 = quaternion.z * quaternion.z;
	        var zw = quaternion.z * quaternion.w;
	        var w2 = quaternion.w * quaternion.w;

	        var m00 = x2 - y2 - z2 + w2;
	        var m01 = 2.0 * (xy - zw);
	        var m02 = 2.0 * (xz + yw);

	        var m10 = 2.0 * (xy + zw);
	        var m11 = -x2 + y2 - z2 + w2;
	        var m12 = 2.0 * (yz - xw);

	        var m20 = 2.0 * (xz - yw);
	        var m21 = 2.0 * (yz + xw);
	        var m22 = -x2 - y2 + z2 + w2;

	        if (!defined(result)) {
	            return new Matrix3(m00, m01, m02,
	                               m10, m11, m12,
	                               m20, m21, m22);
	        }
	        result[0] = m00;
	        result[1] = m10;
	        result[2] = m20;
	        result[3] = m01;
	        result[4] = m11;
	        result[5] = m21;
	        result[6] = m02;
	        result[7] = m12;
	        result[8] = m22;
	        return result;
	    };

	    /**
	     * Computes a Matrix3 instance representing a non-uniform scale.
	     *
	     * @param {Cartesian3} scale The x, y, and z scale factors.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     *
	     * @example
	     * // Creates
	     * //   [7.0, 0.0, 0.0]
	     * //   [0.0, 8.0, 0.0]
	     * //   [0.0, 0.0, 9.0]
	     * var m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
	     */
	    Matrix3.fromScale = function(scale, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(scale)) {
	            throw new DeveloperError('scale is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Matrix3(
	                scale.x, 0.0,     0.0,
	                0.0,     scale.y, 0.0,
	                0.0,     0.0,     scale.z);
	        }

	        result[0] = scale.x;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = scale.y;
	        result[5] = 0.0;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = scale.z;
	        return result;
	    };

	    /**
	     * Computes a Matrix3 instance representing a uniform scale.
	     *
	     * @param {Number} scale The uniform scale factor.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     *
	     * @example
	     * // Creates
	     * //   [2.0, 0.0, 0.0]
	     * //   [0.0, 2.0, 0.0]
	     * //   [0.0, 0.0, 2.0]
	     * var m = Cesium.Matrix3.fromUniformScale(2.0);
	     */
	    Matrix3.fromUniformScale = function(scale, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof scale !== 'number') {
	            throw new DeveloperError('scale is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Matrix3(
	                scale, 0.0,   0.0,
	                0.0,   scale, 0.0,
	                0.0,   0.0,   scale);
	        }

	        result[0] = scale;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = scale;
	        result[5] = 0.0;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = scale;
	        return result;
	    };

	    /**
	     * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.
	     *
	     * @param {Cartesian3} the vector on the left hand side of the cross product operation.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     *
	     * @example
	     * // Creates
	     * //   [0.0, -9.0,  8.0]
	     * //   [9.0,  0.0, -7.0]
	     * //   [-8.0, 7.0,  0.0]
	     * var m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));
	     */
	    Matrix3.fromCrossProduct = function(vector, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(vector)) {
	            throw new DeveloperError('vector is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Matrix3(
	                      0.0, -vector.z,  vector.y,
	                 vector.z,       0.0, -vector.x,
	                -vector.y,  vector.x,       0.0);
	        }

	        result[0] = 0.0;
	        result[1] = vector.z;
	        result[2] = -vector.y;
	        result[3] = -vector.z;
	        result[4] = 0.0;
	        result[5] = vector.x;
	        result[6] = vector.y;
	        result[7] = -vector.x;
	        result[8] = 0.0;
	        return result;
	    };

	    /**
	     * Creates a rotation matrix around the x-axis.
	     *
	     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     *
	     * @example
	     * // Rotate a point 45 degrees counterclockwise around the x-axis.
	     * var p = new Cesium.Cartesian3(5, 6, 7);
	     * var m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));
	     * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
	     */
	    Matrix3.fromRotationX = function(angle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(angle)) {
	            throw new DeveloperError('angle is required.');
	        }
	        //>>includeEnd('debug');

	        var cosAngle = Math.cos(angle);
	        var sinAngle = Math.sin(angle);

	        if (!defined(result)) {
	            return new Matrix3(
	                1.0, 0.0, 0.0,
	                0.0, cosAngle, -sinAngle,
	                0.0, sinAngle, cosAngle);
	        }

	        result[0] = 1.0;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = cosAngle;
	        result[5] = sinAngle;
	        result[6] = 0.0;
	        result[7] = -sinAngle;
	        result[8] = cosAngle;

	        return result;
	    };

	    /**
	     * Creates a rotation matrix around the y-axis.
	     *
	     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     *
	     * @example
	     * // Rotate a point 45 degrees counterclockwise around the y-axis.
	     * var p = new Cesium.Cartesian3(5, 6, 7);
	     * var m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));
	     * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
	     */
	    Matrix3.fromRotationY = function(angle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(angle)) {
	            throw new DeveloperError('angle is required.');
	        }
	        //>>includeEnd('debug');

	        var cosAngle = Math.cos(angle);
	        var sinAngle = Math.sin(angle);

	        if (!defined(result)) {
	            return new Matrix3(
	                cosAngle, 0.0, sinAngle,
	                0.0, 1.0, 0.0,
	                -sinAngle, 0.0, cosAngle);
	        }

	        result[0] = cosAngle;
	        result[1] = 0.0;
	        result[2] = -sinAngle;
	        result[3] = 0.0;
	        result[4] = 1.0;
	        result[5] = 0.0;
	        result[6] = sinAngle;
	        result[7] = 0.0;
	        result[8] = cosAngle;

	        return result;
	    };

	    /**
	     * Creates a rotation matrix around the z-axis.
	     *
	     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
	     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
	     *
	     * @example
	     * // Rotate a point 45 degrees counterclockwise around the z-axis.
	     * var p = new Cesium.Cartesian3(5, 6, 7);
	     * var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));
	     * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
	     */
	    Matrix3.fromRotationZ = function(angle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(angle)) {
	            throw new DeveloperError('angle is required.');
	        }
	        //>>includeEnd('debug');

	        var cosAngle = Math.cos(angle);
	        var sinAngle = Math.sin(angle);

	        if (!defined(result)) {
	            return new Matrix3(
	                cosAngle, -sinAngle, 0.0,
	                sinAngle, cosAngle, 0.0,
	                0.0, 0.0, 1.0);
	        }

	        result[0] = cosAngle;
	        result[1] = sinAngle;
	        result[2] = 0.0;
	        result[3] = -sinAngle;
	        result[4] = cosAngle;
	        result[5] = 0.0;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = 1.0;

	        return result;
	    };

	    /**
	     * Creates an Array from the provided Matrix3 instance.
	     * The array will be in column-major order.
	     *
	     * @param {Matrix3} matrix The matrix to use..
	     * @param {Number[]} [result] The Array onto which to store the result.
	     * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.
	     */
	    Matrix3.toArray = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];
	        }
	        result[0] = matrix[0];
	        result[1] = matrix[1];
	        result[2] = matrix[2];
	        result[3] = matrix[3];
	        result[4] = matrix[4];
	        result[5] = matrix[5];
	        result[6] = matrix[6];
	        result[7] = matrix[7];
	        result[8] = matrix[8];
	        return result;
	    };

	    /**
	     * Computes the array index of the element at the provided row and column.
	     *
	     * @param {Number} row The zero-based index of the row.
	     * @param {Number} column The zero-based index of the column.
	     * @returns {Number} The index of the element at the provided row and column.
	     *
	     * @exception {DeveloperError} row must be 0, 1, or 2.
	     * @exception {DeveloperError} column must be 0, 1, or 2.
	     *
	     * @example
	     * var myMatrix = new Cesium.Matrix3();
	     * var column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);
	     * var column1Row0 = myMatrix[column1Row0Index]
	     * myMatrix[column1Row0Index] = 10.0;
	     */
	    Matrix3.getElementIndex = function(column, row) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof row !== 'number' || row < 0 || row > 2) {
	            throw new DeveloperError('row must be 0, 1, or 2.');
	        }
	        if (typeof column !== 'number' || column < 0 || column > 2) {
	            throw new DeveloperError('column must be 0, 1, or 2.');
	        }
	        //>>includeEnd('debug');

	        return column * 3 + row;
	    };

	    /**
	     * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
	     *
	     * @param {Matrix3} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the column to retrieve.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, or 2.
	     */
	    Matrix3.getColumn = function(matrix, index, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }

	        if (typeof index !== 'number' || index < 0 || index > 2) {
	            throw new DeveloperError('index must be 0, 1, or 2.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var startIndex = index * 3;
	        var x = matrix[startIndex];
	        var y = matrix[startIndex + 1];
	        var z = matrix[startIndex + 2];

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
	     *
	     * @param {Matrix3} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the column to set.
	     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, or 2.
	     */
	    Matrix3.setColumn = function(matrix, index, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof index !== 'number' || index < 0 || index > 2) {
	            throw new DeveloperError('index must be 0, 1, or 2.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result = Matrix3.clone(matrix, result);
	        var startIndex = index * 3;
	        result[startIndex] = cartesian.x;
	        result[startIndex + 1] = cartesian.y;
	        result[startIndex + 2] = cartesian.z;
	        return result;
	    };

	    /**
	     * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
	     *
	     * @param {Matrix3} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the row to retrieve.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, or 2.
	     */
	    Matrix3.getRow = function(matrix, index, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }
	        if (typeof index !== 'number' || index < 0 || index > 2) {
	            throw new DeveloperError('index must be 0, 1, or 2.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var x = matrix[index];
	        var y = matrix[index + 3];
	        var z = matrix[index + 6];

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
	     *
	     * @param {Matrix3} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the row to set.
	     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, or 2.
	     */
	    Matrix3.setRow = function(matrix, index, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof index !== 'number' || index < 0 || index > 2) {
	            throw new DeveloperError('index must be 0, 1, or 2.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result = Matrix3.clone(matrix, result);
	        result[index] = cartesian.x;
	        result[index + 3] = cartesian.y;
	        result[index + 6] = cartesian.z;
	        return result;
	    };

	    var scratchColumn = new Cartesian3();

	    /**
	     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
	     *
	     * @param {Matrix3} matrix The matrix.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Matrix3.getScale = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
	        result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));
	        result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));
	        return result;
	    };

	    var scratchScale = new Cartesian3();

	    /**
	     * Computes the maximum scale assuming the matrix is an affine transformation.
	     * The maximum scale is the maximum length of the column vectors.
	     *
	     * @param {Matrix3} matrix The matrix.
	     * @returns {Number} The maximum scale.
	     */
	    Matrix3.getMaximumScale = function(matrix) {
	        Matrix3.getScale(matrix, scratchScale);
	        return Cartesian3.maximumComponent(scratchScale);
	    };

	    /**
	     * Computes the product of two matrices.
	     *
	     * @param {Matrix3} left The first matrix.
	     * @param {Matrix3} right The second matrix.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     */
	    Matrix3.multiply = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
	        var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
	        var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];

	        var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
	        var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
	        var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];

	        var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
	        var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
	        var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];

	        result[0] = column0Row0;
	        result[1] = column0Row1;
	        result[2] = column0Row2;
	        result[3] = column1Row0;
	        result[4] = column1Row1;
	        result[5] = column1Row2;
	        result[6] = column2Row0;
	        result[7] = column2Row1;
	        result[8] = column2Row2;
	        return result;
	    };

	    /**
	     * Computes the sum of two matrices.
	     *
	     * @param {Matrix3} left The first matrix.
	     * @param {Matrix3} right The second matrix.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     */
	    Matrix3.add = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = left[0] + right[0];
	        result[1] = left[1] + right[1];
	        result[2] = left[2] + right[2];
	        result[3] = left[3] + right[3];
	        result[4] = left[4] + right[4];
	        result[5] = left[5] + right[5];
	        result[6] = left[6] + right[6];
	        result[7] = left[7] + right[7];
	        result[8] = left[8] + right[8];
	        return result;
	    };

	    /**
	     * Computes the difference of two matrices.
	     *
	     * @param {Matrix3} left The first matrix.
	     * @param {Matrix3} right The second matrix.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     */
	    Matrix3.subtract = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = left[0] - right[0];
	        result[1] = left[1] - right[1];
	        result[2] = left[2] - right[2];
	        result[3] = left[3] - right[3];
	        result[4] = left[4] - right[4];
	        result[5] = left[5] - right[5];
	        result[6] = left[6] - right[6];
	        result[7] = left[7] - right[7];
	        result[8] = left[8] - right[8];
	        return result;
	    };

	    /**
	     * Computes the product of a matrix and a column vector.
	     *
	     * @param {Matrix3} matrix The matrix.
	     * @param {Cartesian3} cartesian The column.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Matrix3.multiplyByVector = function(matrix, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var vX = cartesian.x;
	        var vY = cartesian.y;
	        var vZ = cartesian.z;

	        var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
	        var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
	        var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Computes the product of a matrix and a scalar.
	     *
	     * @param {Matrix3} matrix The matrix.
	     * @param {Number} scalar The number to multiply by.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     */
	    Matrix3.multiplyByScalar = function(matrix, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar must be a number');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = matrix[0] * scalar;
	        result[1] = matrix[1] * scalar;
	        result[2] = matrix[2] * scalar;
	        result[3] = matrix[3] * scalar;
	        result[4] = matrix[4] * scalar;
	        result[5] = matrix[5] * scalar;
	        result[6] = matrix[6] * scalar;
	        result[7] = matrix[7] * scalar;
	        result[8] = matrix[8] * scalar;
	        return result;
	    };

	    /**
	     * Creates a negated copy of the provided matrix.
	     *
	     * @param {Matrix3} matrix The matrix to negate.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     */
	    Matrix3.negate = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = -matrix[0];
	        result[1] = -matrix[1];
	        result[2] = -matrix[2];
	        result[3] = -matrix[3];
	        result[4] = -matrix[4];
	        result[5] = -matrix[5];
	        result[6] = -matrix[6];
	        result[7] = -matrix[7];
	        result[8] = -matrix[8];
	        return result;
	    };

	    /**
	     * Computes the transpose of the provided matrix.
	     *
	     * @param {Matrix3} matrix The matrix to transpose.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     */
	    Matrix3.transpose = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var column0Row0 = matrix[0];
	        var column0Row1 = matrix[3];
	        var column0Row2 = matrix[6];
	        var column1Row0 = matrix[1];
	        var column1Row1 = matrix[4];
	        var column1Row2 = matrix[7];
	        var column2Row0 = matrix[2];
	        var column2Row1 = matrix[5];
	        var column2Row2 = matrix[8];

	        result[0] = column0Row0;
	        result[1] = column0Row1;
	        result[2] = column0Row2;
	        result[3] = column1Row0;
	        result[4] = column1Row1;
	        result[5] = column1Row2;
	        result[6] = column2Row0;
	        result[7] = column2Row1;
	        result[8] = column2Row2;
	        return result;
	    };

	    function computeFrobeniusNorm(matrix) {
	        var norm = 0.0;
	        for (var i = 0; i < 9; ++i) {
	            var temp = matrix[i];
	            norm += temp * temp;
	        }

	        return Math.sqrt(norm);
	    }

	    var rowVal = [1, 0, 0];
	    var colVal = [2, 2, 1];

	    function offDiagonalFrobeniusNorm(matrix) {
	        // Computes the "off-diagonal" Frobenius norm.
	        // Assumes matrix is symmetric.

	        var norm = 0.0;
	        for (var i = 0; i < 3; ++i) {
	            var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
	            norm += 2.0 * temp * temp;
	        }

	        return Math.sqrt(norm);
	    }

	    function shurDecomposition(matrix, result) {
	        // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
	        // section 8.4.2 The 2by2 Symmetric Schur Decomposition.
	        //
	        // The routine takes a matrix, which is assumed to be symmetric, and
	        // finds the largest off-diagonal term, and then creates
	        // a matrix (result) which can be used to help reduce it

	        var tolerance = CesiumMath.EPSILON15;

	        var maxDiagonal = 0.0;
	        var rotAxis = 1;

	        // find pivot (rotAxis) based on max diagonal of matrix
	        for (var i = 0; i < 3; ++i) {
	            var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);
	            if (temp > maxDiagonal) {
	                rotAxis = i;
	                maxDiagonal = temp;
	            }
	        }

	        var c = 1.0;
	        var s = 0.0;

	        var p = rowVal[rotAxis];
	        var q = colVal[rotAxis];

	        if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
	            var qq = matrix[Matrix3.getElementIndex(q, q)];
	            var pp = matrix[Matrix3.getElementIndex(p, p)];
	            var qp = matrix[Matrix3.getElementIndex(q, p)];

	            var tau = (qq - pp) / 2.0 / qp;
	            var t;

	            if (tau < 0.0) {
	                t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
	            } else {
	                t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
	            }

	            c = 1.0 / Math.sqrt(1.0 + t * t);
	            s = t * c;
	        }

	        result = Matrix3.clone(Matrix3.IDENTITY, result);

	        result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;
	        result[Matrix3.getElementIndex(q, p)] = s;
	        result[Matrix3.getElementIndex(p, q)] = -s;

	        return result;
	    }

	    var jMatrix = new Matrix3();
	    var jMatrixTranspose = new Matrix3();

	    /**
	     * Computes the eigenvectors and eigenvalues of a symmetric matrix.
	     * <p>
	     * Returns a diagonal matrix and unitary matrix such that:
	     * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>
	     * </p>
	     * <p>
	     * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns
	     * of the unitary matrix are the corresponding eigenvectors.
	     * </p>
	     *
	     * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.
	     * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.
	     * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.
	     *
	     * @example
	     * var a = //... symetric matrix
	     * var result = {
	     *     unitary : new Cesium.Matrix3(),
	     *     diagonal : new Cesium.Matrix3()
	     * };
	     * Cesium.Matrix3.computeEigenDecomposition(a, result);
	     *
	     * var unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());
	     * var b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());
	     * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a
	     *
	     * var lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue
	     * var v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector
	     * var c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)
	     */
	    Matrix3.computeEigenDecomposition = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }
	        //>>includeEnd('debug');

	        // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
	        // section 8.4.3 The Classical Jacobi Algorithm

	        var tolerance = CesiumMath.EPSILON20;
	        var maxSweeps = 10;

	        var count = 0;
	        var sweep = 0;

	        if (!defined(result)) {
	            result = {};
	        }

	        var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);
	        var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);

	        var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);

	        while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
	            shurDecomposition(diagMatrix, jMatrix);
	            Matrix3.transpose(jMatrix, jMatrixTranspose);
	            Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
	            Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
	            Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);

	            if (++count > 2) {
	                ++sweep;
	                count = 0;
	            }
	        }

	        return result;
	    };

	    /**
	     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
	     *
	     * @param {Matrix3} matrix The matrix with signed elements.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     */
	    Matrix3.abs = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = Math.abs(matrix[0]);
	        result[1] = Math.abs(matrix[1]);
	        result[2] = Math.abs(matrix[2]);
	        result[3] = Math.abs(matrix[3]);
	        result[4] = Math.abs(matrix[4]);
	        result[5] = Math.abs(matrix[5]);
	        result[6] = Math.abs(matrix[6]);
	        result[7] = Math.abs(matrix[7]);
	        result[8] = Math.abs(matrix[8]);

	        return result;
	    };

	    /**
	     * Computes the determinant of the provided matrix.
	     *
	     * @param {Matrix3} matrix The matrix to use.
	     * @returns {Number} The value of the determinant of the matrix.
	     */
	    Matrix3.determinant = function(matrix) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        //>>includeEnd('debug');

	        var m11 = matrix[0];
	        var m21 = matrix[3];
	        var m31 = matrix[6];
	        var m12 = matrix[1];
	        var m22 = matrix[4];
	        var m32 = matrix[7];
	        var m13 = matrix[2];
	        var m23 = matrix[5];
	        var m33 = matrix[8];

	        return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
	    };

	    /**
	     * Computes the inverse of the provided matrix.
	     *
	     * @param {Matrix3} matrix The matrix to invert.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     *
	     * @exception {DeveloperError} matrix is not invertible.
	     */
	    Matrix3.inverse = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var m11 = matrix[0];
	        var m21 = matrix[1];
	        var m31 = matrix[2];
	        var m12 = matrix[3];
	        var m22 = matrix[4];
	        var m32 = matrix[5];
	        var m13 = matrix[6];
	        var m23 = matrix[7];
	        var m33 = matrix[8];

	        var determinant = Matrix3.determinant(matrix);

	        if (Math.abs(determinant) <= CesiumMath.EPSILON15) {
	            throw new DeveloperError('matrix is not invertible');
	        }

	        result[0] = m22 * m33 - m23 * m32;
	        result[1] = m23 * m31 - m21 * m33;
	        result[2] = m21 * m32 - m22 * m31;
	        result[3] = m13 * m32 - m12 * m33;
	        result[4] = m11 * m33 - m13 * m31;
	        result[5] = m12 * m31 - m11 * m32;
	        result[6] = m12 * m23 - m13 * m22;
	        result[7] = m13 * m21 - m11 * m23;
	        result[8] = m11 * m22 - m12 * m21;

	       var scale = 1.0 / determinant;
	       return Matrix3.multiplyByScalar(result, scale, result);
	    };

	    /**
	     * Compares the provided matrices componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Matrix3} [left] The first matrix.
	     * @param {Matrix3} [right] The second matrix.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Matrix3.equals = function(left, right) {
	        return (left === right) ||
	               (defined(left) &&
	                defined(right) &&
	                left[0] === right[0] &&
	                left[1] === right[1] &&
	                left[2] === right[2] &&
	                left[3] === right[3] &&
	                left[4] === right[4] &&
	                left[5] === right[5] &&
	                left[6] === right[6] &&
	                left[7] === right[7] &&
	                left[8] === right[8]);
	    };

	    /**
	     * Compares the provided matrices componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Matrix3} [left] The first matrix.
	     * @param {Matrix3} [right] The second matrix.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Matrix3.equalsEpsilon = function(left, right, epsilon) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof epsilon !== 'number') {
	            throw new DeveloperError('epsilon must be a number');
	        }
	        //>>includeEnd('debug');

	        return (left === right) ||
	                (defined(left) &&
	                defined(right) &&
	                Math.abs(left[0] - right[0]) <= epsilon &&
	                Math.abs(left[1] - right[1]) <= epsilon &&
	                Math.abs(left[2] - right[2]) <= epsilon &&
	                Math.abs(left[3] - right[3]) <= epsilon &&
	                Math.abs(left[4] - right[4]) <= epsilon &&
	                Math.abs(left[5] - right[5]) <= epsilon &&
	                Math.abs(left[6] - right[6]) <= epsilon &&
	                Math.abs(left[7] - right[7]) <= epsilon &&
	                Math.abs(left[8] - right[8]) <= epsilon);
	    };

	    /**
	     * An immutable Matrix3 instance initialized to the identity matrix.
	     *
	     * @type {Matrix3}
	     * @constant
	     */
	    Matrix3.IDENTITY = freezeObject(new Matrix3(1.0, 0.0, 0.0,
	                                                0.0, 1.0, 0.0,
	                                                0.0, 0.0, 1.0));

	    /**
	     * The index into Matrix3 for column 0, row 0.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN0ROW0 = 0;

	    /**
	     * The index into Matrix3 for column 0, row 1.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN0ROW1 = 1;

	    /**
	     * The index into Matrix3 for column 0, row 2.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN0ROW2 = 2;

	    /**
	     * The index into Matrix3 for column 1, row 0.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN1ROW0 = 3;

	    /**
	     * The index into Matrix3 for column 1, row 1.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN1ROW1 = 4;

	    /**
	     * The index into Matrix3 for column 1, row 2.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN1ROW2 = 5;

	    /**
	     * The index into Matrix3 for column 2, row 0.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN2ROW0 = 6;

	    /**
	     * The index into Matrix3 for column 2, row 1.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN2ROW1 = 7;

	    /**
	     * The index into Matrix3 for column 2, row 2.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix3.COLUMN2ROW2 = 8;

	    /**
	     * Duplicates the provided Matrix3 instance.
	     *
	     * @param {Matrix3} [result] The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
	     */
	    Matrix3.prototype.clone = function(result) {
	        return Matrix3.clone(this, result);
	    };

	    /**
	     * Compares this matrix to the provided matrix componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Matrix3} [right] The right hand side matrix.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    Matrix3.prototype.equals = function(right) {
	        return Matrix3.equals(this, right);
	    };

	    /**
	     * @private
	     */
	    Matrix3.equalsArray = function(matrix, array, offset) {
	        return matrix[0] === array[offset] &&
	               matrix[1] === array[offset + 1] &&
	               matrix[2] === array[offset + 2] &&
	               matrix[3] === array[offset + 3] &&
	               matrix[4] === array[offset + 4] &&
	               matrix[5] === array[offset + 5] &&
	               matrix[6] === array[offset + 6] &&
	               matrix[7] === array[offset + 7] &&
	               matrix[8] === array[offset + 8];
	    };

	    /**
	     * Compares this matrix to the provided matrix componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Matrix3} [right] The right hand side matrix.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Matrix3.prototype.equalsEpsilon = function(right, epsilon) {
	        return Matrix3.equalsEpsilon(this, right, epsilon);
	    };

	    /**
	     * Creates a string representing this Matrix with each row being
	     * on a separate line and in the format '(column0, column1, column2)'.
	     *
	     * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
	     */
	    Matrix3.prototype.toString = function() {
	        return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\n' +
	               '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\n' +
	               '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';
	    };

	    return Matrix3;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(5)
	  , TAG      = __webpack_require__(14)('toStringTag')
	  , toString = {}.toString;
	function cof(it){
	  return toString.call(it).slice(8, -1);
	}
	cof.classof = function(it){
	  var O, T;
	  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
	    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
	};
	cof.set = function(it, tag, stat){
	  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);
	};
	module.exports = cof;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var ctx  = __webpack_require__(41)
	  , get  = __webpack_require__(13).get
	  , call = __webpack_require__(105);
	module.exports = function(iterable, entries, fn, that){
	  var iterator = get(iterable)
	    , f        = ctx(fn, that, entries ? 2 : 1)
	    , step;
	  while(!(step = iterator.next()).done){
	    if(call(iterator, f, step.value, entries) === false){
	      return call.close(iterator);
	    }
	  }
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var EventEmitter = __webpack_require__(142);
	var EventHandler = __webpack_require__(48);
	var EventArbiter = __webpack_require__(210);
	var EventFilter = __webpack_require__(211);
	var EventMapper = __webpack_require__(212);

	var asap = __webpack_require__(58);

	var setOutputHandler = EventHandler.setOutputHandler;
	EventHandler.setOutputHandler = function (obj, handler) {
	  setOutputHandler(obj, handler);
	  obj.once = function (type, handler) {
	    obj.on(type, function onceHandler(e) {
	      handler(e);
	      obj.removeListener(type, onceHandler);
	    });
	  };
	};

	var removeListener = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.removeListener = function (type, listener) {
	  asap((function () {
	    removeListener.call(this, type, listener);
	  }).bind(this));
	};

	// re-export Famous event classes

	module.exports = { EventEmitter: EventEmitter,
	  EventHandler: EventHandler,
	  EventArbiter: EventArbiter,
	  EventFilter: EventFilter,
	  EventMapper: EventMapper
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _Object$keys = __webpack_require__(95)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;
	exports['default'] = ready;

	// @param {(Array.<string>|string)} capabilities
	exports.setReady = setReady;

	// @param {(Array.<string>|string)} capabilities
	exports.setUnavailable = setUnavailable;
	exports.getCapabilities = getCapabilities;

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var deferredCapabilities = {};

	function ready(capability) {
	  if (!capability) return _bluebird2['default'].reject(new Error('capability is required'));
	  if (!deferredCapabilities[capability]) deferredCapabilities[capability] = _bluebird2['default'].defer();
	  return deferredCapabilities[capability].promise;
	}

	function setReady(capabilities) {
	  if (!Array.isArray(capabilities)) capabilities = [capabilities];

	  capabilities.forEach(function (c) {
	    if (!deferredCapabilities[c]) deferredCapabilities[c] = _bluebird2['default'].defer();
	    deferredCapabilities[c].resolve();
	  });
	}

	function setUnavailable(capabilities) {
	  if (!Array.isArray(capabilities)) capabilities = [capabilities];

	  capabilities.forEach(function (c) {
	    deferredCapabilities[c].reject(new Error(c + ' capability is not available on this platform'));
	  });
	}

	function getCapabilities() {
	  return _Object$keys(deferredCapabilities).map(function (k) {
	    var capability = deferredCapabilities[k].promise;
	    return !capability.isPending ? capability.value() : undefined;
	  });
	}

	setTimeout(function () {
	  if (window.Argon_CAPABILITIES) setReady(window.Argon_CAPABILITIES);
	}, 0);

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    /**
	     * A 2D Cartesian point.
	     * @alias Cartesian2
	     * @constructor
	     *
	     * @param {Number} [x=0.0] The X component.
	     * @param {Number} [y=0.0] The Y component.
	     *
	     * @see Cartesian3
	     * @see Cartesian4
	     * @see Packable
	     */
	    var Cartesian2 = function(x, y) {
	        /**
	         * The X component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.x = defaultValue(x, 0.0);

	        /**
	         * The Y component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.y = defaultValue(y, 0.0);
	    };

	    /**
	     * Creates a Cartesian2 instance from x and y coordinates.
	     *
	     * @param {Number} x The x coordinate.
	     * @param {Number} y The y coordinate.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	     */
	    Cartesian2.fromElements = function(x, y, result) {
	        if (!defined(result)) {
	            return new Cartesian2(x, y);
	        }

	        result.x = x;
	        result.y = y;
	        return result;
	    };

	    /**
	     * Duplicates a Cartesian2 instance.
	     *
	     * @param {Cartesian2} cartesian The Cartesian to duplicate.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)
	     */
	    Cartesian2.clone = function(cartesian, result) {
	        if (!defined(cartesian)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new Cartesian2(cartesian.x, cartesian.y);
	        }

	        result.x = cartesian.x;
	        result.y = cartesian.y;
	        return result;
	    };

	    /**
	     * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
	     * x and y properties of the Cartesian3 and drops z.
	     * @function
	     *
	     * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	     */
	    Cartesian2.fromCartesian3 = Cartesian2.clone;

	    /**
	     * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
	     * x and y properties of the Cartesian4 and drops z and w.
	     * @function
	     *
	     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	     */
	    Cartesian2.fromCartesian4 = Cartesian2.clone;

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Cartesian2.packedLength = 2;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Cartesian2} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Cartesian2.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value.x;
	        array[startingIndex] = value.y;
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Cartesian2} [result] The object into which to store the result.
	     */
	    Cartesian2.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Cartesian2();
	        }
	        result.x = array[startingIndex++];
	        result.y = array[startingIndex];
	        return result;
	    };

	    /**
	     * Creates a Cartesian2 from two consecutive elements in an array.
	     * @function
	     *
	     * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.
	     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	     *
	     * @example
	     * // Create a Cartesian2 with (1.0, 2.0)
	     * var v = [1.0, 2.0];
	     * var p = Cesium.Cartesian2.fromArray(v);
	     *
	     * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array
	     * var v2 = [0.0, 0.0, 1.0, 2.0];
	     * var p2 = Cesium.Cartesian2.fromArray(v2, 2);
	     */
	    Cartesian2.fromArray = Cartesian2.unpack;

	    /**
	     * Computes the value of the maximum component for the supplied Cartesian.
	     *
	     * @param {Cartesian2} cartesian The cartesian to use.
	     * @returns {Number} The value of the maximum component.
	     */
	    Cartesian2.maximumComponent = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return Math.max(cartesian.x, cartesian.y);
	    };

	    /**
	     * Computes the value of the minimum component for the supplied Cartesian.
	     *
	     * @param {Cartesian2} cartesian The cartesian to use.
	     * @returns {Number} The value of the minimum component.
	     */
	    Cartesian2.minimumComponent = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return Math.min(cartesian.x, cartesian.y);
	    };

	    /**
	     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
	     *
	     * @param {Cartesian2} first A cartesian to compare.
	     * @param {Cartesian2} second A cartesian to compare.
	     * @param {Cartesian2} result The object into which to store the result.
	     * @returns {Cartesian2} A cartesian with the minimum components.
	     */
	    Cartesian2.minimumByComponent = function(first, second, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(first)) {
	            throw new DeveloperError('first is required.');
	        }
	        if (!defined(second)) {
	            throw new DeveloperError('second is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');


	        result.x = Math.min(first.x, second.x);
	        result.y = Math.min(first.y, second.y);

	        return result;
	    };

	    /**
	     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
	     *
	     * @param {Cartesian2} first A cartesian to compare.
	     * @param {Cartesian2} second A cartesian to compare.
	     * @param {Cartesian2} result The object into which to store the result.
	     * @returns {Cartesian2} A cartesian with the maximum components.
	     */
	    Cartesian2.maximumByComponent = function(first, second, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(first)) {
	            throw new DeveloperError('first is required.');
	        }
	        if (!defined(second)) {
	            throw new DeveloperError('second is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.max(first.x, second.x);
	        result.y = Math.max(first.y, second.y);
	        return result;
	    };

	    /**
	     * Computes the provided Cartesian's squared magnitude.
	     *
	     * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.
	     * @returns {Number} The squared magnitude.
	     */
	    Cartesian2.magnitudeSquared = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
	    };

	    /**
	     * Computes the Cartesian's magnitude (length).
	     *
	     * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.
	     * @returns {Number} The magnitude.
	     */
	    Cartesian2.magnitude = function(cartesian) {
	        return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
	    };

	    var distanceScratch = new Cartesian2();

	    /**
	     * Computes the distance between two points.
	     *
	     * @param {Cartesian2} left The first point to compute the distance from.
	     * @param {Cartesian2} right The second point to compute the distance to.
	     * @returns {Number} The distance between two points.
	     *
	     * @example
	     * // Returns 1.0
	     * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));
	     */
	    Cartesian2.distance = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left) || !defined(right)) {
	            throw new DeveloperError('left and right are required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian2.subtract(left, right, distanceScratch);
	        return Cartesian2.magnitude(distanceScratch);
	    };

	    /**
	     * Computes the squared distance between two points.  Comparing squared distances
	     * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.
	     *
	     * @param {Cartesian2} left The first point to compute the distance from.
	     * @param {Cartesian2} right The second point to compute the distance to.
	     * @returns {Number} The distance between two points.
	     *
	     * @example
	     * // Returns 4.0, not 2.0
	     * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));
	     */
	    Cartesian2.distanceSquared = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left) || !defined(right)) {
	            throw new DeveloperError('left and right are required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian2.subtract(left, right, distanceScratch);
	        return Cartesian2.magnitudeSquared(distanceScratch);
	    };

	    /**
	     * Computes the normalized form of the supplied Cartesian.
	     *
	     * @param {Cartesian2} cartesian The Cartesian to be normalized.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.normalize = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var magnitude = Cartesian2.magnitude(cartesian);

	        result.x = cartesian.x / magnitude;
	        result.y = cartesian.y / magnitude;
	        return result;
	    };

	    /**
	     * Computes the dot (scalar) product of two Cartesians.
	     *
	     * @param {Cartesian2} left The first Cartesian.
	     * @param {Cartesian2} right The second Cartesian.
	     * @returns {Number} The dot product.
	     */
	    Cartesian2.dot = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        //>>includeEnd('debug');

	        return left.x * right.x + left.y * right.y;
	    };

	    /**
	     * Computes the componentwise product of two Cartesians.
	     *
	     * @param {Cartesian2} left The first Cartesian.
	     * @param {Cartesian2} right The second Cartesian.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.multiplyComponents = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x * right.x;
	        result.y = left.y * right.y;
	        return result;
	    };

	    /**
	     * Computes the componentwise sum of two Cartesians.
	     *
	     * @param {Cartesian2} left The first Cartesian.
	     * @param {Cartesian2} right The second Cartesian.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.add = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x + right.x;
	        result.y = left.y + right.y;
	        return result;
	    };

	    /**
	     * Computes the componentwise difference of two Cartesians.
	     *
	     * @param {Cartesian2} left The first Cartesian.
	     * @param {Cartesian2} right The second Cartesian.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.subtract = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x - right.x;
	        result.y = left.y - right.y;
	        return result;
	    };

	    /**
	     * Multiplies the provided Cartesian componentwise by the provided scalar.
	     *
	     * @param {Cartesian2} cartesian The Cartesian to be scaled.
	     * @param {Number} scalar The scalar to multiply with.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = cartesian.x * scalar;
	        result.y = cartesian.y * scalar;
	        return result;
	    };

	    /**
	     * Divides the provided Cartesian componentwise by the provided scalar.
	     *
	     * @param {Cartesian2} cartesian The Cartesian to be divided.
	     * @param {Number} scalar The scalar to divide by.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.divideByScalar = function(cartesian, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = cartesian.x / scalar;
	        result.y = cartesian.y / scalar;
	        return result;
	    };

	    /**
	     * Negates the provided Cartesian.
	     *
	     * @param {Cartesian2} cartesian The Cartesian to be negated.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.negate = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = -cartesian.x;
	        result.y = -cartesian.y;
	        return result;
	    };

	    /**
	     * Computes the absolute value of the provided Cartesian.
	     *
	     * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.abs = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.abs(cartesian.x);
	        result.y = Math.abs(cartesian.y);
	        return result;
	    };

	    var lerpScratch = new Cartesian2();
	    /**
	     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
	     *
	     * @param {Cartesian2} start The value corresponding to t at 0.0.
	     * @param {Cartesian2} end The value corresponding to t at 1.0.
	     * @param {Number} t The point along t at which to interpolate.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter.
	     */
	    Cartesian2.lerp = function(start, end, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(start)) {
	            throw new DeveloperError('start is required.');
	        }
	        if (!defined(end)) {
	            throw new DeveloperError('end is required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian2.multiplyByScalar(end, t, lerpScratch);
	        result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
	        return Cartesian2.add(lerpScratch, result, result);
	    };

	    var angleBetweenScratch = new Cartesian2();
	    var angleBetweenScratch2 = new Cartesian2();
	    /**
	     * Returns the angle, in radians, between the provided Cartesians.
	     *
	     * @param {Cartesian2} left The first Cartesian.
	     * @param {Cartesian2} right The second Cartesian.
	     * @returns {Number} The angle between the Cartesians.
	     */
	    Cartesian2.angleBetween = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        //>>includeEnd('debug');

	        Cartesian2.normalize(left, angleBetweenScratch);
	        Cartesian2.normalize(right, angleBetweenScratch2);
	        return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));
	    };

	    var mostOrthogonalAxisScratch = new Cartesian2();
	    /**
	     * Returns the axis that is most orthogonal to the provided Cartesian.
	     *
	     * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.
	     * @param {Cartesian2} result The object onto which to store the result.
	     * @returns {Cartesian2} The most orthogonal axis.
	     */
	    Cartesian2.mostOrthogonalAxis = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);
	        Cartesian2.abs(f, f);

	        if (f.x <= f.y) {
	            result = Cartesian2.clone(Cartesian2.UNIT_X, result);
	        } else {
	            result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
	        }

	        return result;
	    };

	    /**
	     * Compares the provided Cartesians componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartesian2} [left] The first Cartesian.
	     * @param {Cartesian2} [right] The second Cartesian.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Cartesian2.equals = function(left, right) {
	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (left.x === right.x) &&
	                (left.y === right.y));
	    };

	    /**
	     * @private
	     */
	    Cartesian2.equalsArray = function(cartesian, array, offset) {
	        return cartesian.x === array[offset] &&
	               cartesian.y === array[offset + 1];
	    };

	    /**
	     * Compares the provided Cartesians componentwise and returns
	     * <code>true</code> if they pass an absolute or relative tolerance test,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartesian2} [left] The first Cartesian.
	     * @param {Cartesian2} [right] The second Cartesian.
	     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
	     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartesian2.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	        return (left === right) ||
	               (defined(left) &&
	                defined(right) &&
	                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&
	                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon));
	    };

	    /**
	     * An immutable Cartesian2 instance initialized to (0.0, 0.0).
	     *
	     * @type {Cartesian2}
	     * @constant
	     */
	    Cartesian2.ZERO = freezeObject(new Cartesian2(0.0, 0.0));

	    /**
	     * An immutable Cartesian2 instance initialized to (1.0, 0.0).
	     *
	     * @type {Cartesian2}
	     * @constant
	     */
	    Cartesian2.UNIT_X = freezeObject(new Cartesian2(1.0, 0.0));

	    /**
	     * An immutable Cartesian2 instance initialized to (0.0, 1.0).
	     *
	     * @type {Cartesian2}
	     * @constant
	     */
	    Cartesian2.UNIT_Y = freezeObject(new Cartesian2(0.0, 1.0));

	    /**
	     * Duplicates this Cartesian2 instance.
	     *
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
	     */
	    Cartesian2.prototype.clone = function(result) {
	        return Cartesian2.clone(this, result);
	    };

	    /**
	     * Compares this Cartesian against the provided Cartesian componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartesian2} [right] The right hand side Cartesian.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    Cartesian2.prototype.equals = function(right) {
	        return Cartesian2.equals(this, right);
	    };

	    /**
	     * Compares this Cartesian against the provided Cartesian componentwise and returns
	     * <code>true</code> if they pass an absolute or relative tolerance test,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartesian2} [right] The right hand side Cartesian.
	     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
	     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartesian2.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
	        return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
	    };

	    /**
	     * Creates a string representing this Cartesian in the format '(x, y)'.
	     *
	     * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.
	     */
	    Cartesian2.prototype.toString = function() {
	        return '(' + this.x + ', ' + this.y + ')';
	    };

	    return Cartesian2;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(119),
	        __webpack_require__(7),
	        __webpack_require__(11),
	        __webpack_require__(29)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        defaultValue,
	        defined,
	        DeveloperError,
	        FeatureDetection,
	        freezeObject,
	        CesiumMath,
	        Matrix3) {
	    "use strict";

	    /**
	     * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
	     * @alias Quaternion
	     * @constructor
	     *
	     * @param {Number} [x=0.0] The X component.
	     * @param {Number} [y=0.0] The Y component.
	     * @param {Number} [z=0.0] The Z component.
	     * @param {Number} [w=0.0] The W component.
	     *
	     * @see PackableForInterpolation
	     */
	    var Quaternion = function(x, y, z, w) {
	        /**
	         * The X component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.x = defaultValue(x, 0.0);

	        /**
	         * The Y component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.y = defaultValue(y, 0.0);

	        /**
	         * The Z component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.z = defaultValue(z, 0.0);

	        /**
	         * The W component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.w = defaultValue(w, 0.0);
	    };

	    var fromAxisAngleScratch = new Cartesian3();

	    /**
	     * Computes a quaternion representing a rotation around an axis.
	     *
	     * @param {Cartesian3} axis The axis of rotation.
	     * @param {Number} angle The angle in radians to rotate around the axis.
	     * @param {Quaternion} [result] The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	     */
	    Quaternion.fromAxisAngle = function(axis, angle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(axis)) {
	            throw new DeveloperError('axis is required.');
	        }
	        if (typeof angle !== 'number') {
	            throw new DeveloperError('angle is required and must be a number.');
	        }
	        //>>includeEnd('debug');

	        var halfAngle = angle / 2.0;
	        var s = Math.sin(halfAngle);
	        fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);

	        var x = fromAxisAngleScratch.x * s;
	        var y = fromAxisAngleScratch.y * s;
	        var z = fromAxisAngleScratch.z * s;
	        var w = Math.cos(halfAngle);
	        if (!defined(result)) {
	            return new Quaternion(x, y, z, w);
	        }
	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    var fromRotationMatrixNext = [1, 2, 0];
	    var fromRotationMatrixQuat = new Array(3);
	    /**
	     * Computes a Quaternion from the provided Matrix3 instance.
	     *
	     * @param {Matrix3} matrix The rotation matrix.
	     * @param {Quaternion} [result] The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	     *
	     * @see Matrix3.fromQuaternion
	     */
	    Quaternion.fromRotationMatrix = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }
	        //>>includeEnd('debug');

	        var root;
	        var x;
	        var y;
	        var z;
	        var w;

	        var m00 = matrix[Matrix3.COLUMN0ROW0];
	        var m11 = matrix[Matrix3.COLUMN1ROW1];
	        var m22 = matrix[Matrix3.COLUMN2ROW2];
	        var trace = m00 + m11 + m22;

	        if (trace > 0.0) {
	            // |w| > 1/2, may as well choose w > 1/2
	            root = Math.sqrt(trace + 1.0); // 2w
	            w = 0.5 * root;
	            root = 0.5 / root; // 1/(4w)

	            x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;
	            y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;
	            z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;
	        } else {
	            // |w| <= 1/2
	            var next = fromRotationMatrixNext;

	            var i = 0;
	            if (m11 > m00) {
	                i = 1;
	            }
	            if (m22 > m00 && m22 > m11) {
	                i = 2;
	            }
	            var j = next[i];
	            var k = next[j];

	            root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);

	            var quat = fromRotationMatrixQuat;
	            quat[i] = 0.5 * root;
	            root = 0.5 / root;
	            w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;
	            quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;
	            quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;

	            x = -quat[0];
	            y = -quat[1];
	            z = -quat[2];
	        }

	        if (!defined(result)) {
	            return new Quaternion(x, y, z, w);
	        }
	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    var scratchHPRQuaternion = new Quaternion();

	    /**
	     * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the
	     * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
	     * the positive x axis.
	     *
	     * @param {Number} heading The heading angle in radians.
	     * @param {Number} pitch The pitch angle in radians.
	     * @param {Number} roll The roll angle in radians.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
	     */
	    Quaternion.fromHeadingPitchRoll = function(heading, pitch, roll, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(heading)) {
	            throw new DeveloperError('heading is required.');
	        }
	        if (!defined(pitch)) {
	            throw new DeveloperError('pitch is required.');
	        }
	        if (!defined(roll)) {
	            throw new DeveloperError('roll is required.');
	        }
	        //>>includeEnd('debug');

	        var rollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, roll, scratchHPRQuaternion);
	        var pitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, result);
	        result = Quaternion.multiply(pitchQuaternion, rollQuaternion, pitchQuaternion);
	        var headingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, scratchHPRQuaternion);
	        return Quaternion.multiply(headingQuaternion, result, result);
	    };

	    var sampledQuaternionAxis = new Cartesian3();
	    var sampledQuaternionRotation = new Cartesian3();
	    var sampledQuaternionTempQuaternion = new Quaternion();
	    var sampledQuaternionQuaternion0 = new Quaternion();
	    var sampledQuaternionQuaternion0Conjugate = new Quaternion();

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Quaternion.packedLength = 4;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Quaternion} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Quaternion.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }

	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value.x;
	        array[startingIndex++] = value.y;
	        array[startingIndex++] = value.z;
	        array[startingIndex] = value.w;
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Quaternion} [result] The object into which to store the result.
	     */
	    Quaternion.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Quaternion();
	        }
	        result.x = array[startingIndex];
	        result.y = array[startingIndex + 1];
	        result.z = array[startingIndex + 2];
	        result.w = array[startingIndex + 3];
	        return result;
	    };

	    /**
	     * The number of elements used to store the object into an array in its interpolatable form.
	     * @type {Number}
	     */
	    Quaternion.packedInterpolationLength = 3;

	    /**
	     * Converts a packed array into a form suitable for interpolation.
	     *
	     * @param {Number[]} packedArray The packed array.
	     * @param {Number} [startingIndex=0] The index of the first element to be converted.
	     * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.
	     * @param {Number[]} [result] The object into which to store the result.
	     */
	    Quaternion.convertPackedArrayForInterpolation = function(packedArray, startingIndex, lastIndex, result) {
	        Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);
	        Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);

	        for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {
	            var offset = i * 3;
	            Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);

	            Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);

	            if (sampledQuaternionTempQuaternion.w < 0) {
	                Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);
	            }

	            Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);
	            var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);
	            result[offset] = sampledQuaternionAxis.x * angle;
	            result[offset + 1] = sampledQuaternionAxis.y * angle;
	            result[offset + 2] = sampledQuaternionAxis.z * angle;
	        }
	    };

	    /**
	     * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.
	     *
	     * @param {Number[]} array The original packed array.
	     * @param {Number[]} sourceArray The converted array.
	     * @param {Number} [startingIndex=0] The startingIndex used to convert the array.
	     * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.
	     * @param {Quaternion} [result] The object into which to store the result.
	     */
	    Quaternion.unpackInterpolationResult = function(array, sourceArray, firstIndex, lastIndex, result) {
	        if (!defined(result)) {
	            result = new Quaternion();
	        }
	        Cartesian3.fromArray(array, 0, sampledQuaternionRotation);
	        var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);

	        Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);

	        if (magnitude === 0) {
	            Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);
	        } else {
	            Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);
	        }

	        return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);
	    };

	    /**
	     * Duplicates a Quaternion instance.
	     *
	     * @param {Quaternion} quaternion The quaternion to duplicate.
	     * @param {Quaternion} [result] The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)
	     */
	    Quaternion.clone = function(quaternion, result) {
	        if (!defined(quaternion)) {
	            return undefined;
	        }

	        if (!defined(result)) {
	            return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
	        }

	        result.x = quaternion.x;
	        result.y = quaternion.y;
	        result.z = quaternion.z;
	        result.w = quaternion.w;
	        return result;
	    };

	    /**
	     * Computes the conjugate of the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to conjugate.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.conjugate = function(quaternion, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = -quaternion.x;
	        result.y = -quaternion.y;
	        result.z = -quaternion.z;
	        result.w = quaternion.w;
	        return result;
	    };

	    /**
	     * Computes magnitude squared for the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to conjugate.
	     * @returns {Number} The magnitude squared.
	     */
	    Quaternion.magnitudeSquared = function(quaternion) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        //>>includeEnd('debug');

	        return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
	    };

	    /**
	     * Computes magnitude for the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to conjugate.
	     * @returns {Number} The magnitude.
	     */
	    Quaternion.magnitude = function(quaternion) {
	        return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
	    };

	    /**
	     * Computes the normalized form of the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to normalize.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.normalize = function(quaternion, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);
	        var x = quaternion.x * inverseMagnitude;
	        var y = quaternion.y * inverseMagnitude;
	        var z = quaternion.z * inverseMagnitude;
	        var w = quaternion.w * inverseMagnitude;

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    /**
	     * Computes the inverse of the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to normalize.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.inverse = function(quaternion, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
	        result = Quaternion.conjugate(quaternion, result);
	        return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);
	    };

	    /**
	     * Computes the componentwise sum of two quaternions.
	     *
	     * @param {Quaternion} left The first quaternion.
	     * @param {Quaternion} right The second quaternion.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.add = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x + right.x;
	        result.y = left.y + right.y;
	        result.z = left.z + right.z;
	        result.w = left.w + right.w;
	        return result;
	    };

	    /**
	     * Computes the componentwise difference of two quaternions.
	     *
	     * @param {Quaternion} left The first quaternion.
	     * @param {Quaternion} right The second quaternion.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.subtract = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x - right.x;
	        result.y = left.y - right.y;
	        result.z = left.z - right.z;
	        result.w = left.w - right.w;
	        return result;
	    };

	    /**
	     * Negates the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to be negated.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.negate = function(quaternion, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = -quaternion.x;
	        result.y = -quaternion.y;
	        result.z = -quaternion.z;
	        result.w = -quaternion.w;
	        return result;
	    };

	    /**
	     * Computes the dot (scalar) product of two quaternions.
	     *
	     * @param {Quaternion} left The first quaternion.
	     * @param {Quaternion} right The second quaternion.
	     * @returns {Number} The dot product.
	     */
	    Quaternion.dot = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        //>>includeEnd('debug');

	        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
	    };

	    /**
	     * Computes the product of two quaternions.
	     *
	     * @param {Quaternion} left The first quaternion.
	     * @param {Quaternion} right The second quaternion.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.multiply = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var leftX = left.x;
	        var leftY = left.y;
	        var leftZ = left.z;
	        var leftW = left.w;

	        var rightX = right.x;
	        var rightY = right.y;
	        var rightZ = right.z;
	        var rightW = right.w;

	        var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
	        var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
	        var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
	        var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    /**
	     * Multiplies the provided quaternion componentwise by the provided scalar.
	     *
	     * @param {Quaternion} quaternion The quaternion to be scaled.
	     * @param {Number} scalar The scalar to multiply with.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.multiplyByScalar = function(quaternion, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = quaternion.x * scalar;
	        result.y = quaternion.y * scalar;
	        result.z = quaternion.z * scalar;
	        result.w = quaternion.w * scalar;
	        return result;
	    };

	    /**
	     * Divides the provided quaternion componentwise by the provided scalar.
	     *
	     * @param {Quaternion} quaternion The quaternion to be divided.
	     * @param {Number} scalar The scalar to divide by.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.divideByScalar = function(quaternion, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = quaternion.x / scalar;
	        result.y = quaternion.y / scalar;
	        result.z = quaternion.z / scalar;
	        result.w = quaternion.w / scalar;
	        return result;
	    };

	    /**
	     * Computes the axis of rotation of the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to use.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Quaternion.computeAxis = function(quaternion, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var w = quaternion.w;
	        if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {
	            result.x = result.y = result.z = 0;
	            return result;
	        }

	        var scalar = 1.0 / Math.sqrt(1.0 - (w * w));

	        result.x = quaternion.x * scalar;
	        result.y = quaternion.y * scalar;
	        result.z = quaternion.z * scalar;
	        return result;
	    };

	    /**
	     * Computes the angle of rotation of the provided quaternion.
	     *
	     * @param {Quaternion} quaternion The quaternion to use.
	     * @returns {Number} The angle of rotation.
	     */
	    Quaternion.computeAngle = function(quaternion) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required');
	        }
	        //>>includeEnd('debug');

	        if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {
	            return 0.0;
	        }
	        return 2.0 * Math.acos(quaternion.w);
	    };

	    var lerpScratch = new Quaternion();
	    /**
	     * Computes the linear interpolation or extrapolation at t using the provided quaternions.
	     *
	     * @param {Quaternion} start The value corresponding to t at 0.0.
	     * @param {Quaternion} end The value corresponding to t at 1.0.
	     * @param {Number} t The point along t at which to interpolate.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.lerp = function(start, end, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(start)) {
	            throw new DeveloperError('start is required.');
	        }
	        if (!defined(end)) {
	            throw new DeveloperError('end is required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);
	        result = Quaternion.multiplyByScalar(start, 1.0 - t, result);
	        return Quaternion.add(lerpScratch, result, result);
	    };

	    var slerpEndNegated = new Quaternion();
	    var slerpScaledP = new Quaternion();
	    var slerpScaledR = new Quaternion();
	    /**
	     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
	     *
	     * @param {Quaternion} start The value corresponding to t at 0.0.
	     * @param {Quaternion} end The value corresponding to t at 1.0.
	     * @param {Number} t The point along t at which to interpolate.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     *
	     * @see Quaternion#fastSlerp
	     */
	    Quaternion.slerp = function(start, end, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(start)) {
	            throw new DeveloperError('start is required.');
	        }
	        if (!defined(end)) {
	            throw new DeveloperError('end is required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var dot = Quaternion.dot(start, end);

	        // The angle between start must be acute. Since q and -q represent
	        // the same rotation, negate q to get the acute angle.
	        var r = end;
	        if (dot < 0.0) {
	            dot = -dot;
	            r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
	        }

	        // dot > 0, as the dot product approaches 1, the angle between the
	        // quaternions vanishes. use linear interpolation.
	        if (1.0 - dot < CesiumMath.EPSILON6) {
	            return Quaternion.lerp(start, r, t, result);
	        }

	        var theta = Math.acos(dot);
	        slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);
	        slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);
	        result = Quaternion.add(slerpScaledP, slerpScaledR, result);
	        return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);
	    };

	    /**
	     * The logarithmic quaternion function.
	     *
	     * @param {Quaternion} quaternion The unit quaternion.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Quaternion.log = function(quaternion, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(quaternion)) {
	            throw new DeveloperError('quaternion is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var theta = CesiumMath.acosClamped(quaternion.w);
	        var thetaOverSinTheta = 0.0;

	        if (theta !== 0.0) {
	            thetaOverSinTheta = theta / Math.sin(theta);
	        }

	        return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);
	    };

	    /**
	     * The exponential quaternion function.
	     *
	     * @param {Cartesian3} cartesian The cartesian.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     */
	    Quaternion.exp = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var theta = Cartesian3.magnitude(cartesian);
	        var sinThetaOverTheta = 0.0;

	        if (theta !== 0.0) {
	            sinThetaOverTheta = Math.sin(theta) / theta;
	        }

	        result.x = cartesian.x * sinThetaOverTheta;
	        result.y = cartesian.y * sinThetaOverTheta;
	        result.z = cartesian.z * sinThetaOverTheta;
	        result.w = Math.cos(theta);

	        return result;
	    };

	    var squadScratchCartesian0 = new Cartesian3();
	    var squadScratchCartesian1 = new Cartesian3();
	    var squadScratchQuaternion0 = new Quaternion();
	    var squadScratchQuaternion1 = new Quaternion();

	    /**
	     * Computes an inner quadrangle point.
	     * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>
	     *
	     * @param {Quaternion} q0 The first quaternion.
	     * @param {Quaternion} q1 The second quaternion.
	     * @param {Quaternion} q2 The third quaternion.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     *
	     * @see Quaternion#squad
	     */
	    Quaternion.computeInnerQuadrangle = function(q0, q1, q2, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(q0) || !defined(q1) || !defined(q2)) {
	            throw new DeveloperError('q0, q1, and q2 are required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);
	        Quaternion.multiply(qInv, q2, squadScratchQuaternion1);
	        var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);

	        Quaternion.multiply(qInv, q0, squadScratchQuaternion1);
	        var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);

	        Cartesian3.add(cart0, cart1, cart0);
	        Cartesian3.multiplyByScalar(cart0, 0.25, cart0);
	        Cartesian3.negate(cart0, cart0);
	        Quaternion.exp(cart0, squadScratchQuaternion0);

	        return Quaternion.multiply(q1, squadScratchQuaternion0, result);
	    };

	    /**
	     * Computes the spherical quadrangle interpolation between quaternions.
	     *
	     * @param {Quaternion} q0 The first quaternion.
	     * @param {Quaternion} q1 The second quaternion.
	     * @param {Quaternion} s0 The first inner quadrangle.
	     * @param {Quaternion} s1 The second inner quadrangle.
	     * @param {Number} t The time in [0,1] used to interpolate.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     *
	     * @see Quaternion#computeInnerQuadrangle
	     *
	     * @example
	     * // 1. compute the squad interpolation between two quaternions on a curve
	     * var s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1]);
	     * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2]);
	     * var q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t);
	     *
	     * // 2. compute the squad interpolation as above but where the first quaternion is a end point.
	     * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2]);
	     * var q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t);
	     */
	    Quaternion.squad = function(q0, q1, s0, s1, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
	            throw new DeveloperError('q0, q1, s0, and s1 are required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);
	        var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);
	        return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
	    };

	    var fastSlerpScratchQuaternion = new Quaternion();
	    var opmu = 1.90110745351730037;
	    var u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	    var v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	    var bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
	    var bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];

	    for (var i = 0; i < 7; ++i) {
	        var s = i + 1.0;
	        var t = 2.0 * s + 1.0;
	        u[i] = 1.0 / (s * t);
	        v[i] = s / t;
	    }

	    u[7] = opmu / (8.0 * 17.0);
	    v[7] = opmu * 8.0 / 17.0;

	    /**
	     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
	     * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.
	     *
	     * @param {Quaternion} start The value corresponding to t at 0.0.
	     * @param {Quaternion} end The value corresponding to t at 1.0.
	     * @param {Number} t The point along t at which to interpolate.
	     * @param {Quaternion} result The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter.
	     *
	     * @see Quaternion#slerp
	     */
	    Quaternion.fastSlerp = function(start, end, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(start)) {
	            throw new DeveloperError('start is required.');
	        }
	        if (!defined(end)) {
	            throw new DeveloperError('end is required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var x = Quaternion.dot(start, end);

	        var sign;
	        if (x >= 0) {
	            sign = 1.0;
	        } else {
	            sign = -1.0;
	            x = -x;
	        }

	        var xm1 = x - 1.0;
	        var d = 1.0 - t;
	        var sqrT = t * t;
	        var sqrD = d * d;

	        for (var i = 7; i >= 0; --i) {
	            bT[i] = (u[i] * sqrT - v[i]) * xm1;
	            bD[i] = (u[i] * sqrD - v[i]) * xm1;
	        }

	        var cT = sign * t * (
	            1.0 + bT[0] * (1.0 + bT[1] * (1.0 + bT[2] * (1.0 + bT[3] * (
	            1.0 + bT[4] * (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));
	        var cD = d * (
	            1.0 + bD[0] * (1.0 + bD[1] * (1.0 + bD[2] * (1.0 + bD[3] * (
	            1.0 + bD[4] * (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));

	        var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);
	        Quaternion.multiplyByScalar(end, cT, result);
	        return Quaternion.add(temp, result, result);
	    };

	    /**
	     * Computes the spherical quadrangle interpolation between quaternions.
	     * An implementation that is faster than {@link Quaternion#squad}, but less accurate.
	     *
	     * @param {Quaternion} q0 The first quaternion.
	     * @param {Quaternion} q1 The second quaternion.
	     * @param {Quaternion} s0 The first inner quadrangle.
	     * @param {Quaternion} s1 The second inner quadrangle.
	     * @param {Number} t The time in [0,1] used to interpolate.
	     * @param {Quaternion} [result] The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter or a new instance if none was provided.
	     *
	     * @see Quaternion#squad
	     */
	    Quaternion.fastSquad = function(q0, q1, s0, s1, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
	            throw new DeveloperError('q0, q1, s0, and s1 are required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);
	        var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);
	        return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
	    };

	    /**
	     * Compares the provided quaternions componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Quaternion} [left] The first quaternion.
	     * @param {Quaternion} [right] The second quaternion.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Quaternion.equals = function(left, right) {
	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (left.x === right.x) &&
	                (left.y === right.y) &&
	                (left.z === right.z) &&
	                (left.w === right.w));
	    };

	    /**
	     * Compares the provided quaternions componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Quaternion} [left] The first quaternion.
	     * @param {Quaternion} [right] The second quaternion.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Quaternion.equalsEpsilon = function(left, right, epsilon) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof epsilon !== 'number') {
	            throw new DeveloperError('epsilon is required and must be a number.');
	        }
	        //>>includeEnd('debug');

	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (Math.abs(left.x - right.x) <= epsilon) &&
	                (Math.abs(left.y - right.y) <= epsilon) &&
	                (Math.abs(left.z - right.z) <= epsilon) &&
	                (Math.abs(left.w - right.w) <= epsilon));
	    };

	    /**
	     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
	     *
	     * @type {Quaternion}
	     * @constant
	     */
	    Quaternion.ZERO = freezeObject(new Quaternion(0.0, 0.0, 0.0, 0.0));

	    /**
	     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
	     *
	     * @type {Quaternion}
	     * @constant
	     */
	    Quaternion.IDENTITY = freezeObject(new Quaternion(0.0, 0.0, 0.0, 1.0));

	    /**
	     * Duplicates this Quaternion instance.
	     *
	     * @param {Quaternion} [result] The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
	     */
	    Quaternion.prototype.clone = function(result) {
	        return Quaternion.clone(this, result);
	    };

	    /**
	     * Compares this and the provided quaternion componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Quaternion} [right] The right hand side quaternion.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Quaternion.prototype.equals = function(right) {
	        return Quaternion.equals(this, right);
	    };

	    /**
	     * Compares this and the provided quaternion componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Quaternion} [right] The right hand side quaternion.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Quaternion.prototype.equalsEpsilon = function(right, epsilon) {
	        return Quaternion.equalsEpsilon(this, right, epsilon);
	    };

	    /**
	     * Returns a string representing this quaternion in the format (x, y, z, w).
	     *
	     * @returns {String} A string representing this Quaternion.
	     */
	    Quaternion.prototype.toString = function() {
	        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
	    };

	    return Quaternion;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined) {
	    "use strict";

	    /**
	     * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
	     * out of memory, could not compile shader, etc.  If a function may throw this
	     * exception, the calling code should be prepared to catch it.
	     * <br /><br />
	     * On the other hand, a {@link DeveloperError} indicates an exception due
	     * to a developer error, e.g., invalid argument, that usually indicates a bug in the
	     * calling code.
	     *
	     * @alias RuntimeError
	     * @constructor
	     *
	     * @param {String} [message] The error message for this exception.
	     *
	     * @see DeveloperError
	     */
	    var RuntimeError = function(message) {
	        /**
	         * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
	         * @type {String}
	         * @readonly
	         */
	        this.name = 'RuntimeError';

	        /**
	         * The explanation for why this exception was thrown.
	         * @type {String}
	         * @readonly
	         */
	        this.message = message;

	        //Browsers such as IE don't have a stack property until you actually throw the error.
	        var stack;
	        try {
	            throw new Error();
	        } catch (e) {
	            stack = e.stack;
	        }

	        /**
	         * The stack trace of this exception, if available.
	         * @type {String}
	         * @readonly
	         */
	        this.stack = stack;
	    };

	    RuntimeError.prototype.toString = function() {
	        var str = this.name + ': ' + this.message;

	        if (defined(this.stack)) {
	            str += '\n' + this.stack.toString();
	        }

	        return str;
	    };

	    return RuntimeError;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define,console*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        DeveloperError) {
	    "use strict";

	    var warnings = {};

	    /**
	     * Logs a deprecation message to the console.  Use this function instead of
	     * <code>console.log</code> directly since this does not log duplicate messages
	     * unless it is called from multiple workers.
	     *
	     * @exports deprecationWarning
	     *
	     * @param {String} identifier The unique identifier for this deprecated API.
	     * @param {String} message The message to log to the console.
	     *
	     * @example
	     * // Deprecated function or class
	     * var Foo = function() {
	     *    deprecationWarning('Foo', 'Foo was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use newFoo instead.');
	     *    // ...
	     * }
	     *
	     * // Deprecated function
	     * Bar.prototype.func = function() {
	     *    deprecationWarning('Bar.func', 'Bar.func() was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newFunc() instead.');
	     *    // ...
	     * };
	     *
	     * // Deprecated property
	     * defineProperties(Bar.prototype, {
	     *     prop : {
	     *         get : function() {
	     *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');
	     *             // ...
	     *         },
	     *         set : function(value) {
	     *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');
	     *             // ...
	     *         }
	     *     }
	     * });
	     *
	     * @private
	     */
	    var deprecationWarning = function(identifier, message) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(identifier) || !defined(message)) {
	            throw new DeveloperError('identifier and message are required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(warnings[identifier])) {
	            warnings[identifier] = true;
	            console.log(message);
	        }
	    };

	    return deprecationWarning;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _createClass = __webpack_require__(69)['default'];

	var _classCallCheck = __webpack_require__(26)['default'];

	var _WeakMap = __webpack_require__(50)['default'];

	var EventPort = __webpack_require__(39);
	var EventHandler = __webpack_require__(32).EventHandler;
	var Util = __webpack_require__(22);
	var VersionTransformer = __webpack_require__(147);
	var asap = __webpack_require__(58);
	var Promise = __webpack_require__(17);

	var _require = __webpack_require__(33);

	var getCapabilities = _require.getCapabilities;

	var ArgonSemver = __webpack_require__(49).semver;
	var ArgonVersion = __webpack_require__(49).version;

	var CSSClass = 'argon-channel';

	var Channel = (function () {
	  function Channel() {
	    var _this = this;

	    var options = arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Channel);

	    this.id = Util.cuid();
	    Channel.collection[this.id] = this;
	    Util.mixinInputOutputEventHandlers(this);

	    this._url = null;
	    this._history = [];
	    this._messagePort = null;

	    this.port = new EventPort(_sendToChannel.bind(this), (function output(type, event) {
	      Channel.port.output.emit(type, event);
	      return true;
	    }).bind(this));

	    this.element = options.element || document.createElement('iframe');
	    this.element.webkitallowfullscreen = false;
	    this.element.sandbox = 'allow-forms allow-scripts allow-same-origin';
	    this.element.classList.add(CSSClass);
	    this.element.id = CSSClass + '-' + this.id;
	    this.element.channel = this;

	    if (!options.element) {
	      var container = document.documentElement;
	      if (options && options.container) container = options.container;
	      container.appendChild(this.element);
	    }

	    // 'unload' event from argon.js
	    this.port.on('unload', _unload.bind(this));
	    this.element.onload = _load.bind(this);
	    this.loaded = false;
	    this.inLoad = false;

	    if (options.src) this.setURL(options.src);

	    this.on('connect', function () {
	      if (_this._hasFocus) {
	        _this.port.trigger('focus');
	      } else {
	        _this.port.trigger('blur');
	      }
	    });
	  }

	  Channel.prototype.setURL = function setURL(url) {
	    var _this2 = this;

	    asap(function () {
	      _setURL.call(_this2, url);
	      if (_this2._url) {
	        _this2.element.src = _this2._url;
	      } else {
	        _this2.element.src = 'about:blank';
	      }
	      _this2._waitingForLoad = true;
	    });
	  };

	  Channel.prototype.setSrcDoc = function setSrcDoc(doc) {
	    var _this3 = this;

	    asap(function () {
	      _setURL.call(_this3, ' ');
	      _this3.element.src = undefined;
	      _this3.element.srcdoc = doc;
	      _this3._waitingForLoad = true;
	    });
	  };

	  Channel.prototype.getURL = function getURL() {
	    return this._url;
	  };

	  Channel.prototype.getHistory = function getHistory() {
	    return this._history;
	  };

	  Channel.prototype.focus = function focus() {
	    this._hasFocus = true;
	    for (var id in Channel.collection) {
	      var channel = Channel.collection[id];
	      if (this !== channel) {
	        channel._hasFocus = false;
	        channel.port.trigger('blur');
	        channel._emit('blur');
	      }
	    }
	    Channel.focussedChannel = this;
	    this.port.trigger('focus');
	    this._emit('focus');
	    Channel.events.emit('focus', this);
	  };

	  Channel.prototype.whenFocussed = function whenFocussed() {
	    var deferred = Promise.defer();
	    if (this._hasFocus) {
	      deferred.resolve();
	    } else {
	      this.once('focus', function () {
	        deferred.resolve();
	      });
	    }
	    return deferred.promise;
	  };

	  Channel.prototype.destroy = function destroy() {
	    _unload.call(this);
	    delete Channel.collection[this.id];
	    if (this.element.parentNode) this.element.parentNode.removeChild(this.element);
	  };

	  _createClass(Channel, [{
	    key: 'hasFocus',
	    get: function () {
	      return this._hasFocus;
	    }
	  }]);

	  return Channel;
	})();

	Channel.collection = {};
	Channel.eventMap = new _WeakMap();
	Channel.events = new EventHandler();
	Channel.focussedChannel = undefined;

	Channel.hideBlurredChannels = function () {
	  for (var id in Channel.collection) {
	    var c = Channel.collection[id];
	    if (!c.hasFocus) c.element.style.display = 'none';
	  }
	};

	Channel.showAllChannels = function () {
	  for (var id in Channel.collection) {
	    var c = Channel.collection[id];
	    c.element.style.display = '';
	  }
	};

	// channel manager <-> channel communication
	Channel.port = new EventPort();
	Channel.port.input.pipe(function (type, event) {
	  for (var id in Channel.collection) {
	    Channel.collection[id].port.trigger(type, event);
	  }
	});

	Channel.requestHandler = {};

	Channel.port.on('REQUEST', function (request) {
	  var channel = Channel.eventMap.get(request);
	  if (Channel.requestHandler[request.type]) {
	    Promise.resolve({ channel: channel, data: request.event }).then(Channel.requestHandler[request.type]).then(function (e) {
	      channel.port.trigger('RESPONSE', { id: request.id, resolve: e });
	    })['catch'](function (e) {
	      var reason = e.toJSON ? e.toJSON() : e;
	      channel.port.trigger('RESPONSE', { id: request.id, reject: reason });
	    });
	  } else {
	    channel.port.trigger('RESPONSE', { id: request.id, reject: { message: 'unhandled request' } });
	  }
	});

	function _unload() {
	  if (!this.loaded) return;
	  if (this._messagePort) this._messagePort.close();
	  this._messagePort = null;
	  this._messageQueue = [];
	  this._url = null;
	  this.version = null;
	  this.semver = null;
	  this._emit('unload');
	  Channel.events.emit('unload', this);
	  this.loaded = false;
	}

	function _load() {
	  this.inLoad = true;
	  _unload.call(this);
	  if (this._waitingForLoad) {
	    // this page load was expected
	    this._waitingForLoad = false;
	  } else {
	    // this page load was not expected
	    // (we do not know where we are now)
	    _setURL.call(this, '***');
	  }
	  this.loaded = true;
	  this._emit('load');
	  Channel.events.emit('load', { channel: this });
	  // if we already have focus, then send focus events again
	  if (this._hasFocus) this.focus();
	  this.inLoad = false;
	}

	function _parseVersion(version) {
	  var tokens = version.split('.');
	  return {
	    major: tokens[0],
	    minor: tokens[1],
	    patch: tokens[2]
	  };
	}

	function _onconnect(channelInfo) {
	  var _this4 = this;

	  this.version = channelInfo.ARGON_VERSION_STRING;
	  this.semver = _parseVersion(this.version);

	  // TODO: Once argon.js is beyond major version 0, only
	  // check major & minor versions here. Also, maybe should
	  // use a semver library for comparing semvers.
	  // TODO: backwards compatability
	  if (this.semver.major > ArgonSemver.major || this.semver.minor > ArgonSemver.minor || this.semver.patch > ArgonSemver.patch) {
	    alert('The channel at ' + this._url + ' requires a newer version of Argon (' + this.version + '). You are currently running version ' + ArgonVersion + '. Please update Argon in order to open this channel.');
	    _unload.call(this);
	    _setURL.call(this, null);
	    return;
	  } else if (this.semver.major < ArgonSemver.major || this.semver.minor < ArgonSemver.minor || this.semver.patch < ArgonSemver.patch) {
	    alert('The channel at ' + this._url + ' uses an older version argon.js, which may not work be compatible with your version of Argon (' + ArgonVersion + '). Please update the channel to the latest argon.js');
	    _unload.call(this);
	    _setURL.call(this, null);
	    return;
	  }

	  _setURL.call(this, channelInfo.ARGON_URL);

	  var mc = new MessageChannel();
	  var connectMessage = { msg: 'ARGON_CONNECT', capabilities: getCapabilities(), focus: this.hasFocus };
	  this.element.contentWindow.postMessage(connectMessage, '*', [mc.port2]);
	  this._messagePort = mc.port1;

	  this._messagePort.onmessage = function (message) {
	    var data = message.data;
	    var event = data.event || {};
	    // associate the event to the source channel via a weakmap
	    Channel.eventMap.set(event, _this4);
	    _this4.port.output.emit(data.type, event);
	  };
	}

	function _sendToChannel(type, event) {
	  if (!this._messagePort) return;
	  // transform outgoing messages for backwards compatability
	  var message = VersionTransformer.toChannel(type, event, this.semver);
	  this._messagePort.postMessage(message);
	}

	function _setURL(url) {
	  if (this._url != url) {
	    if (url && url !== '***') this._history.push(url);
	    this._url = url;
	    this._emit('navigation', { url: this._url });
	  }
	}

	window.addEventListener('message', function (event) {
	  if (event.data.ARGON_URL) {
	    for (var i in Channel.collection) {
	      var channel = Channel.collection[i];
	      if (channel.element.contentWindow === event.source) {
	        _onconnect.call(channel, event.data);
	        channel._emit('connect');
	        Channel.events.emit('connection', channel);
	        return;
	      }
	    }
	  }
	}, true);

	module.exports = Channel;
	// TODO: In iOS 8, with native WKWebview APIs, we should be able to detect
	// iframe navigation, and then we can notify the appropriate channel.

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	var EventMapper = __webpack_require__(32).EventMapper;
	var EventHandler = __webpack_require__(32).EventHandler;
	var EventFilter = __webpack_require__(32).EventFilter;

	/**
	 * An input & output event mapper/filter.
	 * @private
	 */
	function EventPort(inputHandler, outputHandler) {
	  this.input = this._eventInput = new EventHandler();
	  this.input.subscribe = false;
	  this.output = this._eventOutput = new EventHandler();
	  EventHandler.setInputHandler(this, this.input);
	  EventHandler.setOutputHandler(this, this.output);
	  this.emit = this.trigger;
	  if (inputHandler) this.input.pipe(inputHandler);
	  if (outputHandler) this.output.pipe(outputHandler);
	}

	module.exports = EventPort;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	// handles channelManager <-> channel communication
	'use strict';

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _EventPort = __webpack_require__(39);

	var _EventPort2 = _interopRequireDefault(_EventPort);

	var _Util = __webpack_require__(22);

	var _Util2 = _interopRequireDefault(_Util);

	var _Platform = __webpack_require__(18);

	var _ready = __webpack_require__(33);

	var managerPort;

	if (_Platform.isChannel) {
	  var _messagePort;

	  var connectDeferred;

	  (function () {
	    var _onmessage = function (message) {
	      if (message.type === 'MESSAGE_QUEUE') {
	        var queue = message.event;
	        for (var i in queue) {
	          var m = queue[i];
	          managerPort.output.emit(m.type, m.event);
	        }
	      } else {
	        managerPort.output.emit(message.type, message.event);
	      }
	    };

	    managerPort = new _EventPort2['default']();
	    _messagePort = null;
	    connectDeferred = _bluebird2['default'].defer();

	    managerPort.whenConnected = connectDeferred.promise;
	    managerPort.isConnected = false;

	    managerPort.input.pipe(function (type, event) {
	      if (managerPort.isConnected) {
	        if (_messagePort) _messagePort.postMessage({ type: type, event: event });
	      } else {
	        managerPort.whenConnected.then(function () {
	          managerPort.trigger(type, event);
	        });
	      }
	    });

	    managerPort.requests = {};

	    managerPort.request = function (type, event) {
	      var deferred = _bluebird2['default'].defer();
	      var id = _Util2['default'].cuid();
	      managerPort.requests[id] = deferred;
	      managerPort.trigger('REQUEST', { type: type, event: event, id: id });
	      return deferred.promise;
	    };

	    // used by our remote debugger to simulate a connection with the manager
	    managerPort.connect = function () {
	      var config = arguments[0] === undefined ? {} : arguments[0];

	      (0, _ready.setReady)(config.capabilities);
	      managerPort.isConnected = true;
	      connectDeferred.resolve(config);
	    };

	    managerPort.on('RESPONSE', function onRESPONSE(e) {
	      var deferred = managerPort.requests[e.id];
	      if (!deferred) {
	        console.warn('Unknown RESPONSE received: ' + JSON.stringify(e));
	        return;
	      }
	      delete managerPort.requests[e.id];
	      if (e.reject) {
	        var err = new Error(e.reject.message || e.reject.description || e.reject);
	        if (e.reject.stack) err.stack = e.reject.stack;
	        deferred.reject(err);
	      } else deferred.resolve(e.resolve);
	    });

	    window.addEventListener('message', function (messageEvent) {
	      if (messageEvent.data.msg === 'ARGON_CONNECT') {
	        _messagePort = messageEvent.ports[0];
	        _messagePort.onmessage = function (event) {
	          _onmessage(event.data);
	        };
	        managerPort.connect(messageEvent.data.capabilities);
	      }
	    }, false);

	    window.addEventListener('unload', function (event) {
	      managerPort.trigger('unload');
	    });
	  })();
	}

	exports['default'] = managerPort;
	module.exports = exports['default'];

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// Optional / simple context binding
	var assertFunction = __webpack_require__(20).fn;
	module.exports = function(fn, that, length){
	  assertFunction(fn);
	  if(~length && that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  } return function(/* ...args */){
	      return fn.apply(that, arguments);
	    };
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var $def            = __webpack_require__(27)
	  , $               = __webpack_require__(5)
	  , cof             = __webpack_require__(30)
	  , $iter           = __webpack_require__(13)
	  , SYMBOL_ITERATOR = __webpack_require__(14)('iterator')
	  , FF_ITERATOR     = '@@iterator'
	  , KEYS            = 'keys'
	  , VALUES          = 'values'
	  , Iterators       = $iter.Iterators;
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
	  $iter.create(Constructor, NAME, next);
	  function createMethod(kind){
	    function $$(that){
	      return new Constructor(that, kind);
	    }
	    switch(kind){
	      case KEYS: return function keys(){ return $$(this); };
	      case VALUES: return function values(){ return $$(this); };
	    } return function entries(){ return $$(this); };
	  }
	  var TAG      = NAME + ' Iterator'
	    , proto    = Base.prototype
	    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , _default = _native || createMethod(DEFAULT)
	    , methods, key;
	  // Fix native
	  if(_native){
	    var IteratorPrototype = $.getProto(_default.call(new Base));
	    // Set @@toStringTag to native iterators
	    cof.set(IteratorPrototype, TAG, true);
	    // FF fix
	    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);
	  }
	  // Define iterator
	  if($.FW)$iter.set(proto, _default);
	  // Plug for library
	  Iterators[NAME] = _default;
	  Iterators[TAG]  = $.that;
	  if(DEFAULT){
	    methods = {
	      keys:    IS_SET            ? _default : createMethod(KEYS),
	      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
	      entries: DEFAULT != VALUES ? _default : createMethod('entries')
	    };
	    if(FORCE)for(key in methods){
	      if(!(key in proto))$.hide(proto, key, methods[key]);
	    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
	  }
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(52),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        Cartographic,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    function initialize(ellipsoid, x, y, z) {
	        x = defaultValue(x, 0.0);
	        y = defaultValue(y, 0.0);
	        z = defaultValue(z, 0.0);

	        //>>includeStart('debug', pragmas.debug);
	        if (x < 0.0 || y < 0.0 || z < 0.0) {
	            throw new DeveloperError('All radii components must be greater than or equal to zero.');
	        }
	        //>>includeEnd('debug');

	        ellipsoid._radii = new Cartesian3(x, y, z);

	        ellipsoid._radiiSquared = new Cartesian3(x * x,
	                                            y * y,
	                                            z * z);

	        ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x,
	                                                y * y * y * y,
	                                                z * z * z * z);

	        ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x,
	                                            y === 0.0 ? 0.0 : 1.0 / y,
	                                            z === 0.0 ? 0.0 : 1.0 / z);

	        ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x),
	                                                   y === 0.0 ? 0.0 : 1.0 / (y * y),
	                                                   z === 0.0 ? 0.0 : 1.0 / (z * z));

	        ellipsoid._minimumRadius = Math.min(x, y, z);

	        ellipsoid._maximumRadius = Math.max(x, y, z);

	        ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;
	    }

	    /**
	     * A quadratic surface defined in Cartesian coordinates by the equation
	     * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
	     * by Cesium to represent the shape of planetary bodies.
	     *
	     * Rather than constructing this object directly, one of the provided
	     * constants is normally used.
	     * @alias Ellipsoid
	     * @constructor
	     *
	     * @param {Number} [x=0] The radius in the x direction.
	     * @param {Number} [y=0] The radius in the y direction.
	     * @param {Number} [z=0] The radius in the z direction.
	     *
	     * @exception {DeveloperError} All radii components must be greater than or equal to zero.
	     *
	     * @see Ellipsoid.fromCartesian3
	     * @see Ellipsoid.WGS84
	     * @see Ellipsoid.UNIT_SPHERE
	     */
	    var Ellipsoid = function(x, y, z) {
	        this._radii = undefined;
	        this._radiiSquared = undefined;
	        this._radiiToTheFourth = undefined;
	        this._oneOverRadii = undefined;
	        this._oneOverRadiiSquared = undefined;
	        this._minimumRadius = undefined;
	        this._maximumRadius = undefined;
	        this._centerToleranceSquared = undefined;

	        initialize(this, x, y, z);
	    };

	    defineProperties(Ellipsoid.prototype, {
	        /**
	         * Gets the radii of the ellipsoid.
	         * @memberof Ellipsoid.prototype
	         * @type {Cartesian3}
	         */
	        radii : {
	            get: function() {
	                return this._radii;
	            }
	        },
	        /**
	         * Gets the squared radii of the ellipsoid.
	         * @memberof Ellipsoid.prototype
	         * @type {Cartesian3}
	         */
	        radiiSquared : {
	            get : function() {
	                return this._radiiSquared;
	            }
	        },
	        /**
	         * Gets the radii of the ellipsoid raise to the fourth power.
	         * @memberof Ellipsoid.prototype
	         * @type {Cartesian3}
	         */
	        radiiToTheFourth : {
	            get : function() {
	                return this._radiiToTheFourth;
	            }
	        },
	        /**
	         * Gets one over the radii of the ellipsoid.
	         * @memberof Ellipsoid.prototype
	         * @type {Cartesian3}
	         */
	        oneOverRadii : {
	            get : function() {
	                return this._oneOverRadii;
	            }
	        },
	        /**
	         * Gets one over the squared radii of the ellipsoid.
	         * @memberof Ellipsoid.prototype
	         * @type {Cartesian3}
	         */
	        oneOverRadiiSquared : {
	            get : function() {
	                return this._oneOverRadiiSquared;
	            }
	        },
	        /**
	         * Gets the minimum radius of the ellipsoid.
	         * @memberof Ellipsoid.prototype
	         * @type {Number}
	         */
	        minimumRadius : {
	            get : function() {
	                return this._minimumRadius;
	            }
	        },
	        /**
	         * Gets the maximum radius of the ellipsoid.
	         * @memberof Ellipsoid.prototype
	         * @type {Number}
	         */
	        maximumRadius : {
	            get : function() {
	                return this._maximumRadius;
	            }
	        }
	    });

	    /**
	     * Duplicates an Ellipsoid instance.
	     *
	     * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.
	     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
	     *                    instance should be created.
	     * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)
	     */
	    Ellipsoid.clone = function(ellipsoid, result) {
	        if (!defined(ellipsoid)) {
	            return undefined;
	        }
	        var radii = ellipsoid._radii;

	        if (!defined(result)) {
	            return new Ellipsoid(radii.x, radii.y, radii.z);
	        }

	        Cartesian3.clone(radii, result._radii);
	        Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);
	        Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
	        Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
	        Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
	        result._minimumRadius = ellipsoid._minimumRadius;
	        result._maximumRadius = ellipsoid._maximumRadius;
	        result._centerToleranceSquared = ellipsoid._centerToleranceSquared;

	        return result;
	    };

	    /**
	     * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
	     *
	     * @param {Cartesian3} [radii=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.
	     * @returns {Ellipsoid} A new Ellipsoid instance.
	     *
	     * @exception {DeveloperError} All radii components must be greater than or equal to zero.
	     *
	     * @see Ellipsoid.WGS84
	     * @see Ellipsoid.UNIT_SPHERE
	     */
	    Ellipsoid.fromCartesian3 = function(cartesian, result) {
	        if (!defined(result)) {
	            result = new Ellipsoid();
	        }

	        if (!defined(cartesian)) {
	            return result;
	        }

	        initialize(result, cartesian.x, cartesian.y, cartesian.z);
	        return result;
	    };

	    /**
	     * An Ellipsoid instance initialized to the WGS84 standard.
	     *
	     * @type {Ellipsoid}
	     * @constant
	     */
	    Ellipsoid.WGS84 = freezeObject(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));

	    /**
	     * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
	     *
	     * @type {Ellipsoid}
	     * @constant
	     */
	    Ellipsoid.UNIT_SPHERE = freezeObject(new Ellipsoid(1.0, 1.0, 1.0));

	    /**
	     * An Ellipsoid instance initialized to a sphere with the lunar radius.
	     *
	     * @type {Ellipsoid}
	     * @constant
	     */
	    Ellipsoid.MOON = freezeObject(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));

	    /**
	     * Duplicates an Ellipsoid instance.
	     *
	     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
	     *                    instance should be created.
	     * @returns {Ellipsoid} The cloned Ellipsoid.
	     */
	    Ellipsoid.prototype.clone = function(result) {
	        return Ellipsoid.clone(this, result);
	    };

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Ellipsoid.packedLength = Cartesian3.packedLength;

	    /**
	     * Stores the provided instance into the provided array.
	     * @function
	     *
	     * @param {Object} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Ellipsoid.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        Cartesian3.pack(value._radii, array, startingIndex);
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Ellipsoid} [result] The object into which to store the result.
	     */
	    Ellipsoid.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        var radii = Cartesian3.unpack(array, startingIndex);
	        return Ellipsoid.fromCartesian3(radii, result);
	    };

	    /**
	     * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
	     * @function
	     *
	     * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	     */
	    Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;

	    /**
	     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
	     *
	     * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	     */
	    Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartographic)) {
	            throw new DeveloperError('cartographic is required.');
	        }
	        //>>includeEnd('debug');

	        var longitude = cartographic.longitude;
	        var latitude = cartographic.latitude;
	        var cosLatitude = Math.cos(latitude);

	        var x = cosLatitude * Math.cos(longitude);
	        var y = cosLatitude * Math.sin(longitude);
	        var z = Math.sin(latitude);

	        if (!defined(result)) {
	            result = new Cartesian3();
	        }
	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return Cartesian3.normalize(result, result);
	    };

	    /**
	     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
	     *
	     * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	     */
	    Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {
	        if (!defined(result)) {
	            result = new Cartesian3();
	        }
	        result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);
	        return Cartesian3.normalize(result, result);
	    };

	    var cartographicToCartesianNormal = new Cartesian3();
	    var cartographicToCartesianK = new Cartesian3();

	    /**
	     * Converts the provided cartographic to Cartesian representation.
	     *
	     * @param {Cartographic} cartographic The cartographic position.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	     *
	     * @example
	     * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
	     * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);
	     * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);
	     */
	    Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {
	        //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.
	        var n = cartographicToCartesianNormal;
	        var k = cartographicToCartesianK;
	        this.geodeticSurfaceNormalCartographic(cartographic, n);
	        Cartesian3.multiplyComponents(this._radiiSquared, n, k);
	        var gamma = Math.sqrt(Cartesian3.dot(n, k));
	        Cartesian3.divideByScalar(k, gamma, k);
	        Cartesian3.multiplyByScalar(n, cartographic.height, n);

	        if (!defined(result)) {
	            result = new Cartesian3();
	        }
	        return Cartesian3.add(k, n, result);
	    };

	    /**
	     * Converts the provided array of cartographics to an array of Cartesians.
	     *
	     * @param {Cartographic[]} cartographics An array of cartographic positions.
	     * @param {Cartesian3[]} [result] The object onto which to store the result.
	     * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.
	     *
	     * @example
	     * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
	     * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),
	     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),
	     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)
	     * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
	     */
	    Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartographics)) {
	            throw new DeveloperError('cartographics is required.');
	        }
	        //>>includeEnd('debug');

	        var length = cartographics.length;
	        if (!defined(result)) {
	            result = new Array(length);
	        } else {
	            result.length = length;
	        }
	        for ( var i = 0; i < length; i++) {
	            result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
	        }
	        return result;
	    };

	    var cartesianToCartographicN = new Cartesian3();
	    var cartesianToCartographicP = new Cartesian3();
	    var cartesianToCartographicH = new Cartesian3();

	    /**
	     * Converts the provided cartesian to cartographic representation.
	     * The cartesian is undefined at the center of the ellipsoid.
	     *
	     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
	     *
	     * @example
	     * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
	     * var position = new Cesium.Cartesian(17832.12, 83234.52, 952313.73);
	     * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
	     */
	    Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {
	        //`cartesian is required.` is thrown from scaleToGeodeticSurface
	        var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);

	        if (!defined(p)) {
	            return undefined;
	        }

	        var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
	        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);

	        var longitude = Math.atan2(n.y, n.x);
	        var latitude = Math.asin(n.z);
	        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);

	        if (!defined(result)) {
	            return new Cartographic(longitude, latitude, height);
	        }
	        result.longitude = longitude;
	        result.latitude = latitude;
	        result.height = height;
	        return result;
	    };

	    /**
	     * Converts the provided array of cartesians to an array of cartographics.
	     *
	     * @param {Cartesian3[]} cartesians An array of Cartesian positions.
	     * @param {Cartographic[]} [result] The object onto which to store the result.
	     * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.
	     *
	     * @example
	     * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
	     * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),
	     *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),
	     *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]
	     * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
	     */
	    Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesians)) {
	            throw new DeveloperError('cartesians is required.');
	        }
	        //>>includeEnd('debug');

	        var length = cartesians.length;
	        if (!defined(result)) {
	            result = new Array(length);
	        } else {
	            result.length = length;
	        }
	        for ( var i = 0; i < length; ++i) {
	            result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
	        }
	        return result;
	    };

	    var scaleToGeodeticSurfaceIntersection = new Cartesian3();
	    var scaleToGeodeticSurfaceGradient = new Cartesian3();

	    /**
	     * Scales the provided Cartesian position along the geodetic surface normal
	     * so that it is on the surface of this ellipsoid.  If the position is
	     * at the center of the ellipsoid, this function returns undefined.
	     *
	     * @param {Cartesian3} cartesian The Cartesian position to scale.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
	     */
	    Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required.');
	        }
	        //>>includeEnd('debug');

	        var positionX = cartesian.x;
	        var positionY = cartesian.y;
	        var positionZ = cartesian.z;

	        var oneOverRadii = this._oneOverRadii;
	        var oneOverRadiiX = oneOverRadii.x;
	        var oneOverRadiiY = oneOverRadii.y;
	        var oneOverRadiiZ = oneOverRadii.z;

	        var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
	        var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
	        var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;

	        // Compute the squared ellipsoid norm.
	        var squaredNorm = x2 + y2 + z2;
	        var ratio = Math.sqrt(1.0 / squaredNorm);

	        // As an initial approximation, assume that the radial intersection is the projection point.
	        var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);

	        //* If the position is near the center, the iteration will not converge.
	        if (squaredNorm < this._centerToleranceSquared) {
	            return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);
	        }

	        var oneOverRadiiSquared = this._oneOverRadiiSquared;
	        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
	        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
	        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;

	        // Use the gradient at the intersection point in place of the true unit normal.
	        // The difference in magnitude will be absorbed in the multiplier.
	        var gradient = scaleToGeodeticSurfaceGradient;
	        gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;
	        gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;
	        gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;

	        // Compute the initial guess at the normal vector multiplier, lambda.
	        var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));
	        var correction = 0.0;

	        var func;
	        var denominator;
	        var xMultiplier;
	        var yMultiplier;
	        var zMultiplier;
	        var xMultiplier2;
	        var yMultiplier2;
	        var zMultiplier2;
	        var xMultiplier3;
	        var yMultiplier3;
	        var zMultiplier3;

	        do {
	            lambda -= correction;

	            xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
	            yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
	            zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);

	            xMultiplier2 = xMultiplier * xMultiplier;
	            yMultiplier2 = yMultiplier * yMultiplier;
	            zMultiplier2 = zMultiplier * zMultiplier;

	            xMultiplier3 = xMultiplier2 * xMultiplier;
	            yMultiplier3 = yMultiplier2 * yMultiplier;
	            zMultiplier3 = zMultiplier2 * zMultiplier;

	            func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;

	            // "denominator" here refers to the use of this expression in the velocity and acceleration
	            // computations in the sections to follow.
	            denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;

	            var derivative = -2.0 * denominator;

	            correction = func / derivative;
	        } while (Math.abs(func) > CesiumMath.EPSILON12);

	        if (!defined(result)) {
	            return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);
	        }
	        result.x = positionX * xMultiplier;
	        result.y = positionY * yMultiplier;
	        result.z = positionZ * zMultiplier;
	        return result;
	    };

	    /**
	     * Scales the provided Cartesian position along the geocentric surface normal
	     * so that it is on the surface of this ellipsoid.
	     *
	     * @param {Cartesian3} cartesian The Cartesian position to scale.
	     * @param {Cartesian3} [result] The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
	     */
	    Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            result = new Cartesian3();
	        }

	        var positionX = cartesian.x;
	        var positionY = cartesian.y;
	        var positionZ = cartesian.z;
	        var oneOverRadiiSquared = this._oneOverRadiiSquared;

	        var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x +
	                                   (positionY * positionY) * oneOverRadiiSquared.y +
	                                   (positionZ * positionZ) * oneOverRadiiSquared.z);

	        return Cartesian3.multiplyByScalar(cartesian, beta, result);
	    };

	    /**
	     * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
	     * its components by the result of {@link Ellipsoid#oneOverRadii}.
	     *
	     * @param {Cartesian3} position The position to transform.
	     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
	     *        return a new instance.
	     * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the
	     *          one passed as the result parameter if it is not undefined, or a new instance of it is.
	     */
	    Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {
	        if (!defined(result)) {
	            result = new Cartesian3();
	        }

	        return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
	    };

	    /**
	     * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
	     * its components by the result of {@link Ellipsoid#radii}.
	     *
	     * @param {Cartesian3} position The position to transform.
	     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
	     *        return a new instance.
	     * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the
	     *          one passed as the result parameter if it is not undefined, or a new instance of it is.
	     */
	    Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {
	        if (!defined(result)) {
	            result = new Cartesian3();
	        }

	        return Cartesian3.multiplyComponents(position, this._radii, result);
	    };

	    /**
	     * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Ellipsoid} [right] The other Ellipsoid.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    Ellipsoid.prototype.equals = function(right) {
	        return (this === right) ||
	               (defined(right) &&
	                Cartesian3.equals(this._radii, right._radii));
	    };

	    /**
	     * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
	     *
	     * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.
	     */
	    Ellipsoid.prototype.toString = function() {
	        return this._radii.toString();
	    };

	    return Ellipsoid;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(51),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(11),
	        __webpack_require__(29),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        Cartesian4,
	        defaultValue,
	        defined,
	        DeveloperError,
	        freezeObject,
	        CesiumMath,
	        Matrix3,
	        RuntimeError) {
	    "use strict";

	    /**
	     * A 4x4 matrix, indexable as a column-major order array.
	     * Constructor parameters are in row-major order for code readability.
	     * @alias Matrix4
	     * @constructor
	     *
	     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
	     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
	     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
	     * @param {Number} [column3Row0=0.0] The value for column 3, row 0.
	     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
	     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
	     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
	     * @param {Number} [column3Row1=0.0] The value for column 3, row 1.
	     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
	     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
	     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
	     * @param {Number} [column3Row2=0.0] The value for column 3, row 2.
	     * @param {Number} [column0Row3=0.0] The value for column 0, row 3.
	     * @param {Number} [column1Row3=0.0] The value for column 1, row 3.
	     * @param {Number} [column2Row3=0.0] The value for column 2, row 3.
	     * @param {Number} [column3Row3=0.0] The value for column 3, row 3.
	     *
	     * @see Matrix4.fromColumnMajorArray
	     * @see Matrix4.fromRowMajorArray
	     * @see Matrix4.fromRotationTranslation
	     * @see Matrix4.fromTranslationQuaternionRotationScale
	     * @see Matrix4.fromTranslation
	     * @see Matrix4.fromScale
	     * @see Matrix4.fromUniformScale
	     * @see Matrix4.fromCamera
	     * @see Matrix4.computePerspectiveFieldOfView
	     * @see Matrix4.computeOrthographicOffCenter
	     * @see Matrix4.computePerspectiveOffCenter
	     * @see Matrix4.computeInfinitePerspectiveOffCenter
	     * @see Matrix4.computeViewportTransformation
	     * @see Matrix2
	     * @see Matrix3
	     * @see Packable
	     */
	    var Matrix4 = function(column0Row0, column1Row0, column2Row0, column3Row0,
	                           column0Row1, column1Row1, column2Row1, column3Row1,
	                           column0Row2, column1Row2, column2Row2, column3Row2,
	                           column0Row3, column1Row3, column2Row3, column3Row3) {
	        this[0] = defaultValue(column0Row0, 0.0);
	        this[1] = defaultValue(column0Row1, 0.0);
	        this[2] = defaultValue(column0Row2, 0.0);
	        this[3] = defaultValue(column0Row3, 0.0);
	        this[4] = defaultValue(column1Row0, 0.0);
	        this[5] = defaultValue(column1Row1, 0.0);
	        this[6] = defaultValue(column1Row2, 0.0);
	        this[7] = defaultValue(column1Row3, 0.0);
	        this[8] = defaultValue(column2Row0, 0.0);
	        this[9] = defaultValue(column2Row1, 0.0);
	        this[10] = defaultValue(column2Row2, 0.0);
	        this[11] = defaultValue(column2Row3, 0.0);
	        this[12] = defaultValue(column3Row0, 0.0);
	        this[13] = defaultValue(column3Row1, 0.0);
	        this[14] = defaultValue(column3Row2, 0.0);
	        this[15] = defaultValue(column3Row3, 0.0);
	    };

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Matrix4.packedLength = 16;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Matrix4} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Matrix4.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }

	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value[0];
	        array[startingIndex++] = value[1];
	        array[startingIndex++] = value[2];
	        array[startingIndex++] = value[3];
	        array[startingIndex++] = value[4];
	        array[startingIndex++] = value[5];
	        array[startingIndex++] = value[6];
	        array[startingIndex++] = value[7];
	        array[startingIndex++] = value[8];
	        array[startingIndex++] = value[9];
	        array[startingIndex++] = value[10];
	        array[startingIndex++] = value[11];
	        array[startingIndex++] = value[12];
	        array[startingIndex++] = value[13];
	        array[startingIndex++] = value[14];
	        array[startingIndex] = value[15];
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Matrix4} [result] The object into which to store the result.
	     */
	    Matrix4.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Matrix4();
	        }

	        result[0] = array[startingIndex++];
	        result[1] = array[startingIndex++];
	        result[2] = array[startingIndex++];
	        result[3] = array[startingIndex++];
	        result[4] = array[startingIndex++];
	        result[5] = array[startingIndex++];
	        result[6] = array[startingIndex++];
	        result[7] = array[startingIndex++];
	        result[8] = array[startingIndex++];
	        result[9] = array[startingIndex++];
	        result[10] = array[startingIndex++];
	        result[11] = array[startingIndex++];
	        result[12] = array[startingIndex++];
	        result[13] = array[startingIndex++];
	        result[14] = array[startingIndex++];
	        result[15] = array[startingIndex];
	        return result;
	    };

	    /**
	     * Duplicates a Matrix4 instance.
	     *
	     * @param {Matrix4} matrix The matrix to duplicate.
	     * @param {Matrix4} [result] The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)
	     */
	    Matrix4.clone = function(matrix, result) {
	        if (!defined(matrix)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new Matrix4(matrix[0], matrix[4], matrix[8], matrix[12],
	                               matrix[1], matrix[5], matrix[9], matrix[13],
	                               matrix[2], matrix[6], matrix[10], matrix[14],
	                               matrix[3], matrix[7], matrix[11], matrix[15]);
	        }
	        result[0] = matrix[0];
	        result[1] = matrix[1];
	        result[2] = matrix[2];
	        result[3] = matrix[3];
	        result[4] = matrix[4];
	        result[5] = matrix[5];
	        result[6] = matrix[6];
	        result[7] = matrix[7];
	        result[8] = matrix[8];
	        result[9] = matrix[9];
	        result[10] = matrix[10];
	        result[11] = matrix[11];
	        result[12] = matrix[12];
	        result[13] = matrix[13];
	        result[14] = matrix[14];
	        result[15] = matrix[15];
	        return result;
	    };

	    /**
	     * Creates a Matrix4 from 16 consecutive elements in an array.
	     * @function
	     *
	     * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
	     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
	     * @param {Matrix4} [result] The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
	     *
	     * @example
	     * // Create the Matrix4:
	     * // [1.0, 2.0, 3.0, 4.0]
	     * // [1.0, 2.0, 3.0, 4.0]
	     * // [1.0, 2.0, 3.0, 4.0]
	     * // [1.0, 2.0, 3.0, 4.0]
	     *
	     * var v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
	     * var m = Cesium.Matrix4.fromArray(v);
	     *
	     * // Create same Matrix4 with using an offset into an array
	     * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
	     * var m2 = Cesium.Matrix4.fromArray(v2, 2);
	     */
	    Matrix4.fromArray = Matrix4.unpack;

	    /**
	     * Computes a Matrix4 instance from a column-major order array.
	     *
	     * @param {Number[]} values The column-major order array.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     */
	    Matrix4.fromColumnMajorArray = function(values, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(values)) {
	            throw new DeveloperError('values is required');
	        }
	        //>>includeEnd('debug');

	        return Matrix4.clone(values, result);
	    };

	    /**
	     * Computes a Matrix4 instance from a row-major order array.
	     * The resulting matrix will be in column-major order.
	     *
	     * @param {Number[]} values The row-major order array.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     */
	    Matrix4.fromRowMajorArray = function(values, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(values)) {
	            throw new DeveloperError('values is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Matrix4(values[0], values[1], values[2], values[3],
	                               values[4], values[5], values[6], values[7],
	                               values[8], values[9], values[10], values[11],
	                               values[12], values[13], values[14], values[15]);
	        }
	        result[0] = values[0];
	        result[1] = values[4];
	        result[2] = values[8];
	        result[3] = values[12];
	        result[4] = values[1];
	        result[5] = values[5];
	        result[6] = values[9];
	        result[7] = values[13];
	        result[8] = values[2];
	        result[9] = values[6];
	        result[10] = values[10];
	        result[11] = values[14];
	        result[12] = values[3];
	        result[13] = values[7];
	        result[14] = values[11];
	        result[15] = values[15];
	        return result;
	    };

	    /**
	     * Computes a Matrix4 instance from a Matrix3 representing the rotation
	     * and a Cartesian3 representing the translation.
	     *
	     * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.
	     * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     */
	    Matrix4.fromRotationTranslation = function(rotation, translation, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rotation)) {
	            throw new DeveloperError('rotation is required.');
	        }
	        //>>includeEnd('debug');

	        translation = defaultValue(translation, Cartesian3.ZERO);

	        if (!defined(result)) {
	            return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x,
	                               rotation[1], rotation[4], rotation[7], translation.y,
	                               rotation[2], rotation[5], rotation[8], translation.z,
	                                       0.0,         0.0,         0.0,           1.0);
	        }

	        result[0] = rotation[0];
	        result[1] = rotation[1];
	        result[2] = rotation[2];
	        result[3] = 0.0;
	        result[4] = rotation[3];
	        result[5] = rotation[4];
	        result[6] = rotation[5];
	        result[7] = 0.0;
	        result[8] = rotation[6];
	        result[9] = rotation[7];
	        result[10] = rotation[8];
	        result[11] = 0.0;
	        result[12] = translation.x;
	        result[13] = translation.y;
	        result[14] = translation.z;
	        result[15] = 1.0;
	        return result;
	    };

	    /**
	     * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)
	     * representation with the rotation represented as a quaternion.
	     *
	     * @param {Cartesian3} translation The translation transformation.
	     * @param {Quaternion} rotation The rotation transformation.
	     * @param {Cartesian3} scale The non-uniform scale transformation.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     *
	     * @example
	     * var result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(
	     *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation
	     *   Cesium.Quaternion.IDENTITY,           // rotation
	     *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale
	     *   result);
	     */
	    Matrix4.fromTranslationQuaternionRotationScale = function(translation, rotation, scale, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(translation)) {
	            throw new DeveloperError('translation is required.');
	        }
	        if (!defined(rotation)) {
	            throw new DeveloperError('rotation is required.');
	        }
	        if (!defined(scale)) {
	            throw new DeveloperError('scale is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            result = new Matrix4();
	        }

	        var scaleX = scale.x;
	        var scaleY = scale.y;
	        var scaleZ = scale.z;

	        var x2 = rotation.x * rotation.x;
	        var xy = rotation.x * rotation.y;
	        var xz = rotation.x * rotation.z;
	        var xw = rotation.x * rotation.w;
	        var y2 = rotation.y * rotation.y;
	        var yz = rotation.y * rotation.z;
	        var yw = rotation.y * rotation.w;
	        var z2 = rotation.z * rotation.z;
	        var zw = rotation.z * rotation.w;
	        var w2 = rotation.w * rotation.w;

	        var m00 = x2 - y2 - z2 + w2;
	        var m01 = 2.0 * (xy - zw);
	        var m02 = 2.0 * (xz + yw);

	        var m10 = 2.0 * (xy + zw);
	        var m11 = -x2 + y2 - z2 + w2;
	        var m12 = 2.0 * (yz - xw);

	        var m20 = 2.0 * (xz - yw);
	        var m21 = 2.0 * (yz + xw);
	        var m22 = -x2 - y2 + z2 + w2;

	        result[0]  = m00 * scaleX;
	        result[1]  = m10 * scaleX;
	        result[2]  = m20 * scaleX;
	        result[3]  = 0.0;
	        result[4]  = m01 * scaleY;
	        result[5]  = m11 * scaleY;
	        result[6]  = m21 * scaleY;
	        result[7]  = 0.0;
	        result[8]  = m02 * scaleZ;
	        result[9]  = m12 * scaleZ;
	        result[10] = m22 * scaleZ;
	        result[11] = 0.0;
	        result[12] = translation.x;
	        result[13] = translation.y;
	        result[14] = translation.z;
	        result[15] = 1.0;

	        return result;
	    };

	    /**
	     * Creates a Matrix4 instance from a Cartesian3 representing the translation.
	     *
	     * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     *
	     * @see Matrix4.multiplyByTranslation
	     */
	    Matrix4.fromTranslation = function(translation, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(translation)) {
	            throw new DeveloperError('translation is required.');
	        }
	        //>>includeEnd('debug');

	        return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
	    };

	    /**
	     * Computes a Matrix4 instance representing a non-uniform scale.
	     *
	     * @param {Cartesian3} scale The x, y, and z scale factors.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     *
	     * @example
	     * // Creates
	     * //   [7.0, 0.0, 0.0, 0.0]
	     * //   [0.0, 8.0, 0.0, 0.0]
	     * //   [0.0, 0.0, 9.0, 0.0]
	     * //   [0.0, 0.0, 0.0, 1.0]
	     * var m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
	     */
	    Matrix4.fromScale = function(scale, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(scale)) {
	            throw new DeveloperError('scale is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Matrix4(
	                scale.x, 0.0,     0.0,     0.0,
	                0.0,     scale.y, 0.0,     0.0,
	                0.0,     0.0,     scale.z, 0.0,
	                0.0,     0.0,     0.0,     1.0);
	        }

	        result[0] = scale.x;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = 0.0;
	        result[5] = scale.y;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = 0.0;
	        result[9] = 0.0;
	        result[10] = scale.z;
	        result[11] = 0.0;
	        result[12] = 0.0;
	        result[13] = 0.0;
	        result[14] = 0.0;
	        result[15] = 1.0;
	        return result;
	    };

	    /**
	     * Computes a Matrix4 instance representing a uniform scale.
	     *
	     * @param {Number} scale The uniform scale factor.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     *
	     * @example
	     * // Creates
	     * //   [2.0, 0.0, 0.0, 0.0]
	     * //   [0.0, 2.0, 0.0, 0.0]
	     * //   [0.0, 0.0, 2.0, 0.0]
	     * //   [0.0, 0.0, 0.0, 1.0]
	     * var m = Cesium.Matrix4.fromUniformScale(2.0);
	     */
	    Matrix4.fromUniformScale = function(scale, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof scale !== 'number') {
	            throw new DeveloperError('scale is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Matrix4(scale, 0.0,   0.0,   0.0,
	                               0.0,   scale, 0.0,   0.0,
	                               0.0,   0.0,   scale, 0.0,
	                               0.0,   0.0,   0.0,   1.0);
	        }

	        result[0] = scale;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = 0.0;
	        result[5] = scale;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = 0.0;
	        result[9] = 0.0;
	        result[10] = scale;
	        result[11] = 0.0;
	        result[12] = 0.0;
	        result[13] = 0.0;
	        result[14] = 0.0;
	        result[15] = 1.0;
	        return result;
	    };

	    var fromCameraF = new Cartesian3();
	    var fromCameraS = new Cartesian3();
	    var fromCameraU = new Cartesian3();

	    /**
	     * Computes a Matrix4 instance from a Camera.
	     *
	     * @param {Camera} camera The camera to use.
	     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
	     */
	    Matrix4.fromCamera = function(camera, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(camera)) {
	            throw new DeveloperError('camera is required.');
	        }
	        //>>includeEnd('debug');

	        var eye = camera.eye;
	        var target = camera.target;
	        var up = camera.up;

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(eye)) {
	            throw new DeveloperError('camera.eye is required.');
	        }
	        if (!defined(target)) {
	            throw new DeveloperError('camera.target is required.');
	        }
	        if (!defined(up)) {
	            throw new DeveloperError('camera.up is required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian3.normalize(Cartesian3.subtract(target, eye, fromCameraF), fromCameraF);
	        Cartesian3.normalize(Cartesian3.cross(fromCameraF, up, fromCameraS), fromCameraS);
	        Cartesian3.normalize(Cartesian3.cross(fromCameraS, fromCameraF, fromCameraU), fromCameraU);

	        var sX = fromCameraS.x;
	        var sY = fromCameraS.y;
	        var sZ = fromCameraS.z;
	        var fX = fromCameraF.x;
	        var fY = fromCameraF.y;
	        var fZ = fromCameraF.z;
	        var uX = fromCameraU.x;
	        var uY = fromCameraU.y;
	        var uZ = fromCameraU.z;
	        var eyeX = eye.x;
	        var eyeY = eye.y;
	        var eyeZ = eye.z;
	        var t0 = sX * -eyeX + sY * -eyeY+ sZ * -eyeZ;
	        var t1 = uX * -eyeX + uY * -eyeY+ uZ * -eyeZ;
	        var t2 = fX * eyeX + fY * eyeY + fZ * eyeZ;

	        //The code below this comment is an optimized
	        //version of the commented lines.
	        //Rather that create two matrices and then multiply,
	        //we just bake in the multiplcation as part of creation.
	        //var rotation = new Matrix4(
	        //                sX,  sY,  sZ, 0.0,
	        //                uX,  uY,  uZ, 0.0,
	        //               -fX, -fY, -fZ, 0.0,
	        //                0.0,  0.0,  0.0, 1.0);
	        //var translation = new Matrix4(
	        //                1.0, 0.0, 0.0, -eye.x,
	        //                0.0, 1.0, 0.0, -eye.y,
	        //                0.0, 0.0, 1.0, -eye.z,
	        //                0.0, 0.0, 0.0, 1.0);
	        //return rotation.multiply(translation);
	        if (!defined(result)) {
	            return new Matrix4(
	                    sX,   sY,  sZ, t0,
	                    uX,   uY,  uZ, t1,
	                   -fX,  -fY, -fZ, t2,
	                    0.0, 0.0, 0.0, 1.0);
	        }
	        result[0] = sX;
	        result[1] = uX;
	        result[2] = -fX;
	        result[3] = 0.0;
	        result[4] = sY;
	        result[5] = uY;
	        result[6] = -fY;
	        result[7] = 0.0;
	        result[8] = sZ;
	        result[9] = uZ;
	        result[10] = -fZ;
	        result[11] = 0.0;
	        result[12] = t0;
	        result[13] = t1;
	        result[14] = t2;
	        result[15] = 1.0;
	        return result;

	    };

	     /**
	      * Computes a Matrix4 instance representing a perspective transformation matrix.
	      *
	      * @param {Number} fovY The field of view along the Y axis in radians.
	      * @param {Number} aspectRatio The aspect ratio.
	      * @param {Number} near The distance to the near plane in meters.
	      * @param {Number} far The distance to the far plane in meters.
	      * @param {Matrix4} result The object in which the result will be stored.
	      * @returns The modified result parameter.
	      *
	      * @exception {DeveloperError} fovY must be in [0, PI).
	      * @exception {DeveloperError} aspectRatio must be greater than zero.
	      * @exception {DeveloperError} near must be greater than zero.
	      * @exception {DeveloperError} far must be greater than zero.
	      */
	    Matrix4.computePerspectiveFieldOfView = function(fovY, aspectRatio, near, far, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (fovY <= 0.0 || fovY > Math.PI) {
	            throw new DeveloperError('fovY must be in [0, PI).');
	        }
	        if (aspectRatio <= 0.0) {
	            throw new DeveloperError('aspectRatio must be greater than zero.');
	        }
	        if (near <= 0.0) {
	            throw new DeveloperError('near must be greater than zero.');
	        }
	        if (far <= 0.0) {
	            throw new DeveloperError('far must be greater than zero.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var bottom = Math.tan(fovY * 0.5);

	        var column1Row1 = 1.0 / bottom;
	        var column0Row0 = column1Row1 / aspectRatio;
	        var column2Row2 = (far + near) / (near - far);
	        var column3Row2 = (2.0 * far * near) / (near - far);

	        result[0] = column0Row0;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = 0.0;
	        result[5] = column1Row1;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = 0.0;
	        result[9] = 0.0;
	        result[10] = column2Row2;
	        result[11] = -1.0;
	        result[12] = 0.0;
	        result[13] = 0.0;
	        result[14] = column3Row2;
	        result[15] = 0.0;
	        return result;
	    };

	    /**
	    * Computes a Matrix4 instance representing an orthographic transformation matrix.
	    *
	    * @param {Number} left The number of meters to the left of the camera that will be in view.
	    * @param {Number} right The number of meters to the right of the camera that will be in view.
	    * @param {Number} bottom The number of meters below of the camera that will be in view.
	    * @param {Number} top The number of meters above of the camera that will be in view.
	    * @param {Number} near The distance to the near plane in meters.
	    * @param {Number} far The distance to the far plane in meters.
	    * @param {Matrix4} result The object in which the result will be stored.
	    * @returns The modified result parameter.
	    */
	    Matrix4.computeOrthographicOffCenter = function(left, right, bottom, top, near, far, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required.');
	        }
	        if (!defined(bottom)) {
	            throw new DeveloperError('bottom is required.');
	        }
	        if (!defined(top)) {
	            throw new DeveloperError('top is required.');
	        }
	        if (!defined(near)) {
	            throw new DeveloperError('near is required.');
	        }
	        if (!defined(far)) {
	            throw new DeveloperError('far is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var a = 1.0 / (right - left);
	        var b = 1.0 / (top - bottom);
	        var c = 1.0 / (far - near);

	        var tx = -(right + left) * a;
	        var ty = -(top + bottom) * b;
	        var tz = -(far + near) * c;
	        a *= 2.0;
	        b *= 2.0;
	        c *= -2.0;

	        result[0] = a;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = 0.0;
	        result[5] = b;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = 0.0;
	        result[9] = 0.0;
	        result[10] = c;
	        result[11] = 0.0;
	        result[12] = tx;
	        result[13] = ty;
	        result[14] = tz;
	        result[15] = 1.0;
	        return result;
	    };

	    /**
	     * Computes a Matrix4 instance representing an off center perspective transformation.
	     *
	     * @param {Number} left The number of meters to the left of the camera that will be in view.
	     * @param {Number} right The number of meters to the right of the camera that will be in view.
	     * @param {Number} bottom The number of meters below of the camera that will be in view.
	     * @param {Number} top The number of meters above of the camera that will be in view.
	     * @param {Number} near The distance to the near plane in meters.
	     * @param {Number} far The distance to the far plane in meters.
	     * @param {Matrix4} result The object in which the result will be stored.
	     * @returns The modified result parameter.
	     */
	    Matrix4.computePerspectiveOffCenter = function(left, right, bottom, top, near, far, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required.');
	        }
	        if (!defined(bottom)) {
	            throw new DeveloperError('bottom is required.');
	        }
	        if (!defined(top)) {
	            throw new DeveloperError('top is required.');
	        }
	        if (!defined(near)) {
	            throw new DeveloperError('near is required.');
	        }
	        if (!defined(far)) {
	            throw new DeveloperError('far is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var column0Row0 = 2.0 * near / (right - left);
	        var column1Row1 = 2.0 * near / (top - bottom);
	        var column2Row0 = (right + left) / (right - left);
	        var column2Row1 = (top + bottom) / (top - bottom);
	        var column2Row2 = -(far + near) / (far - near);
	        var column2Row3 = -1.0;
	        var column3Row2 = -2.0 * far * near / (far - near);

	        result[0] = column0Row0;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = 0.0;
	        result[5] = column1Row1;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = column2Row0;
	        result[9] = column2Row1;
	        result[10] = column2Row2;
	        result[11] = column2Row3;
	        result[12] = 0.0;
	        result[13] = 0.0;
	        result[14] = column3Row2;
	        result[15] = 0.0;
	        return result;
	    };

	    /**
	     * Computes a Matrix4 instance representing an infinite off center perspective transformation.
	     *
	     * @param {Number} left The number of meters to the left of the camera that will be in view.
	     * @param {Number} right The number of meters to the right of the camera that will be in view.
	     * @param {Number} bottom The number of meters below of the camera that will be in view.
	     * @param {Number} top The number of meters above of the camera that will be in view.
	     * @param {Number} near The distance to the near plane in meters.
	     * @param {Number} far The distance to the far plane in meters.
	     * @param {Matrix4} result The object in which the result will be stored.
	     * @returns The modified result parameter.
	     */
	    Matrix4.computeInfinitePerspectiveOffCenter = function(left, right, bottom, top, near, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required.');
	        }
	        if (!defined(bottom)) {
	            throw new DeveloperError('bottom is required.');
	        }
	        if (!defined(top)) {
	            throw new DeveloperError('top is required.');
	        }
	        if (!defined(near)) {
	            throw new DeveloperError('near is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var column0Row0 = 2.0 * near / (right - left);
	        var column1Row1 = 2.0 * near / (top - bottom);
	        var column2Row0 = (right + left) / (right - left);
	        var column2Row1 = (top + bottom) / (top - bottom);
	        var column2Row2 = -1.0;
	        var column2Row3 = -1.0;
	        var column3Row2 = -2.0 * near;

	        result[0] = column0Row0;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = 0.0;
	        result[5] = column1Row1;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = column2Row0;
	        result[9] = column2Row1;
	        result[10] = column2Row2;
	        result[11] = column2Row3;
	        result[12] = 0.0;
	        result[13] = 0.0;
	        result[14] = column3Row2;
	        result[15] = 0.0;
	        return result;
	    };

	    /**
	     * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
	     *
	     * @param {Object}[viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.
	     * @param {Number}[nearDepthRange=0.0] The near plane distance in window coordinates.
	     * @param {Number}[farDepthRange=1.0] The far plane distance in window coordinates.
	     * @param {Matrix4} result The object in which the result will be stored.
	     * @returns The modified result parameter.
	     *
	     * @example
	     * // Create viewport transformation using an explicit viewport and depth range.
	     * var m = Cesium.Matrix4.computeViewportTransformation({
	     *     x : 0.0,
	     *     y : 0.0,
	     *     width : 1024.0,
	     *     height : 768.0
	     * }, 0.0, 1.0, new Cesium.Matrix4());
	     */
	    Matrix4.computeViewportTransformation = function(viewport, nearDepthRange, farDepthRange, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);
	        var x = defaultValue(viewport.x, 0.0);
	        var y = defaultValue(viewport.y, 0.0);
	        var width = defaultValue(viewport.width, 0.0);
	        var height = defaultValue(viewport.height, 0.0);
	        nearDepthRange = defaultValue(nearDepthRange, 0.0);
	        farDepthRange = defaultValue(farDepthRange, 1.0);

	        var halfWidth = width * 0.5;
	        var halfHeight = height * 0.5;
	        var halfDepth = (farDepthRange - nearDepthRange) * 0.5;

	        var column0Row0 = halfWidth;
	        var column1Row1 = halfHeight;
	        var column2Row2 = halfDepth;
	        var column3Row0 = x + halfWidth;
	        var column3Row1 = y + halfHeight;
	        var column3Row2 = nearDepthRange + halfDepth;
	        var column3Row3 = 1.0;

	        result[0] = column0Row0;
	        result[1] = 0.0;
	        result[2] = 0.0;
	        result[3] = 0.0;
	        result[4] = 0.0;
	        result[5] = column1Row1;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = 0.0;
	        result[9] = 0.0;
	        result[10] = column2Row2;
	        result[11] = 0.0;
	        result[12] = column3Row0;
	        result[13] = column3Row1;
	        result[14] = column3Row2;
	        result[15] = column3Row3;
	        return result;
	    };

	    /**
	     * Computes an Array from the provided Matrix4 instance.
	     * The array will be in column-major order.
	     *
	     * @param {Matrix4} matrix The matrix to use..
	     * @param {Number[]} [result] The Array onto which to store the result.
	     * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.
	     *
	     * @example
	     * //create an array from an instance of Matrix4
	     * // m = [10.0, 14.0, 18.0, 22.0]
	     * //     [11.0, 15.0, 19.0, 23.0]
	     * //     [12.0, 16.0, 20.0, 24.0]
	     * //     [13.0, 17.0, 21.0, 25.0]
	     * var a = Cesium.Matrix4.toArray(m);
	     *
	     * // m remains the same
	     * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]
	     */
	    Matrix4.toArray = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return [matrix[0], matrix[1], matrix[2], matrix[3],
	                    matrix[4], matrix[5], matrix[6], matrix[7],
	                    matrix[8], matrix[9], matrix[10], matrix[11],
	                    matrix[12], matrix[13], matrix[14], matrix[15]];
	        }
	        result[0] = matrix[0];
	        result[1] = matrix[1];
	        result[2] = matrix[2];
	        result[3] = matrix[3];
	        result[4] = matrix[4];
	        result[5] = matrix[5];
	        result[6] = matrix[6];
	        result[7] = matrix[7];
	        result[8] = matrix[8];
	        result[9] = matrix[9];
	        result[10] = matrix[10];
	        result[11] = matrix[11];
	        result[12] = matrix[12];
	        result[13] = matrix[13];
	        result[14] = matrix[14];
	        result[15] = matrix[15];
	        return result;
	    };

	    /**
	     * Computes the array index of the element at the provided row and column.
	     *
	     * @param {Number} row The zero-based index of the row.
	     * @param {Number} column The zero-based index of the column.
	     * @returns {Number} The index of the element at the provided row and column.
	     *
	     * @exception {DeveloperError} row must be 0, 1, 2, or 3.
	     * @exception {DeveloperError} column must be 0, 1, 2, or 3.
	     *
	     * @example
	     * var myMatrix = new Cesium.Matrix4();
	     * var column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);
	     * var column1Row0 = myMatrix[column1Row0Index];
	     * myMatrix[column1Row0Index] = 10.0;
	     */
	    Matrix4.getElementIndex = function(column, row) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof row !== 'number' || row < 0 || row > 3) {
	            throw new DeveloperError('row must be 0, 1, 2, or 3.');
	        }
	        if (typeof column !== 'number' || column < 0 || column > 3) {
	            throw new DeveloperError('column must be 0, 1, 2, or 3.');
	        }
	        //>>includeEnd('debug');

	        return column * 4 + row;
	    };

	    /**
	     * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
	     *
	     * @param {Matrix4} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the column to retrieve.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	     *
	     * @example
	     * //returns a Cartesian4 instance with values from the specified column
	     * // m = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [18.0, 19.0, 20.0, 21.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     *
	     * //Example 1: Creates an instance of Cartesian
	     * var a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());
	     *
	     * @example
	     * //Example 2: Sets values for Cartesian instance
	     * var a = new Cesium.Cartesian4();
	     * Cesium.Matrix4.getColumn(m, 2, a);
	     *
	     * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;
	     */
	    Matrix4.getColumn = function(matrix, index, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }

	        if (typeof index !== 'number' || index < 0 || index > 3) {
	            throw new DeveloperError('index must be 0, 1, 2, or 3.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var startIndex = index * 4;
	        var x = matrix[startIndex];
	        var y = matrix[startIndex + 1];
	        var z = matrix[startIndex + 2];
	        var w = matrix[startIndex + 3];

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    /**
	     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
	     *
	     * @param {Matrix4} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the column to set.
	     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	     *
	     * @example
	     * //creates a new Matrix4 instance with new column values from the Cartesian4 instance
	     * // m = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [18.0, 19.0, 20.0, 21.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     *
	     * var a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
	     *
	     * // m remains the same
	     * // a = [10.0, 11.0, 99.0, 13.0]
	     * //     [14.0, 15.0, 98.0, 17.0]
	     * //     [18.0, 19.0, 97.0, 21.0]
	     * //     [22.0, 23.0, 96.0, 25.0]
	     */
	    Matrix4.setColumn = function(matrix, index, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof index !== 'number' || index < 0 || index > 3) {
	            throw new DeveloperError('index must be 0, 1, 2, or 3.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result = Matrix4.clone(matrix, result);
	        var startIndex = index * 4;
	        result[startIndex] = cartesian.x;
	        result[startIndex + 1] = cartesian.y;
	        result[startIndex + 2] = cartesian.z;
	        result[startIndex + 3] = cartesian.w;
	        return result;
	    };

	    /**
	     * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
	     *
	     * @param {Matrix4} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the row to retrieve.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	     *
	     * @example
	     * //returns a Cartesian4 instance with values from the specified column
	     * // m = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [18.0, 19.0, 20.0, 21.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     *
	     * //Example 1: Returns an instance of Cartesian
	     * var a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());
	     *
	     * @example
	     * //Example 2: Sets values for a Cartesian instance
	     * var a = new Cesium.Cartesian4();
	     * Cesium.Matrix4.getRow(m, 2, a);
	     *
	     * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;
	     */
	    Matrix4.getRow = function(matrix, index, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }

	        if (typeof index !== 'number' || index < 0 || index > 3) {
	            throw new DeveloperError('index must be 0, 1, 2, or 3.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var x = matrix[index];
	        var y = matrix[index + 4];
	        var z = matrix[index + 8];
	        var w = matrix[index + 12];

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    /**
	     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
	     *
	     * @param {Matrix4} matrix The matrix to use.
	     * @param {Number} index The zero-based index of the row to set.
	     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @exception {DeveloperError} index must be 0, 1, 2, or 3.
	     *
	     * @example
	     * //create a new Matrix4 instance with new row values from the Cartesian4 instance
	     * // m = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [18.0, 19.0, 20.0, 21.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     *
	     * var a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
	     *
	     * // m remains the same
	     * // a = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [99.0, 98.0, 97.0, 96.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     */
	    Matrix4.setRow = function(matrix, index, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof index !== 'number' || index < 0 || index > 3) {
	            throw new DeveloperError('index must be 0, 1, 2, or 3.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result = Matrix4.clone(matrix, result);
	        result[index] = cartesian.x;
	        result[index + 4] = cartesian.y;
	        result[index + 8] = cartesian.z;
	        result[index + 12] = cartesian.w;
	        return result;
	    };

	    var scratchColumn = new Cartesian3();

	    /**
	     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
	     *
	     * @param {Matrix4} matrix The matrix.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter
	     */
	    Matrix4.getScale = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
	        result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn));
	        result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn));
	        return result;
	    };

	    var scratchScale = new Cartesian3();

	    /**
	     * Computes the maximum scale assuming the matrix is an affine transformation.
	     * The maximum scale is the maximum length of the column vectors in the upper-left
	     * 3x3 matrix.
	     *
	     * @param {Matrix4} matrix The matrix.
	     * @returns {Number} The maximum scale.
	     */
	    Matrix4.getMaximumScale = function(matrix) {
	        Matrix4.getScale(matrix, scratchScale);
	        return Cartesian3.maximumComponent(scratchScale);
	    };

	    /**
	     * Computes the product of two matrices.
	     *
	     * @param {Matrix4} left The first matrix.
	     * @param {Matrix4} right The second matrix.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     */
	    Matrix4.multiply = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var left0 = left[0];
	        var left1 = left[1];
	        var left2 = left[2];
	        var left3 = left[3];
	        var left4 = left[4];
	        var left5 = left[5];
	        var left6 = left[6];
	        var left7 = left[7];
	        var left8 = left[8];
	        var left9 = left[9];
	        var left10 = left[10];
	        var left11 = left[11];
	        var left12 = left[12];
	        var left13 = left[13];
	        var left14 = left[14];
	        var left15 = left[15];

	        var right0 = right[0];
	        var right1 = right[1];
	        var right2 = right[2];
	        var right3 = right[3];
	        var right4 = right[4];
	        var right5 = right[5];
	        var right6 = right[6];
	        var right7 = right[7];
	        var right8 = right[8];
	        var right9 = right[9];
	        var right10 = right[10];
	        var right11 = right[11];
	        var right12 = right[12];
	        var right13 = right[13];
	        var right14 = right[14];
	        var right15 = right[15];

	        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
	        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
	        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
	        var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;

	        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
	        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
	        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
	        var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;

	        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
	        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
	        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
	        var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;

	        var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
	        var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
	        var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
	        var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;

	        result[0] = column0Row0;
	        result[1] = column0Row1;
	        result[2] = column0Row2;
	        result[3] = column0Row3;
	        result[4] = column1Row0;
	        result[5] = column1Row1;
	        result[6] = column1Row2;
	        result[7] = column1Row3;
	        result[8] = column2Row0;
	        result[9] = column2Row1;
	        result[10] = column2Row2;
	        result[11] = column2Row3;
	        result[12] = column3Row0;
	        result[13] = column3Row1;
	        result[14] = column3Row2;
	        result[15] = column3Row3;
	        return result;
	    };

	    /**
	     * Computes the sum of two matrices.
	     *
	     * @param {Matrix4} left The first matrix.
	     * @param {Matrix4} right The second matrix.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     */
	    Matrix4.add = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = left[0] + right[0];
	        result[1] = left[1] + right[1];
	        result[2] = left[2] + right[2];
	        result[3] = left[3] + right[3];
	        result[4] = left[4] + right[4];
	        result[5] = left[5] + right[5];
	        result[6] = left[6] + right[6];
	        result[7] = left[7] + right[7];
	        result[8] = left[8] + right[8];
	        result[9] = left[9] + right[9];
	        result[10] = left[10] + right[10];
	        result[11] = left[11] + right[11];
	        result[12] = left[12] + right[12];
	        result[13] = left[13] + right[13];
	        result[14] = left[14] + right[14];
	        result[15] = left[15] + right[15];
	        return result;
	    };

	    /**
	     * Computes the difference of two matrices.
	     *
	     * @param {Matrix4} left The first matrix.
	     * @param {Matrix4} right The second matrix.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     */
	    Matrix4.subtract = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = left[0] - right[0];
	        result[1] = left[1] - right[1];
	        result[2] = left[2] - right[2];
	        result[3] = left[3] - right[3];
	        result[4] = left[4] - right[4];
	        result[5] = left[5] - right[5];
	        result[6] = left[6] - right[6];
	        result[7] = left[7] - right[7];
	        result[8] = left[8] - right[8];
	        result[9] = left[9] - right[9];
	        result[10] = left[10] - right[10];
	        result[11] = left[11] - right[11];
	        result[12] = left[12] - right[12];
	        result[13] = left[13] - right[13];
	        result[14] = left[14] - right[14];
	        result[15] = left[15] - right[15];
	        return result;
	    };

	    /**
	     * Computes the product of two matrices assuming the matrices are
	     * affine transformation matrices, where the upper left 3x3 elements
	     * are a rotation matrix, and the upper three elements in the fourth
	     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
	     * The matrix is not verified to be in the proper form.
	     * This method is faster than computing the product for general 4x4
	     * matrices using {@link Matrix4.multiply}.
	     *
	     * @param {Matrix4} left The first matrix.
	     * @param {Matrix4} right The second matrix.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @example
	     * var m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);
	     * var m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));
	     * var m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());
	     */
	    Matrix4.multiplyTransformation = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var left0 = left[0];
	        var left1 = left[1];
	        var left2 = left[2];
	        var left4 = left[4];
	        var left5 = left[5];
	        var left6 = left[6];
	        var left8 = left[8];
	        var left9 = left[9];
	        var left10 = left[10];
	        var left12 = left[12];
	        var left13 = left[13];
	        var left14 = left[14];

	        var right0 = right[0];
	        var right1 = right[1];
	        var right2 = right[2];
	        var right4 = right[4];
	        var right5 = right[5];
	        var right6 = right[6];
	        var right8 = right[8];
	        var right9 = right[9];
	        var right10 = right[10];
	        var right12 = right[12];
	        var right13 = right[13];
	        var right14 = right[14];

	        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
	        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
	        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;

	        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
	        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
	        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;

	        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
	        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
	        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;

	        var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;
	        var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;
	        var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;

	        result[0] = column0Row0;
	        result[1] = column0Row1;
	        result[2] = column0Row2;
	        result[3] = 0.0;
	        result[4] = column1Row0;
	        result[5] = column1Row1;
	        result[6] = column1Row2;
	        result[7] = 0.0;
	        result[8] = column2Row0;
	        result[9] = column2Row1;
	        result[10] = column2Row2;
	        result[11] = 0.0;
	        result[12] = column3Row0;
	        result[13] = column3Row1;
	        result[14] = column3Row2;
	        result[15] = 1.0;
	        return result;
	    };

	    /**
	     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
	     * by a 3x3 rotation matrix.  This is an optimization
	     * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.
	     *
	     * @param {Matrix4} matrix The matrix on the left-hand side.
	     * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @example
	     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);
	     * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);
	     */
	    Matrix4.multiplyByMatrix3 = function(matrix, rotation, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(rotation)) {
	            throw new DeveloperError('rotation is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var left0 = matrix[0];
	        var left1 = matrix[1];
	        var left2 = matrix[2];
	        var left4 = matrix[4];
	        var left5 = matrix[5];
	        var left6 = matrix[6];
	        var left8 = matrix[8];
	        var left9 = matrix[9];
	        var left10 = matrix[10];

	        var right0 = rotation[0];
	        var right1 = rotation[1];
	        var right2 = rotation[2];
	        var right4 = rotation[3];
	        var right5 = rotation[4];
	        var right6 = rotation[5];
	        var right8 = rotation[6];
	        var right9 = rotation[7];
	        var right10 = rotation[8];

	        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
	        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
	        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;

	        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
	        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
	        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;

	        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
	        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
	        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;

	        result[0] = column0Row0;
	        result[1] = column0Row1;
	        result[2] = column0Row2;
	        result[3] = 0.0;
	        result[4] = column1Row0;
	        result[5] = column1Row1;
	        result[6] = column1Row2;
	        result[7] = 0.0;
	        result[8] = column2Row0;
	        result[9] = column2Row1;
	        result[10] = column2Row2;
	        result[11] = 0.0;
	        result[12] = matrix[12];
	        result[13] = matrix[13];
	        result[14] = matrix[14];
	        result[15] = matrix[15];
	        return result;
	    };

	    /**
	     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
	     * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
	     * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
	     *
	     * @param {Matrix4} matrix The matrix on the left-hand side.
	     * @param {Cartesian3} translation The translation on the right-hand side.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @example
	     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);
	     * Cesium.Matrix4.multiplyByTranslation(m, position, m);
	     */
	    Matrix4.multiplyByTranslation = function(matrix, translation, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(translation)) {
	            throw new DeveloperError('translation is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var x = translation.x;
	        var y = translation.y;
	        var z = translation.z;

	        var tx = (x * matrix[0]) + (y * matrix[4]) + (z * matrix[8]) + matrix[12];
	        var ty = (x * matrix[1]) + (y * matrix[5]) + (z * matrix[9]) + matrix[13];
	        var tz = (x * matrix[2]) + (y * matrix[6]) + (z * matrix[10]) + matrix[14];

	        result[0] = matrix[0];
	        result[1] = matrix[1];
	        result[2] = matrix[2];
	        result[3] = matrix[3];
	        result[4] = matrix[4];
	        result[5] = matrix[5];
	        result[6] = matrix[6];
	        result[7] = matrix[7];
	        result[8] = matrix[8];
	        result[9] = matrix[9];
	        result[10] = matrix[10];
	        result[11] = matrix[11];
	        result[12] = tx;
	        result[13] = ty;
	        result[14] = tz;
	        result[15] = matrix[15];
	        return result;
	    };

	    var uniformScaleScratch = new Cartesian3();

	    /**
	     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
	     * by an implicit uniform scale matrix.  This is an optimization
	     * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code> with less allocations and arithmetic operations.
	     *
	     * @param {Matrix4} matrix The matrix on the left-hand side.
	     * @param {Number} scale The uniform scale on the right-hand side.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @see Matrix4.fromUniformScale
	     * @see Matrix4.multiplyByScale
	     *
	     * @example
	     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);
	     * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);
	     */
	    Matrix4.multiplyByUniformScale = function(matrix, scale, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (typeof scale !== 'number') {
	            throw new DeveloperError('scale is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        uniformScaleScratch.x = scale;
	        uniformScaleScratch.y = scale;
	        uniformScaleScratch.z = scale;
	        return Matrix4.multiplyByScale(matrix, uniformScaleScratch, result);
	    };

	    /**
	     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
	     * by an implicit non-uniform scale matrix.  This is an optimization
	     * for <code>Matrix4.multiply(m, Matrix4.fromScale(scale), m);</code> with less allocations and arithmetic operations.
	     *
	     * @param {Matrix4} matrix The matrix on the left-hand side.
	     * @param {Cartesian3} scale The non-uniform scale on the right-hand side.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @see Matrix4.fromScale
	     * @see Matrix4.multiplyByUniformScale
	     *
	     * @example
	     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);
	     * Cesium.Matrix4.multiplyByScale(m, scale, m);
	     */
	    Matrix4.multiplyByScale = function(matrix, scale, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(scale)) {
	            throw new DeveloperError('scale is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var scaleX = scale.x;
	        var scaleY = scale.y;
	        var scaleZ = scale.z;

	        // Faster than Cartesian3.equals
	        if ((scaleX === 1.0) && (scaleY === 1.0) && (scaleZ === 1.0)) {
	            return Matrix4.clone(matrix, result);
	        }

	        result[0] = scaleX * matrix[0];
	        result[1] = scaleX * matrix[1];
	        result[2] = scaleX * matrix[2];
	        result[3] = 0.0;
	        result[4] = scaleY * matrix[4];
	        result[5] = scaleY * matrix[5];
	        result[6] = scaleY * matrix[6];
	        result[7] = 0.0;
	        result[8] = scaleZ * matrix[8];
	        result[9] = scaleZ * matrix[9];
	        result[10] = scaleZ * matrix[10];
	        result[11] = 0.0;
	        result[12] = matrix[12];
	        result[13] = matrix[13];
	        result[14] = matrix[14];
	        result[15] = 1.0;
	        return result;
	    };

	    /**
	     * Computes the product of a matrix and a column vector.
	     *
	     * @param {Matrix4} matrix The matrix.
	     * @param {Cartesian4} cartesian The vector.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Matrix4.multiplyByVector = function(matrix, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var vX = cartesian.x;
	        var vY = cartesian.y;
	        var vZ = cartesian.z;
	        var vW = cartesian.w;

	        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
	        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
	        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
	        var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    /**
	     * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
	     * with a {@link Cartesian4} with a <code>w</code> component of zero.
	     *
	     * @param {Matrix4} matrix The matrix.
	     * @param {Cartesian3} cartesian The point.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     *
	     * @example
	     * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
	     * var result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());
	     * // A shortcut for
	     * //   Cartesian3 p = ...
	     * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);
	     */
	    Matrix4.multiplyByPointAsVector = function(matrix, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var vX = cartesian.x;
	        var vY = cartesian.y;
	        var vZ = cartesian.z;

	        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
	        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
	        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}
	     * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.
	     *
	     * @param {Matrix4} matrix The matrix.
	     * @param {Cartesian3} cartesian The point.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     *
	     * @example
	     * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
	     * var result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());
	     */
	    Matrix4.multiplyByPoint = function(matrix, cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }

	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var vX = cartesian.x;
	        var vY = cartesian.y;
	        var vZ = cartesian.z;

	        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
	        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
	        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Computes the product of a matrix and a scalar.
	     *
	     * @param {Matrix4} matrix The matrix.
	     * @param {Number} scalar The number to multiply by.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @example
	     * //create a Matrix4 instance which is a scaled version of the supplied Matrix4
	     * // m = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [18.0, 19.0, 20.0, 21.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     *
	     * var a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());
	     *
	     * // m remains the same
	     * // a = [-20.0, -22.0, -24.0, -26.0]
	     * //     [-28.0, -30.0, -32.0, -34.0]
	     * //     [-36.0, -38.0, -40.0, -42.0]
	     * //     [-44.0, -46.0, -48.0, -50.0]
	     */
	    Matrix4.multiplyByScalar = function(matrix, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar must be a number');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = matrix[0] * scalar;
	        result[1] = matrix[1] * scalar;
	        result[2] = matrix[2] * scalar;
	        result[3] = matrix[3] * scalar;
	        result[4] = matrix[4] * scalar;
	        result[5] = matrix[5] * scalar;
	        result[6] = matrix[6] * scalar;
	        result[7] = matrix[7] * scalar;
	        result[8] = matrix[8] * scalar;
	        result[9] = matrix[9] * scalar;
	        result[10] = matrix[10] * scalar;
	        result[11] = matrix[11] * scalar;
	        result[12] = matrix[12] * scalar;
	        result[13] = matrix[13] * scalar;
	        result[14] = matrix[14] * scalar;
	        result[15] = matrix[15] * scalar;
	        return result;
	    };

	    /**
	     * Computes a negated copy of the provided matrix.
	     *
	     * @param {Matrix4} matrix The matrix to negate.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @example
	     * //create a new Matrix4 instance which is a negation of a Matrix4
	     * // m = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [18.0, 19.0, 20.0, 21.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     *
	     * var a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());
	     *
	     * // m remains the same
	     * // a = [-10.0, -11.0, -12.0, -13.0]
	     * //     [-14.0, -15.0, -16.0, -17.0]
	     * //     [-18.0, -19.0, -20.0, -21.0]
	     * //     [-22.0, -23.0, -24.0, -25.0]
	     */
	    Matrix4.negate = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = -matrix[0];
	        result[1] = -matrix[1];
	        result[2] = -matrix[2];
	        result[3] = -matrix[3];
	        result[4] = -matrix[4];
	        result[5] = -matrix[5];
	        result[6] = -matrix[6];
	        result[7] = -matrix[7];
	        result[8] = -matrix[8];
	        result[9] = -matrix[9];
	        result[10] = -matrix[10];
	        result[11] = -matrix[11];
	        result[12] = -matrix[12];
	        result[13] = -matrix[13];
	        result[14] = -matrix[14];
	        result[15] = -matrix[15];
	        return result;
	    };

	    /**
	     * Computes the transpose of the provided matrix.
	     *
	     * @param {Matrix4} matrix The matrix to transpose.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     *
	     * @example
	     * //returns transpose of a Matrix4
	     * // m = [10.0, 11.0, 12.0, 13.0]
	     * //     [14.0, 15.0, 16.0, 17.0]
	     * //     [18.0, 19.0, 20.0, 21.0]
	     * //     [22.0, 23.0, 24.0, 25.0]
	     *
	     * var a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());
	     *
	     * // m remains the same
	     * // a = [10.0, 14.0, 18.0, 22.0]
	     * //     [11.0, 15.0, 19.0, 23.0]
	     * //     [12.0, 16.0, 20.0, 24.0]
	     * //     [13.0, 17.0, 21.0, 25.0]
	     */
	    Matrix4.transpose = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        var matrix1 = matrix[1];
	        var matrix2 = matrix[2];
	        var matrix3 = matrix[3];
	        var matrix6 = matrix[6];
	        var matrix7 = matrix[7];
	        var matrix11 = matrix[11];

	        result[0] = matrix[0];
	        result[1] = matrix[4];
	        result[2] = matrix[8];
	        result[3] = matrix[12];
	        result[4] = matrix1;
	        result[5] = matrix[5];
	        result[6] = matrix[9];
	        result[7] = matrix[13];
	        result[8] = matrix2;
	        result[9] = matrix6;
	        result[10] = matrix[10];
	        result[11] = matrix[14];
	        result[12] = matrix3;
	        result[13] = matrix7;
	        result[14] = matrix11;
	        result[15] = matrix[15];
	        return result;
	    };

	    /**
	     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
	     *
	     * @param {Matrix4} matrix The matrix with signed elements.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     */
	    Matrix4.abs = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = Math.abs(matrix[0]);
	        result[1] = Math.abs(matrix[1]);
	        result[2] = Math.abs(matrix[2]);
	        result[3] = Math.abs(matrix[3]);
	        result[4] = Math.abs(matrix[4]);
	        result[5] = Math.abs(matrix[5]);
	        result[6] = Math.abs(matrix[6]);
	        result[7] = Math.abs(matrix[7]);
	        result[8] = Math.abs(matrix[8]);
	        result[9] = Math.abs(matrix[9]);
	        result[10] = Math.abs(matrix[10]);
	        result[11] = Math.abs(matrix[11]);
	        result[12] = Math.abs(matrix[12]);
	        result[13] = Math.abs(matrix[13]);
	        result[14] = Math.abs(matrix[14]);
	        result[15] = Math.abs(matrix[15]);

	        return result;
	    };

	    /**
	     * Compares the provided matrices componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Matrix4} [left] The first matrix.
	     * @param {Matrix4} [right] The second matrix.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     *
	     * @example
	     * //compares two Matrix4 instances
	     *
	     * // a = [10.0, 14.0, 18.0, 22.0]
	     * //     [11.0, 15.0, 19.0, 23.0]
	     * //     [12.0, 16.0, 20.0, 24.0]
	     * //     [13.0, 17.0, 21.0, 25.0]
	     *
	     * // b = [10.0, 14.0, 18.0, 22.0]
	     * //     [11.0, 15.0, 19.0, 23.0]
	     * //     [12.0, 16.0, 20.0, 24.0]
	     * //     [13.0, 17.0, 21.0, 25.0]
	     *
	     * if(Cesium.Matrix4.equals(a,b)) {
	     *      console.log("Both matrices are equal");
	     * } else {
	     *      console.log("They are not equal");
	     * }
	     *
	     * //Prints "Both matrices are equal" on the console
	     */
	    Matrix4.equals = function(left, right) {
	        // Given that most matrices will be transformation matrices, the elements
	        // are tested in order such that the test is likely to fail as early
	        // as possible.  I _think_ this is just as friendly to the L1 cache
	        // as testing in index order.  It is certainty faster in practice.
	        return (left === right) ||
	               (defined(left) &&
	                defined(right) &&
	                // Translation
	                left[12] === right[12] &&
	                left[13] === right[13] &&
	                left[14] === right[14] &&

	                // Rotation/scale
	                left[0] === right[0] &&
	                left[1] === right[1] &&
	                left[2] === right[2] &&
	                left[4] === right[4] &&
	                left[5] === right[5] &&
	                left[6] === right[6] &&
	                left[8] === right[8] &&
	                left[9] === right[9] &&
	                left[10] === right[10] &&

	                // Bottom row
	                left[3] === right[3] &&
	                left[7] === right[7] &&
	                left[11] === right[11] &&
	                left[15] === right[15]);
	    };

	    /**
	     * Compares the provided matrices componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Matrix4} [left] The first matrix.
	     * @param {Matrix4} [right] The second matrix.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     *
	     * @example
	     * //compares two Matrix4 instances
	     *
	     * // a = [10.5, 14.5, 18.5, 22.5]
	     * //     [11.5, 15.5, 19.5, 23.5]
	     * //     [12.5, 16.5, 20.5, 24.5]
	     * //     [13.5, 17.5, 21.5, 25.5]
	     *
	     * // b = [10.0, 14.0, 18.0, 22.0]
	     * //     [11.0, 15.0, 19.0, 23.0]
	     * //     [12.0, 16.0, 20.0, 24.0]
	     * //     [13.0, 17.0, 21.0, 25.0]
	     *
	     * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){
	     *      console.log("Difference between both the matrices is less than 0.1");
	     * } else {
	     *      console.log("Difference between both the matrices is not less than 0.1");
	     * }
	     *
	     * //Prints "Difference between both the matrices is not less than 0.1" on the console
	     */
	    Matrix4.equalsEpsilon = function(left, right, epsilon) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof epsilon !== 'number') {
	            throw new DeveloperError('epsilon must be a number');
	        }
	        //>>includeEnd('debug');

	        return (left === right) ||
	                (defined(left) &&
	                defined(right) &&
	                Math.abs(left[0] - right[0]) <= epsilon &&
	                Math.abs(left[1] - right[1]) <= epsilon &&
	                Math.abs(left[2] - right[2]) <= epsilon &&
	                Math.abs(left[3] - right[3]) <= epsilon &&
	                Math.abs(left[4] - right[4]) <= epsilon &&
	                Math.abs(left[5] - right[5]) <= epsilon &&
	                Math.abs(left[6] - right[6]) <= epsilon &&
	                Math.abs(left[7] - right[7]) <= epsilon &&
	                Math.abs(left[8] - right[8]) <= epsilon &&
	                Math.abs(left[9] - right[9]) <= epsilon &&
	                Math.abs(left[10] - right[10]) <= epsilon &&
	                Math.abs(left[11] - right[11]) <= epsilon &&
	                Math.abs(left[12] - right[12]) <= epsilon &&
	                Math.abs(left[13] - right[13]) <= epsilon &&
	                Math.abs(left[14] - right[14]) <= epsilon &&
	                Math.abs(left[15] - right[15]) <= epsilon);
	    };

	    /**
	     * Gets the translation portion of the provided matrix, assuming the matrix is a affine transformation matrix.
	     *
	     * @param {Matrix4} matrix The matrix to use.
	     * @param {Cartesian3} result The object onto which to store the result.
	     * @returns {Cartesian3} The modified result parameter.
	     */
	    Matrix4.getTranslation = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result.x = matrix[12];
	        result.y = matrix[13];
	        result.z = matrix[14];
	        return result;
	    };

	    /**
	     * Gets the upper left 3x3 rotation matrix of the provided matrix, assuming the matrix is a affine transformation matrix.
	     *
	     * @param {Matrix4} matrix The matrix to use.
	     * @param {Matrix3} result The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter.
	     *
	     * @example
	     * // returns a Matrix3 instance from a Matrix4 instance
	     *
	     * // m = [10.0, 14.0, 18.0, 22.0]
	     * //     [11.0, 15.0, 19.0, 23.0]
	     * //     [12.0, 16.0, 20.0, 24.0]
	     * //     [13.0, 17.0, 21.0, 25.0]
	     *
	     * var b = new Cesium.Matrix3();
	     * Cesium.Matrix4.getRotation(m,b);
	     *
	     * // b = [10.0, 14.0, 18.0]
	     * //     [11.0, 15.0, 19.0]
	     * //     [12.0, 16.0, 20.0]
	     */
	    Matrix4.getRotation = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        result[0] = matrix[0];
	        result[1] = matrix[1];
	        result[2] = matrix[2];
	        result[3] = matrix[4];
	        result[4] = matrix[5];
	        result[5] = matrix[6];
	        result[6] = matrix[8];
	        result[7] = matrix[9];
	        result[8] = matrix[10];
	        return result;
	    };

	    var scratchInverseRotation = new Matrix3();
	    var scratchMatrix3Zero = new Matrix3();
	    var scratchBottomRow = new Cartesian4();
	    var scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);

	     /**
	      * Computes the inverse of the provided matrix using Cramers Rule.
	      * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
	      * If the matrix is an affine transformation matrix, it is more efficient
	      * to invert it with {@link Matrix4.inverseTransformation}.
	      *
	      * @param {Matrix4} matrix The matrix to invert.
	      * @param {Matrix4} result The object onto which to store the result.
	      * @returns {Matrix4} The modified result parameter.
	      *
	      * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
	      */
	    Matrix4.inverse = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        // Special case for a zero scale matrix that can occur, for example,
	        // when a model's node has a [0, 0, 0] scale.
	        if (Matrix3.equalsEpsilon(Matrix4.getRotation(matrix, scratchInverseRotation), scratchMatrix3Zero, CesiumMath.EPSILON7) &&
	            Cartesian4.equals(Matrix4.getRow(matrix, 3, scratchBottomRow), scratchExpectedBottomRow)) {

	            result[0] = 0.0;
	            result[1] = 0.0;
	            result[2] = 0.0;
	            result[3] = 0.0;
	            result[4] = 0.0;
	            result[5] = 0.0;
	            result[6] = 0.0;
	            result[7] = 0.0;
	            result[8] = 0.0;
	            result[9] = 0.0;
	            result[10] = 0.0;
	            result[11] = 0.0;
	            result[12] = -matrix[12];
	            result[13] = -matrix[13];
	            result[14] = -matrix[14];
	            result[15] = 1.0;
	            return result;
	        }

	        //
	        // Ported from:
	        //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf
	        //
	        var src0 = matrix[0];
	        var src1 = matrix[4];
	        var src2 = matrix[8];
	        var src3 = matrix[12];
	        var src4 = matrix[1];
	        var src5 = matrix[5];
	        var src6 = matrix[9];
	        var src7 = matrix[13];
	        var src8 = matrix[2];
	        var src9 = matrix[6];
	        var src10 = matrix[10];
	        var src11 = matrix[14];
	        var src12 = matrix[3];
	        var src13 = matrix[7];
	        var src14 = matrix[11];
	        var src15 = matrix[15];

	        // calculate pairs for first 8 elements (cofactors)
	        var tmp0 = src10 * src15;
	        var tmp1 = src11 * src14;
	        var tmp2 = src9 * src15;
	        var tmp3 = src11 * src13;
	        var tmp4 = src9 * src14;
	        var tmp5 = src10 * src13;
	        var tmp6 = src8 * src15;
	        var tmp7 = src11 * src12;
	        var tmp8 = src8 * src14;
	        var tmp9 = src10 * src12;
	        var tmp10 = src8 * src13;
	        var tmp11 = src9 * src12;

	        // calculate first 8 elements (cofactors)
	        var dst0 = (tmp0 * src5 + tmp3 * src6 + tmp4 * src7) - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
	        var dst1 = (tmp1 * src4 + tmp6 * src6 + tmp9 * src7) - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
	        var dst2 = (tmp2 * src4 + tmp7 * src5 + tmp10 * src7) - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
	        var dst3 = (tmp5 * src4 + tmp8 * src5 + tmp11 * src6) - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
	        var dst4 = (tmp1 * src1 + tmp2 * src2 + tmp5 * src3) - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
	        var dst5 = (tmp0 * src0 + tmp7 * src2 + tmp8 * src3) - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
	        var dst6 = (tmp3 * src0 + tmp6 * src1 + tmp11 * src3) - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
	        var dst7 = (tmp4 * src0 + tmp9 * src1 + tmp10 * src2) - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);

	        // calculate pairs for second 8 elements (cofactors)
	        tmp0 = src2 * src7;
	        tmp1 = src3 * src6;
	        tmp2 = src1 * src7;
	        tmp3 = src3 * src5;
	        tmp4 = src1 * src6;
	        tmp5 = src2 * src5;
	        tmp6 = src0 * src7;
	        tmp7 = src3 * src4;
	        tmp8 = src0 * src6;
	        tmp9 = src2 * src4;
	        tmp10 = src0 * src5;
	        tmp11 = src1 * src4;

	        // calculate second 8 elements (cofactors)
	        var dst8 = (tmp0 * src13 + tmp3 * src14 + tmp4 * src15) - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
	        var dst9 = (tmp1 * src12 + tmp6 * src14 + tmp9 * src15) - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
	        var dst10 = (tmp2 * src12 + tmp7 * src13 + tmp10 * src15) - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
	        var dst11 = (tmp5 * src12 + tmp8 * src13 + tmp11 * src14) - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
	        var dst12 = (tmp2 * src10 + tmp5 * src11 + tmp1 * src9) - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
	        var dst13 = (tmp8 * src11 + tmp0 * src8 + tmp7 * src10) - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
	        var dst14 = (tmp6 * src9 + tmp11 * src11 + tmp3 * src8) - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
	        var dst15 = (tmp10 * src10 + tmp4 * src8 + tmp9 * src9) - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);

	        // calculate determinant
	        var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;

	        if (Math.abs(det) < CesiumMath.EPSILON20) {
	            throw new RuntimeError('matrix is not invertible because its determinate is zero.');
	        }

	        // calculate matrix inverse
	        det = 1.0 / det;

	        result[0] = dst0 * det;
	        result[1] = dst1 * det;
	        result[2] = dst2 * det;
	        result[3] = dst3 * det;
	        result[4] = dst4 * det;
	        result[5] = dst5 * det;
	        result[6] = dst6 * det;
	        result[7] = dst7 * det;
	        result[8] = dst8 * det;
	        result[9] = dst9 * det;
	        result[10] = dst10 * det;
	        result[11] = dst11 * det;
	        result[12] = dst12 * det;
	        result[13] = dst13 * det;
	        result[14] = dst14 * det;
	        result[15] = dst15 * det;
	        return result;
	    };

	    /**
	     * Computes the inverse of the provided matrix assuming it is
	     * an affine transformation matrix, where the upper left 3x3 elements
	     * are a rotation matrix, and the upper three elements in the fourth
	     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
	     * The matrix is not verified to be in the proper form.
	     * This method is faster than computing the inverse for a general 4x4
	     * matrix using {@link Matrix4.inverse}.
	     *
	     * @param {Matrix4} matrix The matrix to invert.
	     * @param {Matrix4} result The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter.
	     */
	    Matrix4.inverseTransformation = function(matrix, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(matrix)) {
	            throw new DeveloperError('matrix is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required,');
	        }
	        //>>includeEnd('debug');

	        //This function is an optimized version of the below 4 lines.
	        //var rT = Matrix3.transpose(Matrix4.getRotation(matrix));
	        //var rTN = Matrix3.negate(rT);
	        //var rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));
	        //return Matrix4.fromRotationTranslation(rT, rTT, result);

	        var matrix0 = matrix[0];
	        var matrix1 = matrix[1];
	        var matrix2 = matrix[2];
	        var matrix4 = matrix[4];
	        var matrix5 = matrix[5];
	        var matrix6 = matrix[6];
	        var matrix8 = matrix[8];
	        var matrix9 = matrix[9];
	        var matrix10 = matrix[10];

	        var vX = matrix[12];
	        var vY = matrix[13];
	        var vZ = matrix[14];

	        var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
	        var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
	        var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;

	        result[0] = matrix0;
	        result[1] = matrix4;
	        result[2] = matrix8;
	        result[3] = 0.0;
	        result[4] = matrix1;
	        result[5] = matrix5;
	        result[6] = matrix9;
	        result[7] = 0.0;
	        result[8] = matrix2;
	        result[9] = matrix6;
	        result[10] = matrix10;
	        result[11] = 0.0;
	        result[12] = x;
	        result[13] = y;
	        result[14] = z;
	        result[15] = 1.0;
	        return result;
	    };

	    /**
	     * An immutable Matrix4 instance initialized to the identity matrix.
	     *
	     * @type {Matrix4}
	     * @constant
	     */
	    Matrix4.IDENTITY = freezeObject(new Matrix4(1.0, 0.0, 0.0, 0.0,
	                                                0.0, 1.0, 0.0, 0.0,
	                                                0.0, 0.0, 1.0, 0.0,
	                                                0.0, 0.0, 0.0, 1.0));

	    /**
	     * The index into Matrix4 for column 0, row 0.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN0ROW0 = 0;

	    /**
	     * The index into Matrix4 for column 0, row 1.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN0ROW1 = 1;

	    /**
	     * The index into Matrix4 for column 0, row 2.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN0ROW2 = 2;

	    /**
	     * The index into Matrix4 for column 0, row 3.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN0ROW3 = 3;

	    /**
	     * The index into Matrix4 for column 1, row 0.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN1ROW0 = 4;

	    /**
	     * The index into Matrix4 for column 1, row 1.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN1ROW1 = 5;

	    /**
	     * The index into Matrix4 for column 1, row 2.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN1ROW2 = 6;

	    /**
	     * The index into Matrix4 for column 1, row 3.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN1ROW3 = 7;

	    /**
	     * The index into Matrix4 for column 2, row 0.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN2ROW0 = 8;

	    /**
	     * The index into Matrix4 for column 2, row 1.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN2ROW1 = 9;

	    /**
	     * The index into Matrix4 for column 2, row 2.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN2ROW2 = 10;

	    /**
	     * The index into Matrix4 for column 2, row 3.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN2ROW3 = 11;

	    /**
	     * The index into Matrix4 for column 3, row 0.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN3ROW0 = 12;

	    /**
	     * The index into Matrix4 for column 3, row 1.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN3ROW1 = 13;

	    /**
	     * The index into Matrix4 for column 3, row 2.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN3ROW2 = 14;

	    /**
	     * The index into Matrix4 for column 3, row 3.
	     *
	     * @type {Number}
	     * @constant
	     */
	    Matrix4.COLUMN3ROW3 = 15;

	    /**
	     * Duplicates the provided Matrix4 instance.
	     *
	     * @param {Matrix4} [result] The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
	     */
	    Matrix4.prototype.clone = function(result) {
	        return Matrix4.clone(this, result);
	    };

	    /**
	     * Compares this matrix to the provided matrix componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Matrix4} [right] The right hand side matrix.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    Matrix4.prototype.equals = function(right) {
	        return Matrix4.equals(this, right);
	    };

	    /**
	     * @private
	     */
	    Matrix4.equalsArray = function(matrix, array, offset) {
	        return matrix[0] === array[offset] &&
	               matrix[1] === array[offset + 1] &&
	               matrix[2] === array[offset + 2] &&
	               matrix[3] === array[offset + 3] &&
	               matrix[4] === array[offset + 4] &&
	               matrix[5] === array[offset + 5] &&
	               matrix[6] === array[offset + 6] &&
	               matrix[7] === array[offset + 7] &&
	               matrix[8] === array[offset + 8] &&
	               matrix[9] === array[offset + 9] &&
	               matrix[10] === array[offset + 10] &&
	               matrix[11] === array[offset + 11] &&
	               matrix[12] === array[offset + 12] &&
	               matrix[13] === array[offset + 13] &&
	               matrix[14] === array[offset + 14] &&
	               matrix[15] === array[offset + 15];
	    };

	    /**
	     * Compares this matrix to the provided matrix componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Matrix4} [right] The right hand side matrix.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Matrix4.prototype.equalsEpsilon = function(right, epsilon) {
	        return Matrix4.equalsEpsilon(this, right, epsilon);
	    };

	    /**
	     * Computes a string representing this Matrix with each row being
	     * on a separate line and in the format '(column0, column1, column2, column3)'.
	     *
	     * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
	     */
	    Matrix4.prototype.toString = function() {
	        return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] +')\n' +
	               '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] +')\n' +
	               '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] +')\n' +
	               '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] +')';
	    };

	    return Matrix4;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        DeveloperError) {
	    "use strict";

	    /**
	     * Finds an item in a sorted array.
	     *
	     * @exports binarySearch
	     *
	     * @param {Array} array The sorted array to search.
	     * @param {Object} itemToFind The item to find in the array.
	     * @param {binarySearch~Comparator} comparator The function to use to compare the item to
	     *        elements in the array.
	     * @returns {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
	     *        does not exist, the return value is a negative number which is the bitwise complement (~)
	     *        of the index before which the itemToFind should be inserted in order to maintain the
	     *        sorted order of the array.
	     *
	     * @example
	     * // Create a comparator function to search through an array of numbers.
	     * var comparator = function(a, b) {
	     *     return a - b;
	     * };
	     * var numbers = [0, 2, 4, 6, 8];
	     * var index = Cesium.binarySearch(numbers, 6, comparator); // 3
	     */
	    var binarySearch = function(array, itemToFind, comparator) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required.');
	        }
	        if (!defined(itemToFind)) {
	            throw new DeveloperError('itemToFind is required.');
	        }
	        if (!defined(comparator)) {
	            throw new DeveloperError('comparator is required.');
	        }
	        //>>includeEnd('debug');

	        var low = 0;
	        var high = array.length - 1;
	        var i;
	        var comparison;

	        while (low <= high) {
	            i = ~~((low + high) / 2);
	            comparison = comparator(array[i], itemToFind);
	            if (comparison < 0) {
	                low = i + 1;
	                continue;
	            }
	            if (comparison > 0) {
	                high = i - 1;
	                continue;
	            }
	            return i;
	        }
	        return ~(high + 1);
	    };

	    /**
	     * A function used to compare two items while performing a binary search.
	     * @callback binarySearch~Comparator
	     *
	     * @param {Object} a An item in the array.
	     * @param {Object} b The item being searched for.
	     * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,
	     *          a positive value if <code>a</code> is greater than <code>b</code>, or
	     *          0 if <code>a</code> is equal to <code>b</code>.
	     *
	     * @example
	     * function compareNumbers(a, b) {
	     *     return a - b;
	     * }
	     */

	    return binarySearch;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    /**
	     * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
	     *
	     * @exports createGuid
	     *
	     * @see {@link http://www.ietf.org/rfc/rfc4122.txt|RFC 4122 A Universally Unique IDentifier (UUID) URN Namespace}
	     *
	     * @example
	     * this.guid = Cesium.createGuid();
	     */
	    var createGuid = function() {
	        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	            var r = Math.random() * 16 | 0;
	            var v = c === 'x' ? r : (r & 0x3 | 0x8);
	            return v.toString(16);
	        });
	    };

	    return createGuid;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	  @license
	  when.js - https://github.com/cujojs/when

	  MIT License (c) copyright B Cavalier & J Hann

	 * A lightweight CommonJS Promises/A and when() implementation
	 * when is part of the cujo.js family of libraries (http://cujojs.com/)
	 *
	 * Licensed under the MIT License at:
	 * http://www.opensource.org/licenses/mit-license.php
	 *
	 * @version 1.7.1
	 */

	(function(define) { 'use strict';
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
		var reduceArray, slice, undef;

		//
		// Public API
		//

		when.defer     = defer;     // Create a deferred
		when.resolve   = resolve;   // Create a resolved promise
		when.reject    = reject;    // Create a rejected promise

		when.join      = join;      // Join 2 or more promises

		when.all       = all;       // Resolve a list of promises
		when.map       = map;       // Array.map() for promises
		when.reduce    = reduce;    // Array.reduce() for promises

		when.any       = any;       // One-winner race
		when.some      = some;      // Multi-winner race

		when.chain     = chain;     // Make a promise trigger another resolver

		when.isPromise = isPromise; // Determine if a thing is a promise

		/**
		 * Register an observer for a promise or immediate value.
		 *
		 * @param {*} promiseOrValue
		 * @param {function?} [onFulfilled] callback to be called when promiseOrValue is
		 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
		 *   will be invoked immediately.
		 * @param {function?} [onRejected] callback to be called when promiseOrValue is
		 *   rejected.
		 * @param {function?} [onProgress] callback to be called when progress updates
		 *   are issued for promiseOrValue.
		 * @returns {Promise} a new {@link Promise} that will complete with the return
		 *   value of callback or errback or the completion value of promiseOrValue if
		 *   callback and/or errback is not supplied.
		 */
		function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
			// Get a trusted promise for the input promiseOrValue, and then
			// register promise handlers
			return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
		}

		/**
		 * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
		 * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}
		 * whose value is promiseOrValue if promiseOrValue is an immediate value.
		 *
		 * @param {*} promiseOrValue
		 * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
		 *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
		 *   whose resolution value is:
		 *   * the resolution value of promiseOrValue if it's a foreign promise, or
		 *   * promiseOrValue if it's a value
		 */
		function resolve(promiseOrValue) {
			var promise, deferred;

			if(promiseOrValue instanceof Promise) {
				// It's a when.js promise, so we trust it
				promise = promiseOrValue;

			} else {
				// It's not a when.js promise. See if it's a foreign promise or a value.
				if(isPromise(promiseOrValue)) {
					// It's a thenable, but we don't know where it came from, so don't trust
					// its implementation entirely.  Introduce a trusted middleman when.js promise
					deferred = defer();

					// IMPORTANT: This is the only place when.js should ever call .then() on an
					// untrusted promise. Don't expose the return value to the untrusted promise
					promiseOrValue.then(
						function(value)  { deferred.resolve(value); },
						function(reason) { deferred.reject(reason); },
						function(update) { deferred.progress(update); }
					);

					promise = deferred.promise;

				} else {
					// It's a value, not a promise.  Create a resolved promise for it.
					promise = fulfilled(promiseOrValue);
				}
			}

			return promise;
		}

		/**
		 * Returns a rejected promise for the supplied promiseOrValue.  The returned
		 * promise will be rejected with:
		 * - promiseOrValue, if it is a value, or
		 * - if promiseOrValue is a promise
		 *   - promiseOrValue's value after it is fulfilled
		 *   - promiseOrValue's reason after it is rejected
		 * @param {*} promiseOrValue the rejected value of the returned {@link Promise}
		 * @returns {Promise} rejected {@link Promise}
		 */
		function reject(promiseOrValue) {
			return when(promiseOrValue, rejected);
		}

		/**
		 * Trusted Promise constructor.  A Promise created from this constructor is
		 * a trusted when.js promise.  Any other duck-typed promise is considered
		 * untrusted.
		 * @constructor
		 * @name Promise
		 */
		function Promise(then) {
			this.then = then;
		}

		Promise.prototype = {
			/**
			 * Register a callback that will be called when a promise is
			 * fulfilled or rejected.  Optionally also register a progress handler.
			 * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)
			 * @param {function?} [onFulfilledOrRejected]
			 * @param {function?} [onProgress]
			 * @returns {Promise}
			 */
			always: function(onFulfilledOrRejected, onProgress) {
				return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
			},

			/**
			 * Register a rejection handler.  Shortcut for .then(undefined, onRejected)
			 * @param {function?} onRejected
			 * @returns {Promise}
			 */
			otherwise: function(onRejected) {
				return this.then(undef, onRejected);
			},

			/**
			 * Shortcut for .then(function() { return value; })
			 * @param  {*} value
			 * @returns {Promise} a promise that:
			 *  - is fulfilled if value is not a promise, or
			 *  - if value is a promise, will fulfill with its value, or reject
			 *    with its reason.
			 */
			yield: function(value) {
				return this.then(function() {
					return value;
				});
			},

			/**
			 * Assumes that this promise will fulfill with an array, and arranges
			 * for the onFulfilled to be called with the array as its argument list
			 * i.e. onFulfilled.spread(undefined, array).
			 * @param {function} onFulfilled function to receive spread arguments
			 * @returns {Promise}
			 */
			spread: function(onFulfilled) {
				return this.then(function(array) {
					// array may contain promises, so resolve its contents.
					return all(array, function(array) {
						return onFulfilled.apply(undef, array);
					});
				});
			}
		};

		/**
		 * Create an already-resolved promise for the supplied value
		 * @private
		 *
		 * @param {*} value
		 * @returns {Promise} fulfilled promise
		 */
		function fulfilled(value) {
			var p = new Promise(function(onFulfilled) {
				// TODO: Promises/A+ check typeof onFulfilled
				try {
					return resolve(onFulfilled ? onFulfilled(value) : value);
				} catch(e) {
					return rejected(e);
				}
			});

			return p;
		}

		/**
		 * Create an already-rejected {@link Promise} with the supplied
		 * rejection reason.
		 * @private
		 *
		 * @param {*} reason
		 * @returns {Promise} rejected promise
		 */
		function rejected(reason) {
			var p = new Promise(function(_, onRejected) {
				// TODO: Promises/A+ check typeof onRejected
				try {
					return onRejected ? resolve(onRejected(reason)) : rejected(reason);
				} catch(e) {
					return rejected(e);
				}
			});

			return p;
		}

		/**
		 * Creates a new, Deferred with fully isolated resolver and promise parts,
		 * either or both of which may be given out safely to consumers.
		 * The Deferred itself has the full API: resolve, reject, progress, and
		 * then. The resolver has resolve, reject, and progress.  The promise
		 * only has then.
		 *
		 * @returns {Deferred}
		 */
		function defer() {
			var deferred, promise, handlers, progressHandlers,
				_then, _progress, _resolve;

			/**
			 * The promise for the new deferred
			 * @type {Promise}
			 */
			promise = new Promise(then);

			/**
			 * The full Deferred object, with {@link Promise} and {@link Resolver} parts
			 * @class Deferred
			 * @name Deferred
			 */
			deferred = {
				then:     then, // DEPRECATED: use deferred.promise.then
				resolve:  promiseResolve,
				reject:   promiseReject,
				// TODO: Consider renaming progress() to notify()
				progress: promiseProgress,

				promise:  promise,

				resolver: {
					resolve:  promiseResolve,
					reject:   promiseReject,
					progress: promiseProgress
				}
			};

			handlers = [];
			progressHandlers = [];

			/**
			 * Pre-resolution then() that adds the supplied callback, errback, and progback
			 * functions to the registered listeners
			 * @private
			 *
			 * @param {function?} [onFulfilled] resolution handler
			 * @param {function?} [onRejected] rejection handler
			 * @param {function?} [onProgress] progress handler
			 */
			_then = function(onFulfilled, onRejected, onProgress) {
				// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
				var deferred, progressHandler;

				deferred = defer();

				progressHandler = typeof onProgress === 'function'
					? function(update) {
						try {
							// Allow progress handler to transform progress event
							deferred.progress(onProgress(update));
						} catch(e) {
							// Use caught value as progress
							deferred.progress(e);
						}
					}
					: function(update) { deferred.progress(update); };

				handlers.push(function(promise) {
					promise.then(onFulfilled, onRejected)
						.then(deferred.resolve, deferred.reject, progressHandler);
				});

				progressHandlers.push(progressHandler);

				return deferred.promise;
			};

			/**
			 * Issue a progress event, notifying all progress listeners
			 * @private
			 * @param {*} update progress event payload to pass to all listeners
			 */
			_progress = function(update) {
				processQueue(progressHandlers, update);
				return update;
			};

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the resolution or rejection
			 * @private
			 * @param {*} value the value of this deferred
			 */
			_resolve = function(value) {
				value = resolve(value);

				// Replace _then with one that directly notifies with the result.
				_then = value.then;
				// Replace _resolve so that this Deferred can only be resolved once
				_resolve = resolve;
				// Make _progress a noop, to disallow progress for the resolved promise.
				_progress = noop;

				// Notify handlers
				processQueue(handlers, value);

				// Free progressHandlers array since we'll never issue progress events
				progressHandlers = handlers = undef;

				return value;
			};

			return deferred;

			/**
			 * Wrapper to allow _then to be replaced safely
			 * @param {function?} [onFulfilled] resolution handler
			 * @param {function?} [onRejected] rejection handler
			 * @param {function?} [onProgress] progress handler
			 * @returns {Promise} new promise
			 */
			function then(onFulfilled, onRejected, onProgress) {
				// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
				return _then(onFulfilled, onRejected, onProgress);
			}

			/**
			 * Wrapper to allow _resolve to be replaced
			 */
			function promiseResolve(val) {
				return _resolve(val);
			}

			/**
			 * Wrapper to allow _reject to be replaced
			 */
			function promiseReject(err) {
				return _resolve(rejected(err));
			}

			/**
			 * Wrapper to allow _progress to be replaced
			 */
			function promiseProgress(update) {
				return _progress(update);
			}
		}

		/**
		 * Determines if promiseOrValue is a promise or not.  Uses the feature
		 * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
		 * promiseOrValue is a promise.
		 *
		 * @param {*} promiseOrValue anything
		 * @returns {boolean} true if promiseOrValue is a {@link Promise}
		 */
		function isPromise(promiseOrValue) {
			return promiseOrValue && typeof promiseOrValue.then === 'function';
		}

		/**
		 * Initiates a competitive race, returning a promise that will resolve when
		 * howMany of the supplied promisesOrValues have resolved, or will reject when
		 * it becomes impossible for howMany to resolve, for example, when
		 * (promisesOrValues.length - howMany) + 1 input promises reject.
		 *
		 * @param {Array} promisesOrValues array of anything, may contain a mix
		 *      of promises and values
		 * @param howMany {number} number of promisesOrValues to resolve
		 * @param {function?} [onFulfilled] resolution handler
		 * @param {function?} [onRejected] rejection handler
		 * @param {function?} [onProgress] progress handler
		 * @returns {Promise} promise that will resolve to an array of howMany values that
		 * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1
		 * rejection reasons.
		 */
		function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {

			checkCallbacks(2, arguments);

			return when(promisesOrValues, function(promisesOrValues) {

				var toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;

				len = promisesOrValues.length >>> 0;

				toResolve = Math.max(0, Math.min(howMany, len));
				values = [];

				toReject = (len - toResolve) + 1;
				reasons = [];

				deferred = defer();

				// No items in the input, resolve immediately
				if (!toResolve) {
					deferred.resolve(values);

				} else {
					progress = deferred.progress;

					rejectOne = function(reason) {
						reasons.push(reason);
						if(!--toReject) {
							fulfillOne = rejectOne = noop;
							deferred.reject(reasons);
						}
					};

					fulfillOne = function(val) {
						// This orders the values based on promise resolution order
						// Another strategy would be to use the original position of
						// the corresponding promise.
						values.push(val);

						if (!--toResolve) {
							fulfillOne = rejectOne = noop;
							deferred.resolve(values);
						}
					};

					for(i = 0; i < len; ++i) {
						if(i in promisesOrValues) {
							when(promisesOrValues[i], fulfiller, rejecter, progress);
						}
					}
				}

				return deferred.then(onFulfilled, onRejected, onProgress);

				function rejecter(reason) {
					rejectOne(reason);
				}

				function fulfiller(val) {
					fulfillOne(val);
				}

			});
		}

		/**
		 * Initiates a competitive race, returning a promise that will resolve when
		 * any one of the supplied promisesOrValues has resolved or will reject when
		 * *all* promisesOrValues have rejected.
		 *
		 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
		 *      of {@link Promise}s and values
		 * @param {function?} [onFulfilled] resolution handler
		 * @param {function?} [onRejected] rejection handler
		 * @param {function?} [onProgress] progress handler
		 * @returns {Promise} promise that will resolve to the value that resolved first, or
		 * will reject with an array of all rejected inputs.
		 */
		function any(promisesOrValues, onFulfilled, onRejected, onProgress) {

			function unwrapSingleResult(val) {
				return onFulfilled ? onFulfilled(val[0]) : val[0];
			}

			return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
		}

		/**
		 * Return a promise that will resolve only once all the supplied promisesOrValues
		 * have resolved. The resolution value of the returned promise will be an array
		 * containing the resolution values of each of the promisesOrValues.
		 * @memberOf when
		 *
		 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
		 *      of {@link Promise}s and values
		 * @param {function?} [onFulfilled] resolution handler
		 * @param {function?} [onRejected] rejection handler
		 * @param {function?} [onProgress] progress handler
		 * @returns {Promise}
		 */
		function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
			checkCallbacks(1, arguments);
			return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
		}

		/**
		 * Joins multiple promises into a single returned promise.
		 * @returns {Promise} a promise that will fulfill when *all* the input promises
		 * have fulfilled, or will reject when *any one* of the input promises rejects.
		 */
		function join(/* ...promises */) {
			return map(arguments, identity);
		}

		/**
		 * Traditional map function, similar to `Array.prototype.map()`, but allows
		 * input to contain {@link Promise}s and/or values, and mapFunc may return
		 * either a value or a {@link Promise}
		 *
		 * @param {Array|Promise} promise array of anything, may contain a mix
		 *      of {@link Promise}s and values
		 * @param {function} mapFunc mapping function mapFunc(value) which may return
		 *      either a {@link Promise} or value
		 * @returns {Promise} a {@link Promise} that will resolve to an array containing
		 *      the mapped output values.
		 */
		function map(promise, mapFunc) {
			return when(promise, function(array) {
				var results, len, toResolve, resolve, i, d;

				// Since we know the resulting length, we can preallocate the results
				// array to avoid array expansions.
				toResolve = len = array.length >>> 0;
				results = [];
				d = defer();

				if(!toResolve) {
					d.resolve(results);
				} else {

					resolve = function resolveOne(item, i) {
						when(item, mapFunc).then(function(mapped) {
							results[i] = mapped;

							if(!--toResolve) {
								d.resolve(results);
							}
						}, d.reject);
					};

					// Since mapFunc may be async, get all invocations of it into flight
					for(i = 0; i < len; i++) {
						if(i in array) {
							resolve(array[i], i);
						} else {
							--toResolve;
						}
					}

				}

				return d.promise;

			});
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 *
		 * @param {Array|Promise} promise array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),
		 *      where total is the total number of items being reduced, and will be the same
		 *      in each call to reduceFunc.
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promise, reduceFunc /*, initialValue */) {
			var args = slice.call(arguments, 1);

			return when(promise, function(array) {
				var total;

				total = array.length;

				// Wrap the supplied reduceFunc with one that handles promises and then
				// delegates to the supplied.
				args[0] = function (current, val, i) {
					return when(current, function (c) {
						return when(val, function (value) {
							return reduceFunc(c, value, i, total);
						});
					});
				};

				return reduceArray.apply(array, args);
			});
		}

		/**
		 * Ensure that resolution of promiseOrValue will trigger resolver with the
		 * value or reason of promiseOrValue, or instead with resolveValue if it is provided.
		 *
		 * @param promiseOrValue
		 * @param {Object} resolver
		 * @param {function} resolver.resolve
		 * @param {function} resolver.reject
		 * @param {*} [resolveValue]
		 * @returns {Promise}
		 */
		function chain(promiseOrValue, resolver, resolveValue) {
			var useResolveValue = arguments.length > 2;

			return when(promiseOrValue,
				function(val) {
					val = useResolveValue ? resolveValue : val;
					resolver.resolve(val);
					return val;
				},
				function(reason) {
					resolver.reject(reason);
					return rejected(reason);
				},
				resolver.progress
			);
		}

		//
		// Utility functions
		//

		/**
		 * Apply all functions in queue to value
		 * @param {Array} queue array of functions to execute
		 * @param {*} value argument passed to each function
		 */
		function processQueue(queue, value) {
			var handler, i = 0;

			while (handler = queue[i++]) {
				handler(value);
			}
		}

		/**
		 * Helper that checks arrayOfCallbacks to ensure that each element is either
		 * a function, or null or undefined.
		 * @private
		 * @param {number} start index at which to start checking items in arrayOfCallbacks
		 * @param {Array} arrayOfCallbacks array to check
		 * @throws {Error} if any element of arrayOfCallbacks is something other than
		 * a functions, null, or undefined.
		 */
		function checkCallbacks(start, arrayOfCallbacks) {
			// TODO: Promises/A+ update type checking and docs
			var arg, i = arrayOfCallbacks.length;

			while(i > start) {
				arg = arrayOfCallbacks[--i];

				if (arg != null && typeof arg != 'function') {
					throw new Error('arg '+i+' must be a function');
				}
			}
		}

		/**
		 * No-Op function used in method replacement
		 * @private
		 */
		function noop() {}

		slice = [].slice;

		// ES5 reduce implementation if native not available
		// See: http://es5.github.com/#x15.4.4.21 as there are many
		// specifics and edge cases.
		reduceArray = [].reduce ||
			function(reduceFunc /*, initialValue */) {
				/*jshint maxcomplexity: 7*/

				// ES5 dictates that reduce.length === 1

				// This implementation deviates from ES5 spec in the following ways:
				// 1. It does not check if reduceFunc is a Callable

				var arr, args, reduced, len, i;

				i = 0;
				// This generates a jshint warning, despite being valid
				// "Missing 'new' prefix when invoking a constructor."
				// See https://github.com/jshint/jshint/issues/392
				arr = Object(this);
				len = arr.length >>> 0;
				args = arguments;

				// If no initialValue, use first item of array (we know length !== 0 here)
				// and adjust i to start at second item
				if(args.length <= 1) {
					// Skip to the first real element in the array
					for(;;) {
						if(i in arr) {
							reduced = arr[i++];
							break;
						}

						// If we reached the end of the array without finding any real
						// elements, it's a TypeError
						if(++i >= len) {
							throw new TypeError();
						}
					}
				} else {
					// If initialValue provided, use it
					reduced = args[1];
				}

				// Do the actual reduce
				for(;i < len; ++i) {
					// Skip holes
					if(i in arr) {
						reduced = reduceFunc(reduced, arr[i], i, arr);
					}
				}

				return reduced;
			};

		function identity(x) {
			return x;
		}

		return when;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(213)
		// Boilerplate for AMD, Node, and browser global
	);

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2015
	 */
	var EventEmitter = __webpack_require__(142);
	function EventHandler() {
	    EventEmitter.apply(this, arguments);
	    this.downstream = [];
	    this.downstreamFn = [];
	    this.upstream = [];
	    this.upstreamListeners = {};
	}
	EventHandler.prototype = Object.create(EventEmitter.prototype);
	EventHandler.prototype.constructor = EventHandler;
	EventHandler.setInputHandler = function setInputHandler(object, handler) {
	    object.trigger = handler.trigger.bind(handler);
	    if (handler.subscribe && handler.unsubscribe) {
	        object.subscribe = handler.subscribe.bind(handler);
	        object.unsubscribe = handler.unsubscribe.bind(handler);
	    }
	};
	EventHandler.setOutputHandler = function setOutputHandler(object, handler) {
	    if (handler instanceof EventHandler)
	        handler.bindThis(object);
	    object.pipe = handler.pipe.bind(handler);
	    object.unpipe = handler.unpipe.bind(handler);
	    object.on = handler.on.bind(handler);
	    object.addListener = object.on;
	    object.removeListener = handler.removeListener.bind(handler);
	};
	EventHandler.prototype.emit = function emit(type, event) {
	    EventEmitter.prototype.emit.apply(this, arguments);
	    var i = 0;
	    for (i = 0; i < this.downstream.length; i++) {
	        if (this.downstream[i].trigger)
	            this.downstream[i].trigger(type, event);
	    }
	    for (i = 0; i < this.downstreamFn.length; i++) {
	        this.downstreamFn[i](type, event);
	    }
	    return this;
	};
	EventHandler.prototype.trigger = EventHandler.prototype.emit;
	EventHandler.prototype.pipe = function pipe(target) {
	    if (target.subscribe instanceof Function)
	        return target.subscribe(this);
	    var downstreamCtx = target instanceof Function ? this.downstreamFn : this.downstream;
	    var index = downstreamCtx.indexOf(target);
	    if (index < 0)
	        downstreamCtx.push(target);
	    if (target instanceof Function)
	        target('pipe', null);
	    else if (target.trigger)
	        target.trigger('pipe', null);
	    return target;
	};
	EventHandler.prototype.unpipe = function unpipe(target) {
	    if (target.unsubscribe instanceof Function)
	        return target.unsubscribe(this);
	    var downstreamCtx = target instanceof Function ? this.downstreamFn : this.downstream;
	    var index = downstreamCtx.indexOf(target);
	    if (index >= 0) {
	        downstreamCtx.splice(index, 1);
	        if (target instanceof Function)
	            target('unpipe', null);
	        else if (target.trigger)
	            target.trigger('unpipe', null);
	        return target;
	    } else
	        return false;
	};
	EventHandler.prototype.on = function on(type, handler) {
	    EventEmitter.prototype.on.apply(this, arguments);
	    if (!(type in this.upstreamListeners)) {
	        var upstreamListener = this.trigger.bind(this, type);
	        this.upstreamListeners[type] = upstreamListener;
	        for (var i = 0; i < this.upstream.length; i++) {
	            this.upstream[i].on(type, upstreamListener);
	        }
	    }
	    return this;
	};
	EventHandler.prototype.addListener = EventHandler.prototype.on;
	EventHandler.prototype.subscribe = function subscribe(source) {
	    var index = this.upstream.indexOf(source);
	    if (index < 0) {
	        this.upstream.push(source);
	        for (var type in this.upstreamListeners) {
	            source.on(type, this.upstreamListeners[type]);
	        }
	    }
	    return this;
	};
	EventHandler.prototype.unsubscribe = function unsubscribe(source) {
	    var index = this.upstream.indexOf(source);
	    if (index >= 0) {
	        this.upstream.splice(index, 1);
	        for (var type in this.upstreamListeners) {
	            source.removeListener(type, this.upstreamListeners[type]);
	        }
	    }
	    return this;
	};
	module.exports = EventHandler;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	console.log('Argon ' + ("0.1.3"));

	function _parseVersion(version) {
	  var tokens = version.split('.');
	  return {
	    major: tokens[0],
	    minor: tokens[1],
	    patch: tokens[2]
	  };
	}

	exports['default'] = {
	  version: ("0.1.3"),
	  semver: _parseVersion(("0.1.3"))
	};
	module.exports = exports['default'];

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    /**
	     * A 4D Cartesian point.
	     * @alias Cartesian4
	     * @constructor
	     *
	     * @param {Number} [x=0.0] The X component.
	     * @param {Number} [y=0.0] The Y component.
	     * @param {Number} [z=0.0] The Z component.
	     * @param {Number} [w=0.0] The W component.
	     *
	     * @see Cartesian2
	     * @see Cartesian3
	     * @see Packable
	     */
	    var Cartesian4 = function(x, y, z, w) {
	        /**
	         * The X component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.x = defaultValue(x, 0.0);

	        /**
	         * The Y component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.y = defaultValue(y, 0.0);

	        /**
	         * The Z component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.z = defaultValue(z, 0.0);

	        /**
	         * The W component.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.w = defaultValue(w, 0.0);
	    };

	    /**
	     * Creates a Cartesian4 instance from x, y, z and w coordinates.
	     *
	     * @param {Number} x The x coordinate.
	     * @param {Number} y The y coordinate.
	     * @param {Number} z The z coordinate.
	     * @param {Number} w The w coordinate.
	     * @param {Cartesian4} [result] The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
	     */
	    Cartesian4.fromElements = function(x, y, z, w, result) {
	        if (!defined(result)) {
	            return new Cartesian4(x, y, z, w);
	        }

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        result.w = w;
	        return result;
	    };

	    /**
	     * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
	     * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
	     *
	     * @param {Color} color The source color.
	     * @param {Cartesian4} [result] The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
	     */
	    Cartesian4.fromColor = function(color, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(color)) {
	            throw new DeveloperError('color is required');
	        }
	        //>>includeEnd('debug');
	        if (!defined(result)) {
	            return new Cartesian4(color.red, color.green, color.blue, color.alpha);
	        }

	        result.x = color.red;
	        result.y = color.green;
	        result.z = color.blue;
	        result.w = color.alpha;
	        return result;
	    };

	    /**
	     * Duplicates a Cartesian4 instance.
	     *
	     * @param {Cartesian4} cartesian The Cartesian to duplicate.
	     * @param {Cartesian4} [result] The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)
	     */
	    Cartesian4.clone = function(cartesian, result) {
	        if (!defined(cartesian)) {
	            return undefined;
	        }

	        if (!defined(result)) {
	            return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	        }

	        result.x = cartesian.x;
	        result.y = cartesian.y;
	        result.z = cartesian.z;
	        result.w = cartesian.w;
	        return result;
	    };


	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Cartesian4.packedLength = 4;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Cartesian4} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Cartesian4.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value.x;
	        array[startingIndex++] = value.y;
	        array[startingIndex++] = value.z;
	        array[startingIndex] = value.w;
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Cartesian4} [result] The object into which to store the result.
	     * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
	     */
	    Cartesian4.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Cartesian4();
	        }
	        result.x = array[startingIndex++];
	        result.y = array[startingIndex++];
	        result.z = array[startingIndex++];
	        result.w = array[startingIndex];
	        return result;
	    };

	    /**
	     * Creates a Cartesian4 from four consecutive elements in an array.
	     * @function
	     *
	     * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
	     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
	     * @param {Cartesian4} [result] The object onto which to store the result.
	     * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
	     *
	     * @example
	     * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)
	     * var v = [1.0, 2.0, 3.0, 4.0];
	     * var p = Cesium.Cartesian4.fromArray(v);
	     *
	     * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array
	     * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];
	     * var p2 = Cesium.Cartesian4.fromArray(v2, 2);
	     */
	    Cartesian4.fromArray = Cartesian4.unpack;

	    /**
	     * Computes the value of the maximum component for the supplied Cartesian.
	     *
	     * @param {Cartesian4} cartesian The cartesian to use.
	     * @returns {Number} The value of the maximum component.
	     */
	    Cartesian4.maximumComponent = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	    };

	    /**
	     * Computes the value of the minimum component for the supplied Cartesian.
	     *
	     * @param {Cartesian4} cartesian The cartesian to use.
	     * @returns {Number} The value of the minimum component.
	     */
	    Cartesian4.minimumComponent = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
	    };

	    /**
	     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
	     *
	     * @param {Cartesian4} first A cartesian to compare.
	     * @param {Cartesian4} second A cartesian to compare.
	     * @param {Cartesian4} result The object into which to store the result.
	     * @returns {Cartesian4} A cartesian with the minimum components.
	     */
	    Cartesian4.minimumByComponent = function(first, second, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(first)) {
	            throw new DeveloperError('first is required.');
	        }
	        if (!defined(second)) {
	            throw new DeveloperError('second is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.min(first.x, second.x);
	        result.y = Math.min(first.y, second.y);
	        result.z = Math.min(first.z, second.z);
	        result.w = Math.min(first.w, second.w);

	        return result;
	    };

	    /**
	     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
	     *
	     * @param {Cartesian4} first A cartesian to compare.
	     * @param {Cartesian4} second A cartesian to compare.
	     * @param {Cartesian4} result The object into which to store the result.
	     * @returns {Cartesian4} A cartesian with the maximum components.
	     */
	    Cartesian4.maximumByComponent = function(first, second, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(first)) {
	            throw new DeveloperError('first is required.');
	        }
	        if (!defined(second)) {
	            throw new DeveloperError('second is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.max(first.x, second.x);
	        result.y = Math.max(first.y, second.y);
	        result.z = Math.max(first.z, second.z);
	        result.w = Math.max(first.w, second.w);

	        return result;
	    };

	    /**
	     * Computes the provided Cartesian's squared magnitude.
	     *
	     * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.
	     * @returns {Number} The squared magnitude.
	     */
	    Cartesian4.magnitudeSquared = function(cartesian) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
	    };

	    /**
	     * Computes the Cartesian's magnitude (length).
	     *
	     * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.
	     * @returns {Number} The magnitude.
	     */
	    Cartesian4.magnitude = function(cartesian) {
	        return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
	    };

	    var distanceScratch = new Cartesian4();

	    /**
	     * Computes the 4-space distance between two points.
	     *
	     * @param {Cartesian4} left The first point to compute the distance from.
	     * @param {Cartesian4} right The second point to compute the distance to.
	     * @returns {Number} The distance between two points.
	     *
	     * @example
	     * // Returns 1.0
	     * var d = Cesium.Cartesian4.distance(
	     *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
	     *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));
	     */
	    Cartesian4.distance = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left) || !defined(right)) {
	            throw new DeveloperError('left and right are required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian4.subtract(left, right, distanceScratch);
	        return Cartesian4.magnitude(distanceScratch);
	    };

	    /**
	     * Computes the squared distance between two points.  Comparing squared distances
	     * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
	     *
	     * @param {Cartesian4} left The first point to compute the distance from.
	     * @param {Cartesian4} right The second point to compute the distance to.
	     * @returns {Number} The distance between two points.
	     *
	     * @example
	     * // Returns 4.0, not 2.0
	     * var d = Cesium.Cartesian4.distance(
	     *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
	     *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));
	     */
	    Cartesian4.distanceSquared = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left) || !defined(right)) {
	            throw new DeveloperError('left and right are required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian4.subtract(left, right, distanceScratch);
	        return Cartesian4.magnitudeSquared(distanceScratch);
	    };

	    /**
	     * Computes the normalized form of the supplied Cartesian.
	     *
	     * @param {Cartesian4} cartesian The Cartesian to be normalized.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.normalize = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        var magnitude = Cartesian4.magnitude(cartesian);

	        result.x = cartesian.x / magnitude;
	        result.y = cartesian.y / magnitude;
	        result.z = cartesian.z / magnitude;
	        result.w = cartesian.w / magnitude;
	        return result;
	    };

	    /**
	     * Computes the dot (scalar) product of two Cartesians.
	     *
	     * @param {Cartesian4} left The first Cartesian.
	     * @param {Cartesian4} right The second Cartesian.
	     * @returns {Number} The dot product.
	     */
	    Cartesian4.dot = function(left, right) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        //>>includeEnd('debug');

	        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
	    };

	    /**
	     * Computes the componentwise product of two Cartesians.
	     *
	     * @param {Cartesian4} left The first Cartesian.
	     * @param {Cartesian4} right The second Cartesian.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.multiplyComponents = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x * right.x;
	        result.y = left.y * right.y;
	        result.z = left.z * right.z;
	        result.w = left.w * right.w;
	        return result;
	    };

	    /**
	     * Computes the componentwise sum of two Cartesians.
	     *
	     * @param {Cartesian4} left The first Cartesian.
	     * @param {Cartesian4} right The second Cartesian.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.add = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x + right.x;
	        result.y = left.y + right.y;
	        result.z = left.z + right.z;
	        result.w = left.w + right.w;
	        return result;
	    };

	    /**
	     * Computes the componentwise difference of two Cartesians.
	     *
	     * @param {Cartesian4} left The first Cartesian.
	     * @param {Cartesian4} right The second Cartesian.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.subtract = function(left, right, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required');
	        }
	        if (!defined(right)) {
	            throw new DeveloperError('right is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = left.x - right.x;
	        result.y = left.y - right.y;
	        result.z = left.z - right.z;
	        result.w = left.w - right.w;
	        return result;
	    };

	    /**
	     * Multiplies the provided Cartesian componentwise by the provided scalar.
	     *
	     * @param {Cartesian4} cartesian The Cartesian to be scaled.
	     * @param {Number} scalar The scalar to multiply with.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.multiplyByScalar = function(cartesian, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = cartesian.x * scalar;
	        result.y = cartesian.y * scalar;
	        result.z = cartesian.z * scalar;
	        result.w = cartesian.w * scalar;
	        return result;
	    };

	    /**
	     * Divides the provided Cartesian componentwise by the provided scalar.
	     *
	     * @param {Cartesian4} cartesian The Cartesian to be divided.
	     * @param {Number} scalar The scalar to divide by.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.divideByScalar = function(cartesian, scalar, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (typeof scalar !== 'number') {
	            throw new DeveloperError('scalar is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = cartesian.x / scalar;
	        result.y = cartesian.y / scalar;
	        result.z = cartesian.z / scalar;
	        result.w = cartesian.w / scalar;
	        return result;
	    };

	    /**
	     * Negates the provided Cartesian.
	     *
	     * @param {Cartesian4} cartesian The Cartesian to be negated.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.negate = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = -cartesian.x;
	        result.y = -cartesian.y;
	        result.z = -cartesian.z;
	        result.w = -cartesian.w;
	        return result;
	    };

	    /**
	     * Computes the absolute value of the provided Cartesian.
	     *
	     * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.abs = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required');
	        }
	        //>>includeEnd('debug');

	        result.x = Math.abs(cartesian.x);
	        result.y = Math.abs(cartesian.y);
	        result.z = Math.abs(cartesian.z);
	        result.w = Math.abs(cartesian.w);
	        return result;
	    };

	    var lerpScratch = new Cartesian4();
	    /**
	     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
	     *
	     * @param {Cartesian4} start The value corresponding to t at 0.0.
	     * @param {Cartesian4}end The value corresponding to t at 1.0.
	     * @param {Number} t The point along t at which to interpolate.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter.
	     */
	    Cartesian4.lerp = function(start, end, t, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(start)) {
	            throw new DeveloperError('start is required.');
	        }
	        if (!defined(end)) {
	            throw new DeveloperError('end is required.');
	        }
	        if (typeof t !== 'number') {
	            throw new DeveloperError('t is required and must be a number.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        Cartesian4.multiplyByScalar(end, t, lerpScratch);
	        result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
	        return Cartesian4.add(lerpScratch, result, result);
	    };

	    var mostOrthogonalAxisScratch = new Cartesian4();
	    /**
	     * Returns the axis that is most orthogonal to the provided Cartesian.
	     *
	     * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.
	     * @param {Cartesian4} result The object onto which to store the result.
	     * @returns {Cartesian4} The most orthogonal axis.
	     */
	    Cartesian4.mostOrthogonalAxis = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);
	        Cartesian4.abs(f, f);

	        if (f.x <= f.y) {
	            if (f.x <= f.z) {
	                if (f.x <= f.w) {
	                    result = Cartesian4.clone(Cartesian4.UNIT_X, result);
	                } else {
	                    result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	                }
	            } else if (f.z <= f.w) {
	                result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
	            } else {
	                result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	            }
	        } else if (f.y <= f.z) {
	            if (f.y <= f.w) {
	                result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
	            } else {
	                result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	            }
	        } else if (f.z <= f.w) {
	            result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
	        } else {
	            result = Cartesian4.clone(Cartesian4.UNIT_W, result);
	        }

	        return result;
	    };

	    /**
	     * Compares the provided Cartesians componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartesian4} [left] The first Cartesian.
	     * @param {Cartesian4} [right] The second Cartesian.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Cartesian4.equals = function(left, right) {
	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (left.x === right.x) &&
	                (left.y === right.y) &&
	                (left.z === right.z) &&
	                (left.w === right.w));
	    };

	    /**
	     * @private
	     */
	    Cartesian4.equalsArray = function(cartesian, array, offset) {
	        return cartesian.x === array[offset] &&
	               cartesian.y === array[offset + 1] &&
	               cartesian.z === array[offset + 2] &&
	               cartesian.w === array[offset + 3];
	    };

	    /**
	     * Compares the provided Cartesians componentwise and returns
	     * <code>true</code> if they pass an absolute or relative tolerance test,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartesian4} [left] The first Cartesian.
	     * @param {Cartesian4} [right] The second Cartesian.
	     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
	     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartesian4.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {
	        return (left === right) ||
	               (defined(left) &&
	                defined(right) &&
	                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&
	                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) &&
	                CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) &&
	                CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon));
	    };

	    /**
	     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
	     *
	     * @type {Cartesian4}
	     * @constant
	     */
	    Cartesian4.ZERO = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 0.0));

	    /**
	     * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
	     *
	     * @type {Cartesian4}
	     * @constant
	     */
	    Cartesian4.UNIT_X = freezeObject(new Cartesian4(1.0, 0.0, 0.0, 0.0));

	    /**
	     * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
	     *
	     * @type {Cartesian4}
	     * @constant
	     */
	    Cartesian4.UNIT_Y = freezeObject(new Cartesian4(0.0, 1.0, 0.0, 0.0));

	    /**
	     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
	     *
	     * @type {Cartesian4}
	     * @constant
	     */
	    Cartesian4.UNIT_Z = freezeObject(new Cartesian4(0.0, 0.0, 1.0, 0.0));

	    /**
	     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
	     *
	     * @type {Cartesian4}
	     * @constant
	     */
	    Cartesian4.UNIT_W = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 1.0));

	    /**
	     * Duplicates this Cartesian4 instance.
	     *
	     * @param {Cartesian4} [result] The object onto which to store the result.
	     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
	     */
	    Cartesian4.prototype.clone = function(result) {
	        return Cartesian4.clone(this, result);
	    };

	    /**
	     * Compares this Cartesian against the provided Cartesian componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartesian4} [right] The right hand side Cartesian.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    Cartesian4.prototype.equals = function(right) {
	        return Cartesian4.equals(this, right);
	    };

	    /**
	     * Compares this Cartesian against the provided Cartesian componentwise and returns
	     * <code>true</code> if they pass an absolute or relative tolerance test,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartesian4} [right] The right hand side Cartesian.
	     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
	     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
	     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartesian4.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {
	        return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
	    };

	    /**
	     * Creates a string representing this Cartesian in the format '(x, y)'.
	     *
	     * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.
	     */
	    Cartesian4.prototype.toString = function() {
	        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
	    };

	    return Cartesian4;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    /**
	     * A position defined by longitude, latitude, and height.
	     * @alias Cartographic
	     * @constructor
	     *
	     * @param {Number} [longitude=0.0] The longitude, in radians.
	     * @param {Number} [latitude=0.0] The latitude, in radians.
	     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
	     *
	     * @see Ellipsoid
	     */
	    var Cartographic = function(longitude, latitude, height) {
	        /**
	         * The longitude, in radians.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.longitude = defaultValue(longitude, 0.0);

	        /**
	         * The latitude, in radians.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.latitude = defaultValue(latitude, 0.0);

	        /**
	         * The height, in meters, above the ellipsoid.
	         * @type {Number}
	         * @default 0.0
	         */
	        this.height = defaultValue(height, 0.0);
	    };

	    /**
	     * Creates a new Cartographic instance from longitude and latitude
	     * specified in radians.
	     *
	     * @param {Number} longitude The longitude, in radians.
	     * @param {Number} latitude The latitude, in radians.
	     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
	     */
	    Cartographic.fromRadians = function(longitude, latitude, height, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(longitude)) {
	            throw new DeveloperError('longitude is required.');
	        }
	        if (!defined(latitude)) {
	            throw new DeveloperError('latitude is required.');
	        }
	        //>>includeEnd('debug');

	        height = defaultValue(height, 0.0);

	        if (!defined(result)) {
	            return new Cartographic(longitude, latitude, height);
	        }

	        result.longitude = longitude;
	        result.latitude = latitude;
	        result.height = height;
	        return result;
	    };

	    /**
	     * Creates a new Cartographic instance from longitude and latitude
	     * specified in degrees.  The values in the resulting object will
	     * be in radians.
	     *
	     * @param {Number} longitude The longitude, in degrees.
	     * @param {Number} latitude The latitude, in degrees.
	     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
	     */
	    Cartographic.fromDegrees = function(longitude, latitude, height, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(longitude)) {
	            throw new DeveloperError('longitude is required.');
	        }
	        if (!defined(latitude)) {
	            throw new DeveloperError('latitude is required.');
	        }
	        //>>includeEnd('debug');
	        longitude = CesiumMath.toRadians(longitude);
	        latitude = CesiumMath.toRadians(latitude);

	        return Cartographic.fromRadians(longitude, latitude, height, result);
	    };

	    /**
	     * Duplicates a Cartographic instance.
	     *
	     * @param {Cartographic} cartographic The cartographic to duplicate.
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)
	     */
	    Cartographic.clone = function(cartographic, result) {
	        if (!defined(cartographic)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
	        }
	        result.longitude = cartographic.longitude;
	        result.latitude = cartographic.latitude;
	        result.height = cartographic.height;
	        return result;
	    };

	    /**
	     * Compares the provided cartographics componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartographic} [left] The first cartographic.
	     * @param {Cartographic} [right] The second cartographic.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Cartographic.equals = function(left, right) {
	        return (left === right) ||
	                ((defined(left)) &&
	                 (defined(right)) &&
	                 (left.longitude === right.longitude) &&
	                 (left.latitude === right.latitude) &&
	                 (left.height === right.height));
	    };

	    /**
	     * Compares the provided cartographics componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartographic} [left] The first cartographic.
	     * @param {Cartographic} [right] The second cartographic.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartographic.equalsEpsilon = function(left, right, epsilon) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof epsilon !== 'number') {
	            throw new DeveloperError('epsilon is required and must be a number.');
	        }
	        //>>includeEnd('debug');

	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (Math.abs(left.longitude - right.longitude) <= epsilon) &&
	                (Math.abs(left.latitude - right.latitude) <= epsilon) &&
	                (Math.abs(left.height - right.height) <= epsilon));
	    };

	    /**
	     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
	     *
	     * @type {Cartographic}
	     * @constant
	     */
	    Cartographic.ZERO = freezeObject(new Cartographic(0.0, 0.0, 0.0));

	    /**
	     * Duplicates this instance.
	     *
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
	     */
	    Cartographic.prototype.clone = function(result) {
	        return Cartographic.clone(this, result);
	    };

	    /**
	     * Compares the provided against this cartographic componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Cartographic} [right] The second cartographic.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    Cartographic.prototype.equals = function(right) {
	        return Cartographic.equals(this, right);
	    };

	    /**
	     * Compares the provided against this cartographic componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Cartographic} [right] The second cartographic.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Cartographic.prototype.equalsEpsilon = function(right, epsilon) {
	        return Cartographic.equalsEpsilon(this, right, epsilon);
	    };

	    /**
	     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
	     *
	     * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
	     */
	    Cartographic.prototype.toString = function() {
	        return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';
	    };

	    return Cartographic;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(7),
	        __webpack_require__(16)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        freezeObject,
	        JulianDate) {
	    "use strict";

	    /**
	     * An interval defined by a start and a stop time; optionally including those times as part of the interval.
	     * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.
	     *
	     * @alias TimeInterval
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.
	     * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.
	     * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
	     * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
	     * @param {Object} [options.data] Arbitrary data associated with this interval.
	     *
	     * @example
	     * // Create an instance that spans August 1st, 1980 and is associated
	     * // with a Cartesian position.
	     * var timeInterval = new Cesium.TimeInterval({
	     *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),
	     *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),
	     *     isStartTimeIncluded : true,
	     *     iSStopTimeIncluded : false,
	     *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)
	     * });
	     *
	     * @example
	     * // Create two instances from ISO 8601 intervals with associated numeric data
	     * // then compute their intersection, summing the data they contain.
	     * var left = Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '2000/2010',
	     *     data : 2
	     * });
	     *
	     * var right = Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '1995/2005',
	     *     data : 3
	     * });
	     *
	     * //The result of the below intersection will be an interval equivalent to
	     * //var intersection = Cesium.TimeInterval.fromIso8601({
	     * //  iso8601 : '2000/2005',
	     * //  data : 5
	     * //});
	     * var intersection = new Cesium.TimeInterval();
	     * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {
	     *     return leftData + rightData;
	     * });
	     *
	     * @example
	     * // Check if an interval contains a specific time.
	     * var dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');
	     * var containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);
	     */
	    var TimeInterval = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	        /**
	         * Gets or sets the start time of this interval.
	         * @type {JulianDate}
	         */
	        this.start = defined(options.start) ? JulianDate.clone(options.start) : new JulianDate();

	        /**
	         * Gets or sets the stop time of this interval.
	         * @type {JulianDate}
	         */
	        this.stop = defined(options.stop) ? JulianDate.clone(options.stop) : new JulianDate();

	        /**
	         * Gets or sets the data associated with this interval.
	         * @type {Object}
	         */
	        this.data = options.data;

	        /**
	         * Gets or sets whether or not the start time is included in this interval.
	         * @type {Boolean}
	         * @default true
	         */
	        this.isStartIncluded = defaultValue(options.isStartIncluded, true);

	        /**
	         * Gets or sets whether or not the stop time is included in this interval.
	         * @type {Boolean}
	         * @default true
	         */
	        this.isStopIncluded = defaultValue(options.isStopIncluded, true);
	    };

	    defineProperties(TimeInterval.prototype, {
	        /**
	         * Gets whether or not this interval is empty.
	         * @memberof TimeInterval.prototype
	         * @type {Boolean}
	         * @readonly
	         */
	        isEmpty : {
	            get : function() {
	                var stopComparedToStart = JulianDate.compare(this.stop, this.start);
	                return stopComparedToStart < 0 || (stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded));
	            }
	        }
	    });

	    var scratchInterval = {
	        start : undefined,
	        stop : undefined,
	        isStartIncluded : undefined,
	        isStopIncluded : undefined,
	        data : undefined
	    };

	    /**
	     * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.
	     *
	     * @param {Object} options Object with the following properties:
	     * @param {String} options.iso8601 An ISO 8601 interval.
	     * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
	     * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
	     * @param {Object} [options.data] Arbitrary data associated with this interval.
	     * @param {TimeInterval} [result] An existing instance to use for the result.
	     * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
	     */
	    TimeInterval.fromIso8601 = function(options, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(options)) {
	            throw new DeveloperError('options is required.');
	        }
	        if (!defined(options.iso8601)) {
	            throw new DeveloperError('options.iso8601 is required.');
	        }
	        //>>includeEnd('debug');

	        var dates = options.iso8601.split('/');
	        var start = JulianDate.fromIso8601(dates[0]);
	        var stop = JulianDate.fromIso8601(dates[1]);
	        var isStartIncluded = defaultValue(options.isStartIncluded, true);
	        var isStopIncluded = defaultValue(options.isStopIncluded, true);
	        var data = options.data;

	        if (!defined(result)) {
	            scratchInterval.start = start;
	            scratchInterval.stop = stop;
	            scratchInterval.isStartIncluded = isStartIncluded;
	            scratchInterval.isStopIncluded = isStopIncluded;
	            scratchInterval.data = data;
	            return new TimeInterval(scratchInterval);
	        }

	        result.start = start;
	        result.stop = stop;
	        result.isStartIncluded = isStartIncluded;
	        result.isStopIncluded = isStopIncluded;
	        result.data = data;
	        return result;
	    };

	    /**
	     * Creates an ISO8601 representation of the provided interval.
	     *
	     * @param {TimeInterval} timeInterval The interval to be converted.
	     * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
	     * @returns {String} The ISO8601 representation of the provided interval.
	     */
	    TimeInterval.toIso8601 = function(timeInterval, precision) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(timeInterval)) {
	            throw new DeveloperError('timeInterval is required.');
	        }
	        //>>includeEnd('debug');

	        return JulianDate.toIso8601(timeInterval.start, precision) + '/' + JulianDate.toIso8601(timeInterval.stop, precision);
	    };

	    /**
	     * Duplicates the provided instance.
	     *
	     * @param {TimeInterval} [timeInterval] The instance to clone.
	     * @param {TimeInterval} [result] An existing instance to use for the result.
	     * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
	     */
	    TimeInterval.clone = function(timeInterval, result) {
	        if (!defined(timeInterval)) {
	            return undefined;
	        }
	        if (!defined(result)) {
	            return new TimeInterval(timeInterval);
	        }
	        result.start = timeInterval.start;
	        result.stop = timeInterval.stop;
	        result.isStartIncluded = timeInterval.isStartIncluded;
	        result.isStopIncluded = timeInterval.isStopIncluded;
	        result.data = timeInterval.data;
	        return result;
	    };

	    /**
	     * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {TimeInterval} [left] The first instance.
	     * @param {TimeInterval} [right] The second instance.
	     * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
	     * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
	     */
	    TimeInterval.equals = function(left, right, dataComparer) {
	        return left === right ||
	               defined(left) && defined(right) &&
	               (left.isEmpty && right.isEmpty ||
	                left.isStartIncluded === right.isStartIncluded &&
	                left.isStopIncluded === right.isStopIncluded &&
	                JulianDate.equals(left.start, right.start) &&
	                JulianDate.equals(left.stop, right.stop) &&
	                (left.data === right.data || (defined(dataComparer) && dataComparer(left.data, right.data))));
	    };

	    /**
	     * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
	     * each other.  That is, in order for the dates to be considered equal (and for
	     * this function to return <code>true</code>), the absolute value of the difference between them, in
	     * seconds, must be less than <code>epsilon</code>.
	     *
	     * @param {TimeInterval} [left] The first instance.
	     * @param {TimeInterval} [right] The second instance.
	     * @param {Number} epsilon The maximum number of seconds that should separate the two instances.
	     * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
	     * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
	     */
	    TimeInterval.equalsEpsilon = function(left, right, epsilon, dataComparer) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof epsilon !== 'number') {
	            throw new DeveloperError('epsilon is required and must be a number.');
	        }
	        //>>includeEnd('debug');

	        return left === right ||
	               defined(left) && defined(right) &&
	               (left.isEmpty && right.isEmpty ||
	                left.isStartIncluded === right.isStartIncluded &&
	                left.isStopIncluded === right.isStopIncluded &&
	                JulianDate.equalsEpsilon(left.start, right.start, epsilon) &&
	                JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) &&
	                (left.data === right.data || (defined(dataComparer) && dataComparer(left.data, right.data))));
	    };

	    /**
	     * Computes the intersection of two intervals, optionally merging their data.
	     *
	     * @param {TimeInterval} left The first interval.
	     * @param {TimeInterval} [right] The second interval.
	     * @param {TimeInterval} result An existing instance to use for the result.
	     * @param {TimeInterval~MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
	     * @returns {TimeInterval} The modified result parameter.
	     */
	    TimeInterval.intersect = function(left, right, result, mergeCallback) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(left)) {
	            throw new DeveloperError('left is required.');
	        }
	        if (!defined(result)) {
	            throw new DeveloperError('result is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(right)) {
	            return TimeInterval.clone(TimeInterval.EMPTY, result);
	        }

	        var leftStart = left.start;
	        var leftStop = left.stop;

	        var rightStart = right.start;
	        var rightStop = right.stop;

	        var intersectsStartRight = JulianDate.greaterThanOrEquals(rightStart, leftStart) && JulianDate.greaterThanOrEquals(leftStop, rightStart);
	        var intersectsStartLeft = !intersectsStartRight && JulianDate.lessThanOrEquals(rightStart, leftStart) && JulianDate.lessThanOrEquals(leftStart, rightStop);

	        if (!intersectsStartRight && !intersectsStartLeft) {
	            return TimeInterval.clone(TimeInterval.EMPTY, result);
	        }

	        var leftIsStartIncluded = left.isStartIncluded;
	        var leftIsStopIncluded = left.isStopIncluded;
	        var rightIsStartIncluded = right.isStartIncluded;
	        var rightIsStopIncluded = right.isStopIncluded;
	        var leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);

	        result.start = intersectsStartRight ? rightStart : leftStart;
	        result.isStartIncluded = (leftIsStartIncluded && rightIsStartIncluded) || (!JulianDate.equals(rightStart, leftStart) && ((intersectsStartRight && rightIsStartIncluded) || (intersectsStartLeft && leftIsStartIncluded)));
	        result.stop = leftLessThanRight ? leftStop : rightStop;
	        result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : (leftIsStopIncluded && rightIsStopIncluded) || (!JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded);
	        result.data = defined(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;
	        return result;
	    };

	    /**
	     * Checks if the specified date is inside the provided interval.
	     *
	     * @param {TimeInterval} timeInterval The interval.
	     * @param {JulianDate} julianDate The date to check.
	     * @returns {Boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.
	     */
	    TimeInterval.contains = function(timeInterval, julianDate) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(timeInterval)) {
	            throw new DeveloperError('timeInterval is required.');
	        }
	        if (!defined(julianDate)) {
	            throw new DeveloperError('julianDate is required.');
	        }
	        //>>includeEnd('debug');

	        if (timeInterval.isEmpty) {
	            return false;
	        }

	        var startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);
	        if (startComparedToDate === 0) {
	            return timeInterval.isStartIncluded;
	        }

	        var dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);
	        if (dateComparedToStop === 0) {
	            return timeInterval.isStopIncluded;
	        }

	        return startComparedToDate < 0 && dateComparedToStop < 0;
	    };

	    /**
	     * Duplicates this instance.
	     *
	     * @param {TimeInterval} [result] An existing instance to use for the result.
	     * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
	     */
	    TimeInterval.prototype.clone = function(result) {
	        return TimeInterval.clone(this, result);
	    };

	    /**
	     * Compares this instance against the provided instance componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {TimeInterval} [right] The right hand side interval.
	     * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    TimeInterval.prototype.equals = function(right, dataComparer) {
	        return TimeInterval.equals(this, right, dataComparer);
	    };

	    /**
	     * Compares this instance against the provided instance componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {TimeInterval} [right] The right hand side interval.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
	     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
	     */
	    TimeInterval.prototype.equalsEpsilon = function(right, epsilon, dataComparer) {
	        return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);
	    };

	    /**
	     * Creates a string representing this TimeInterval in ISO8601 format.
	     *
	     * @returns {String} A string representing this TimeInterval in ISO8601 format.
	     */
	    TimeInterval.prototype.toString = function() {
	        return TimeInterval.toIso8601(this);
	    };

	    /**
	     * An immutable empty interval.
	     *
	     * @type {TimeInterval}
	     * @constant
	     */
	    TimeInterval.EMPTY = freezeObject(new TimeInterval({
	        start : new JulianDate(),
	        stop : new JulianDate(),
	        isStartIncluded : false,
	        isStopIncluded : false
	    }));

	    /**
	     * Function interface for merging interval data.
	     * @callback TimeInterval~MergeCallback
	     *
	     * @param {Object} leftData The first data instance.
	     * @param {Object} rightData The second data instance.
	     * @returns {Object} The result of merging the two data instances.
	     */

	    /**
	     * Function interface for comparing interval data.
	     * @callback TimeInterval~DataComparer
	     * @param {Object} leftData The first data instance.
	     * @param {Object} rightData The second data instance.
	     * @returns {Boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.
	     */

	    return TimeInterval;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(45),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(16),
	        __webpack_require__(53)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        binarySearch,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        JulianDate,
	        TimeInterval) {
	    "use strict";

	    function compareIntervalStartTimes(left, right) {
	        return JulianDate.compare(left.start, right.start);
	    }

	    /**
	     * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.
	     * @alias TimeIntervalCollection
	     * @constructor
	     *
	     * @param {TimeInterval[]} [intervals] An array of intervals to add to the collection.
	     */
	    var TimeIntervalCollection = function(intervals) {
	        this._intervals = [];
	        this._changedEvent = new Event();

	        if (defined(intervals)) {
	            var length = intervals.length;
	            for (var i = 0; i < length; i++) {
	                this.addInterval(intervals[i]);
	            }
	        }
	    };

	    defineProperties(TimeIntervalCollection.prototype, {
	        /**
	         * Gets an event that is raised whenever the collection of intervals change.
	         * @memberof TimeIntervalCollection.prototype
	         * @type {Event}
	         * @readonly
	         */
	        changedEvent : {
	            get : function() {
	                return this._changedEvent;
	            }
	        },

	        /**
	         * Gets the start time of the collection.
	         * @memberof TimeIntervalCollection.prototype
	         * @type {JulianDate}
	         * @readonly
	         */
	        start : {
	            get : function() {
	                var intervals = this._intervals;
	                return intervals.length === 0 ? undefined : intervals[0].start;
	            }
	        },

	        /**
	         * Gets whether or not the start time is included in the collection.
	         * @memberof TimeIntervalCollection.prototype
	         * @type {Boolean}
	         * @readonly
	         */
	        isStartIncluded : {
	            get : function() {
	                var intervals = this._intervals;
	                return intervals.length === 0 ? false : intervals[0].isStartIncluded;
	            }
	        },

	        /**
	         * Gets the stop time of the collection.
	         * @memberof TimeIntervalCollection.prototype
	         * @type {JulianDate}
	         * @readonly
	         */
	        stop : {
	            get : function() {
	                var intervals = this._intervals;
	                var length = intervals.length;
	                return length === 0 ? undefined : intervals[length - 1].stop;
	            }
	        },

	        /**
	         * Gets whether or not the stop time is included in the collection.
	         * @memberof TimeIntervalCollection.prototype
	         * @type {Boolean}
	         * @readonly
	         */
	        isStopIncluded : {
	            get : function() {
	                var intervals = this._intervals;
	                var length = intervals.length;
	                return length === 0 ? false : intervals[length - 1].isStopIncluded;
	            }
	        },

	        /**
	         * Gets the number of intervals in the collection.
	         * @memberof TimeIntervalCollection.prototype
	         * @type {Number}
	         * @readonly
	         */
	        length : {
	            get : function() {
	                return this._intervals.length;
	            }
	        },

	        /**
	         * Gets whether or not the collection is empty.
	         * @memberof TimeIntervalCollection.prototype
	         * @type {Boolean}
	         * @readonly
	         */
	        isEmpty : {
	            get : function() {
	                return this._intervals.length === 0;
	            }
	        }
	    });

	    /**
	     * Compares this instance against the provided instance componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {TimeIntervalCollection} [right] The right hand side collection.
	     * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    TimeIntervalCollection.prototype.equals = function(right, dataComparer) {
	        if (this === right) {
	            return true;
	        }
	        if (!(right instanceof TimeIntervalCollection)) {
	            return false;
	        }
	        var intervals = this._intervals;
	        var rightIntervals = right._intervals;
	        var length = intervals.length;
	        if (length !== rightIntervals.length) {
	            return false;
	        }
	        for (var i = 0; i < length; i++) {
	            if (!TimeInterval.equals(intervals[i], rightIntervals[i], dataComparer)) {
	                return false;
	            }
	        }
	        return true;
	    };

	    /**
	     * Gets the interval at the specified index.
	     *
	     * @param {Number} index The index of the interval to retrieve.
	     * @returns {TimeInterval} The interval at the specified index, or <code>undefined</code> if no interval exists as that index.
	     */
	    TimeIntervalCollection.prototype.get = function(index) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(index)) {
	            throw new DeveloperError('index is required.');
	        }
	        //>>includeEnd('debug');

	        return this._intervals[index];
	    };

	    /**
	     * Removes all intervals from the collection.
	     */
	    TimeIntervalCollection.prototype.removeAll = function() {
	        if (this._intervals.length > 0) {
	            this._intervals.length = 0;
	            this._changedEvent.raiseEvent(this);
	        }
	    };

	    /**
	     * Finds and returns the interval that contains the specified date.
	     *
	     * @param {JulianDate} date The date to search for.
	     * @returns The interval containing the specified date, <code>undefined</code> if no such interval exists.
	     */
	    TimeIntervalCollection.prototype.findIntervalContainingDate = function(date) {
	        var index = this.indexOf(date);
	        return index >= 0 ? this._intervals[index] : undefined;
	    };

	    /**
	     * Finds and returns the data for the interval that contains the specified date.
	     *
	     * @param {JulianDate} date The date to search for.
	     * @returns The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.
	     */
	    TimeIntervalCollection.prototype.findDataForIntervalContainingDate = function(date) {
	        var index = this.indexOf(date);
	        return index >= 0 ? this._intervals[index].data : undefined;
	    };

	    /**
	     * Checks if the specified date is inside this collection.
	     *
	     * @param {JulianDate} julianDate The date to check.
	     * @returns {Boolean} <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.
	     */
	    TimeIntervalCollection.prototype.contains = function(date) {
	        return this.indexOf(date) >= 0;
	    };

	    var indexOfScratch = new TimeInterval();

	    /**
	     * Finds and returns the index of the interval in the collection that contains the specified date.
	     *
	     * @param {JulianDate} date The date to search for.
	     * @returns The index of the interval that contains the specified date, if no such interval exists,
	     * it returns a negative number which is the bitwise complement of the index of the next interval that
	     * starts after the date, or if no interval starts after the specified date, the bitwise complement of
	     * the length of the collection.
	     */
	    TimeIntervalCollection.prototype.indexOf = function(date) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(date)) {
	            throw new DeveloperError('date is required');
	        }
	        //>>includeEnd('debug');

	        var intervals = this._intervals;
	        indexOfScratch.start = date;
	        indexOfScratch.stop = date;
	        var index = binarySearch(intervals, indexOfScratch, compareIntervalStartTimes);
	        if (index >= 0) {
	            if (intervals[index].isStartIncluded) {
	                return index;
	            }

	            if (index > 0 && intervals[index - 1].stop.equals(date) && intervals[index - 1].isStopIncluded) {
	                return index - 1;
	            }
	            return ~index;
	        }

	        index = ~index;
	        if (index > 0 && (index - 1) < intervals.length && TimeInterval.contains(intervals[index - 1], date)) {
	            return index - 1;
	        }
	        return ~index;
	    };

	    /**
	     * Returns the first interval in the collection that matches the specified parameters.
	     * All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {JulianDate} [options.start] The start time of the interval.
	     * @param {JulianDate} [options.stop] The stop time of the interval.
	     * @param {Boolean} [options.isStartIncluded] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
	     * @param {Boolean} [options.isStopIncluded] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
	     * @returns The first interval in the collection that matches the specified parameters.
	     */
	    TimeIntervalCollection.prototype.findInterval = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
	        var start = options.start;
	        var stop = options.stop;
	        var isStartIncluded = options.isStartIncluded;
	        var isStopIncluded = options.isStopIncluded;

	        var intervals = this._intervals;
	        for (var i = 0, len = intervals.length; i < len; i++) {
	            var interval = intervals[i];
	            if ((!defined(start) || interval.start.equals(start)) &&
	                (!defined(stop) || interval.stop.equals(stop)) &&
	                (!defined(isStartIncluded) || interval.isStartIncluded === isStartIncluded) &&
	                (!defined(isStopIncluded) || interval.isStopIncluded === isStopIncluded)) {
	                return intervals[i];
	            }
	        }
	        return undefined;
	    };

	    /**
	     * Adds an interval to the collection, merging intervals that contain the same data and
	     * splitting intervals of different data as needed in order to maintain a non-overlapping collection.
	     * The data in the new interval takes precedence over any existing intervals in the collection.
	     *
	     * @param {TimeInterval} interval The interval to add.
	     * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
	     */
	    TimeIntervalCollection.prototype.addInterval = function(interval, dataComparer) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(interval)) {
	            throw new DeveloperError("interval is required");
	        }
	        //>>includeEnd('debug');

	        if (interval.isEmpty) {
	            return;
	        }

	        var comparison;
	        var index;
	        var intervals = this._intervals;

	        // Handle the common case quickly: we're adding a new interval which is after all existing intervals.
	        if (intervals.length === 0 || JulianDate.greaterThan(interval.start, intervals[intervals.length - 1].stop)) {
	            intervals.push(interval);
	            this._changedEvent.raiseEvent(this);
	            return;
	        }

	        // Keep the list sorted by the start date
	        index = binarySearch(intervals, interval, compareIntervalStartTimes);
	        if (index < 0) {
	            index = ~index;
	        } else {
	            // interval's start date exactly equals the start date of at least one interval in the collection.
	            // It could actually equal the start date of two intervals if one of them does not actually
	            // include the date.  In that case, the binary search could have found either.  We need to
	            // look at the surrounding intervals and their IsStartIncluded properties in order to make sure
	            // we're working with the correct interval.
	            if (index > 0 && interval.isStartIncluded && intervals[index - 1].isStartIncluded && intervals[index - 1].start.equals(interval.start)) {
	                --index;
	            } else if (index < intervals.length && !interval.isStartIncluded && intervals[index].isStartIncluded && intervals[index].start.equals(interval.start)) {
	                ++index;
	            }
	        }

	        if (index > 0) {
	            // Not the first thing in the list, so see if the interval before this one
	            // overlaps this one.
	            comparison = JulianDate.compare(intervals[index - 1].stop, interval.start);
	            if (comparison > 0 || (comparison === 0 && (intervals[index - 1].isStopIncluded || interval.isStartIncluded))) {
	                // There is an overlap
	                if (defined(dataComparer) ? dataComparer(intervals[index - 1].data, interval.data) : (intervals[index - 1].data === interval.data)) {
	                    // Overlapping intervals have the same data, so combine them
	                    if (JulianDate.greaterThan(interval.stop, intervals[index - 1].stop)) {
	                        interval = new TimeInterval({
	                            start : intervals[index - 1].start,
	                            stop : interval.stop,
	                            isStartIncluded : intervals[index - 1].isStartIncluded,
	                            isStopIncluded : interval.isStopIncluded,
	                            data : interval.data
	                        });
	                    } else {
	                        interval = new TimeInterval({
	                            start : intervals[index - 1].start,
	                            stop : intervals[index - 1].stop,
	                            isStartIncluded : intervals[index - 1].isStartIncluded,
	                            isStopIncluded : intervals[index - 1].isStopIncluded || (interval.stop.equals(intervals[index - 1].stop) && interval.isStopIncluded),
	                            data : interval.data
	                        });
	                    }
	                    intervals.splice(index - 1, 1);
	                    --index;
	                } else {
	                    // Overlapping intervals have different data.  The new interval
	                    // being added 'wins' so truncate the previous interval.
	                    // If the existing interval extends past the end of the new one,
	                    // split the existing interval into two intervals.
	                    comparison = JulianDate.compare(intervals[index - 1].stop, interval.stop);
	                    if (comparison > 0 || (comparison === 0 && intervals[index - 1].isStopIncluded && !interval.isStopIncluded)) {
	                        intervals.splice(index - 1, 1, new TimeInterval({
	                            start : intervals[index - 1].start,
	                            stop : interval.start,
	                            isStartIncluded : intervals[index - 1].isStartIncluded,
	                            isStopIncluded : !interval.isStartIncluded,
	                            data : intervals[index - 1].data
	                        }), new TimeInterval({
	                            start : interval.stop,
	                            stop : intervals[index - 1].stop,
	                            isStartIncluded : !interval.isStopIncluded,
	                            isStopIncluded : intervals[index - 1].isStopIncluded,
	                            data : intervals[index - 1].data
	                        }));
	                    } else {
	                        intervals[index - 1] = new TimeInterval({
	                            start : intervals[index - 1].start,
	                            stop : interval.start,
	                            isStartIncluded : intervals[index - 1].isStartIncluded,
	                            isStopIncluded : !interval.isStartIncluded,
	                            data : intervals[index - 1].data
	                        });
	                    }
	                }
	            }
	        }

	        while (index < intervals.length) {
	            // Not the last thing in the list, so see if the intervals after this one overlap this one.
	            comparison = JulianDate.compare(interval.stop, intervals[index].start);
	            if (comparison > 0 || (comparison === 0 && (interval.isStopIncluded || intervals[index].isStartIncluded))) {
	                // There is an overlap
	                if (defined(dataComparer) ? dataComparer(intervals[index].data, interval.data) : intervals[index].data === interval.data) {
	                    // Overlapping intervals have the same data, so combine them
	                    interval = new TimeInterval({
	                        start : interval.start,
	                        stop : JulianDate.greaterThan(intervals[index].stop, interval.stop) ? intervals[index].stop : interval.stop,
	                        isStartIncluded : interval.isStartIncluded,
	                        isStopIncluded : JulianDate.greaterThan(intervals[index].stop, interval.stop) ? intervals[index].isStopIncluded : interval.isStopIncluded,
	                        data : interval.data
	                    });
	                    intervals.splice(index, 1);
	                } else {
	                    // Overlapping intervals have different data.  The new interval
	                    // being added 'wins' so truncate the next interval.
	                    intervals[index] = new TimeInterval({
	                        start : interval.stop,
	                        stop : intervals[index].stop,
	                        isStartIncluded : !interval.isStopIncluded,
	                        isStopIncluded : intervals[index].isStopIncluded,
	                        data : intervals[index].data
	                    });
	                    if (intervals[index].isEmpty) {
	                        intervals.splice(index, 1);
	                    } else {
	                        // Found a partial span, so it is not possible for the next
	                        // interval to be spanned at all.  Stop looking.
	                        break;
	                    }
	                }
	            } else {
	                // Found the last one we're spanning, so stop looking.
	                break;
	            }
	        }

	        // Add the new interval
	        intervals.splice(index, 0, interval);
	        this._changedEvent.raiseEvent(this);
	    };

	    /**
	     * Removes the specified interval from this interval collection, creating a hole over the specified interval.
	     * The data property of the input interval is ignored.
	     *
	     * @param {TimeInterval} interval The interval to remove.
	     * @returns <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.
	     */
	    TimeIntervalCollection.prototype.removeInterval = function(interval) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(interval)) {
	            throw new DeveloperError("interval is required");
	        }
	        //>>includeEnd('debug');

	        if (interval.isEmpty) {
	            return false;
	        }

	        var result = false;
	        var intervals = this._intervals;

	        var index = binarySearch(intervals, interval, compareIntervalStartTimes);
	        if (index < 0) {
	            index = ~index;
	        }

	        var intervalStart = interval.start;
	        var intervalStop = interval.stop;
	        var intervalIsStartIncluded = interval.isStartIncluded;
	        var intervalIsStopIncluded = interval.isStopIncluded;

	        // Check for truncation of the end of the previous interval.
	        if (index > 0) {
	            var indexMinus1 = intervals[index - 1];
	            var indexMinus1Stop = indexMinus1.stop;
	            if (JulianDate.greaterThan(indexMinus1Stop, intervalStart) ||
	                (TimeInterval.equals(indexMinus1Stop, intervalStart) &&
	                 indexMinus1.isStopIncluded && intervalIsStartIncluded)) {
	                result = true;

	                if (JulianDate.greaterThan(indexMinus1Stop, intervalStop) ||
	                    (indexMinus1.isStopIncluded && !intervalIsStopIncluded && TimeInterval.equals(indexMinus1Stop, intervalStop))) {
	                    // Break the existing interval into two pieces
	                    intervals.splice(index, 0, new TimeInterval({
	                        start : intervalStop,
	                        stop : indexMinus1Stop,
	                        isStartIncluded : !intervalIsStopIncluded,
	                        isStopIncluded : indexMinus1.isStopIncluded,
	                        data : indexMinus1.data
	                    }));
	                }
	                intervals[index - 1] = new TimeInterval({
	                    start : indexMinus1.start,
	                    stop : intervalStart,
	                    isStartIncluded : indexMinus1.isStartIncluded,
	                    isStopIncluded : !intervalIsStartIncluded,
	                    data : indexMinus1.data
	                });
	            }
	        }

	        // Check if the Start of the current interval should remain because interval.start is the same but
	        // it is not included.
	        var indexInterval = intervals[index];
	        if (index < intervals.length &&
	            !intervalIsStartIncluded &&
	            indexInterval.isStartIncluded &&
	            intervalStart.equals(indexInterval.start)) {
	            result = true;

	            intervals.splice(index, 0, new TimeInterval({
	                start : indexInterval.start,
	                stop : indexInterval.start,
	                isStartIncluded : true,
	                isStopIncluded : true,
	                data : indexInterval.data
	            }));
	            ++index;
	            indexInterval = intervals[index];
	        }

	        // Remove any intervals that are completely overlapped by the input interval.
	        while (index < intervals.length &&
	                JulianDate.greaterThan(intervalStop, indexInterval.stop)) {
	            result = true;
	            intervals.splice(index, 1);
	        }

	        // Check for the case where the input interval ends on the same date
	        // as an existing interval.
	        if (index < intervals.length && intervalStop.equals(indexInterval.stop)) {
	            result = true;

	            if (!intervalIsStopIncluded && indexInterval.isStopIncluded) {
	                // Last point of interval should remain because the stop date is included in
	                // the existing interval but is not included in the input interval.
	                if ((index + 1) < intervals.length && intervals[index + 1].start.equals(intervalStop) && indexInterval.data === intervals[index + 1].data) {
	                    // Combine single point with the next interval
	                    intervals.splice(index, 1);
	                    indexInterval = new TimeInterval({
	                        start : indexInterval.start,
	                        stop : indexInterval.stop,
	                        isStartIncluded : true,
	                        isStopIncluded : indexInterval.isStopIncluded,
	                        data : indexInterval.data
	                    });
	                } else {
	                    indexInterval = new TimeInterval({
	                        start : intervalStop,
	                        stop : intervalStop,
	                        isStartIncluded : true,
	                        isStopIncluded : true,
	                        data : indexInterval.data
	                    });
	                }
	                intervals[index] = indexInterval;
	            } else {
	                // Interval is completely overlapped
	                intervals.splice(index, 1);
	            }
	        }

	        // Truncate any partially-overlapped intervals.
	        if (index < intervals.length &&
	            (JulianDate.greaterThan(intervalStop, indexInterval.start) ||
	             (intervalStop.equals(indexInterval.start) &&
	              intervalIsStopIncluded &&
	              indexInterval.isStartIncluded))) {
	            result = true;
	            intervals[index] = new TimeInterval({
	                start : intervalStop,
	                stop : indexInterval.stop,
	                isStartIncluded : !intervalIsStopIncluded,
	                isStopIncluded : indexInterval.isStopIncluded,
	                data : indexInterval.data
	            });
	        }

	        if (result) {
	            this._changedEvent.raiseEvent(this);
	        }

	        return result;
	    };

	    /**
	     * Creates a new instance that is the intersection of this collection and the provided collection.
	     *
	     * @param {TimeIntervalCollection} other The collection to intersect with.
	     * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
	     * @param {TimeInterval~MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
	     * @returns A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
	     */
	    TimeIntervalCollection.prototype.intersect = function(other, dataComparer, mergeCallback) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(other)) {
	            throw new DeveloperError('other is required.');
	        }
	        //>>includeEnd('debug');

	        var left = 0;
	        var right = 0;
	        var result = new TimeIntervalCollection();
	        var intervals = this._intervals;
	        var otherIntervals = other._intervals;

	        while (left < intervals.length && right < otherIntervals.length) {
	            var leftInterval = intervals[left];
	            var rightInterval = otherIntervals[right];
	            if (JulianDate.lessThan(leftInterval.stop, rightInterval.start)) {
	                ++left;
	            } else if (JulianDate.lessThan(rightInterval.stop, leftInterval.start)) {
	                ++right;
	            } else {
	                // The following will return an intersection whose data is 'merged' if the callback is defined
	                if (defined(mergeCallback) ||
	                   ((defined(dataComparer) && dataComparer(leftInterval.data, rightInterval.data)) ||
	                    (!defined(dataComparer) && rightInterval.data === leftInterval.data))) {

	                    var intersection = TimeInterval.intersect(leftInterval, rightInterval, new TimeInterval(), mergeCallback);
	                    if (!intersection.isEmpty) {
	                        // Since we start with an empty collection for 'result', and there are no overlapping intervals in 'this' (as a rule),
	                        // the 'intersection' will never overlap with a previous interval in 'result'.  So, no need to do any additional 'merging'.
	                        result.addInterval(intersection, dataComparer);
	                    }
	                }

	                if (JulianDate.lessThan(leftInterval.stop, rightInterval.stop) ||
	                    (leftInterval.stop.equals(rightInterval.stop) &&
	                     !leftInterval.isStopIncluded &&
	                     rightInterval.isStopIncluded)) {
	                    ++left;
	                } else {
	                    ++right;
	                }
	            }
	        }
	        return result;
	    };

	    return TimeIntervalCollection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(47),
	        __webpack_require__(34),
	        __webpack_require__(12),
	        __webpack_require__(51),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(162),
	        __webpack_require__(117),
	        __webpack_require__(43),
	        __webpack_require__(166),
	        __webpack_require__(121),
	        __webpack_require__(16),
	        __webpack_require__(11),
	        __webpack_require__(29),
	        __webpack_require__(44),
	        __webpack_require__(35),
	        __webpack_require__(77)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        when,
	        Cartesian2,
	        Cartesian3,
	        Cartesian4,
	        defaultValue,
	        defined,
	        DeveloperError,
	        EarthOrientationParameters,
	        EarthOrientationParametersSample,
	        Ellipsoid,
	        Iau2006XysData,
	        Iau2006XysSample,
	        JulianDate,
	        CesiumMath,
	        Matrix3,
	        Matrix4,
	        Quaternion,
	        TimeConstants) {
	    "use strict";

	    /**
	     * Contains functions for transforming positions to various reference frames.
	     *
	     * @namespace
	     * @alias Transforms
	     */
	    var Transforms = {};

	    var eastNorthUpToFixedFrameNormal = new Cartesian3();
	    var eastNorthUpToFixedFrameTangent = new Cartesian3();
	    var eastNorthUpToFixedFrameBitangent = new Cartesian3();

	    /**
	     * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
	     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	     * The local axes are defined as:
	     * <ul>
	     * <li>The <code>x</code> axis points in the local east direction.</li>
	     * <li>The <code>y</code> axis points in the local north direction.</li>
	     * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
	     * </ul>
	     *
	     * @param {Cartesian3} origin The center point of the local reference frame.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
	     * @param {Matrix4} [result] The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	     *
	     * @example
	     * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
	     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	     * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
	     */
	    Transforms.eastNorthUpToFixedFrame = function(origin, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(origin)) {
	            throw new DeveloperError('origin is required.');
	        }
	        //>>includeEnd('debug');

	        // If x and y are zero, assume origin is at a pole, which is a special case.
	        if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&
	            CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
	            var sign = CesiumMath.sign(origin.z);
	            if (!defined(result)) {
	                return new Matrix4(
	                        0.0, -sign,  0.0, origin.x,
	                        1.0,   0.0,  0.0, origin.y,
	                        0.0,   0.0, sign, origin.z,
	                        0.0,   0.0,  0.0, 1.0);
	            }
	            result[0] = 0.0;
	            result[1] = 1.0;
	            result[2] = 0.0;
	            result[3] = 0.0;
	            result[4] = -sign;
	            result[5] = 0.0;
	            result[6] = 0.0;
	            result[7] = 0.0;
	            result[8] = 0.0;
	            result[9] = 0.0;
	            result[10] = sign;
	            result[11] = 0.0;
	            result[12] = origin.x;
	            result[13] = origin.y;
	            result[14] = origin.z;
	            result[15] = 1.0;
	            return result;
	        }

	        var normal = eastNorthUpToFixedFrameNormal;
	        var tangent  = eastNorthUpToFixedFrameTangent;
	        var bitangent = eastNorthUpToFixedFrameBitangent;

	        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	        ellipsoid.geodeticSurfaceNormal(origin, normal);

	        tangent.x = -origin.y;
	        tangent.y = origin.x;
	        tangent.z = 0.0;
	        Cartesian3.normalize(tangent, tangent);

	        Cartesian3.cross(normal, tangent, bitangent);

	        if (!defined(result)) {
	            return new Matrix4(
	                    tangent.x, bitangent.x, normal.x, origin.x,
	                    tangent.y, bitangent.y, normal.y, origin.y,
	                    tangent.z, bitangent.z, normal.z, origin.z,
	                    0.0,       0.0,         0.0,      1.0);
	        }
	        result[0] = tangent.x;
	        result[1] = tangent.y;
	        result[2] = tangent.z;
	        result[3] = 0.0;
	        result[4] = bitangent.x;
	        result[5] = bitangent.y;
	        result[6] = bitangent.z;
	        result[7] = 0.0;
	        result[8] = normal.x;
	        result[9] = normal.y;
	        result[10] = normal.z;
	        result[11] = 0.0;
	        result[12] = origin.x;
	        result[13] = origin.y;
	        result[14] = origin.z;
	        result[15] = 1.0;
	        return result;
	    };

	    var northEastDownToFixedFrameNormal = new Cartesian3();
	    var northEastDownToFixedFrameTangent = new Cartesian3();
	    var northEastDownToFixedFrameBitangent = new Cartesian3();

	    /**
	     * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
	     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	     * The local axes are defined as:
	     * <ul>
	     * <li>The <code>x</code> axis points in the local north direction.</li>
	     * <li>The <code>y</code> axis points in the local east direction.</li>
	     * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
	     * </ul>
	     *
	     * @param {Cartesian3} origin The center point of the local reference frame.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
	     * @param {Matrix4} [result] The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	     *
	     * @example
	     * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
	     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	     * var transform = Cesium.Transforms.northEastDownToFixedFrame(center);
	     */
	    Transforms.northEastDownToFixedFrame = function(origin, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(origin)) {
	            throw new DeveloperError('origin is required.');
	        }
	        //>>includeEnd('debug');

	        if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&
	            CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
	            // The poles are special cases.  If x and y are zero, assume origin is at a pole.
	            var sign = CesiumMath.sign(origin.z);
	            if (!defined(result)) {
	                return new Matrix4(
	                  -sign, 0.0,   0.0, origin.x,
	                    0.0, 1.0,   0.0, origin.y,
	                    0.0, 0.0, -sign, origin.z,
	                    0.0, 0.0,   0.0, 1.0);
	            }
	            result[0] = -sign;
	            result[1] = 0.0;
	            result[2] = 0.0;
	            result[3] = 0.0;
	            result[4] = 0.0;
	            result[5] = 1.0;
	            result[6] = 0.0;
	            result[7] = 0.0;
	            result[8] = 0.0;
	            result[9] = 0.0;
	            result[10] = -sign;
	            result[11] = 0.0;
	            result[12] = origin.x;
	            result[13] = origin.y;
	            result[14] = origin.z;
	            result[15] = 1.0;
	            return result;
	        }

	        var normal = northEastDownToFixedFrameNormal;
	        var tangent = northEastDownToFixedFrameTangent;
	        var bitangent = northEastDownToFixedFrameBitangent;

	        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	        ellipsoid.geodeticSurfaceNormal(origin, normal);

	        tangent.x = -origin.y;
	        tangent.y = origin.x;
	        tangent.z = 0.0;
	        Cartesian3.normalize(tangent, tangent);

	        Cartesian3.cross(normal, tangent, bitangent);

	        if (!defined(result)) {
	            return new Matrix4(
	                    bitangent.x, tangent.x, -normal.x, origin.x,
	                    bitangent.y, tangent.y, -normal.y, origin.y,
	                    bitangent.z, tangent.z, -normal.z, origin.z,
	                    0.0,       0.0,         0.0,      1.0);
	        }
	        result[0] = bitangent.x;
	        result[1] = bitangent.y;
	        result[2] = bitangent.z;
	        result[3] = 0.0;
	        result[4] = tangent.x;
	        result[5] = tangent.y;
	        result[6] = tangent.z;
	        result[7] = 0.0;
	        result[8] = -normal.x;
	        result[9] = -normal.y;
	        result[10] = -normal.z;
	        result[11] = 0.0;
	        result[12] = origin.x;
	        result[13] = origin.y;
	        result[14] = origin.z;
	        result[15] = 1.0;
	        return result;
	    };

	    /**
	     * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes
	     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
	     * The local axes are defined as:
	     * <ul>
	     * <li>The <code>x</code> axis points in the local north direction.</li>
	     * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
	     * <li>The <code>z</code> axis points in the local east direction.</li>
	     * </ul>
	     *
	     * @param {Cartesian3} origin The center point of the local reference frame.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
	     * @param {Matrix4} [result] The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	     *
	     * @example
	     * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.
	     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	     * var transform = Cesium.Transforms.northUpEastToFixedFrame(center);
	     */
	    Transforms.northUpEastToFixedFrame = function(origin, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(origin)) {
	            throw new DeveloperError('origin is required.');
	        }
	        //>>includeEnd('debug');

	        // If x and y are zero, assume origin is at a pole, which is a special case.
	        if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&
	            CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
	            var sign = CesiumMath.sign(origin.z);
	            if (!defined(result)) {
	                return new Matrix4(
	                       -sign, 0.0,  0.0, origin.x,
	                        0.0,  0.0,  1.0, origin.y,
	                        0.0,  sign, 0.0, origin.z,
	                        0.0,  0.0,  0.0, 1.0);
	            }
	            result[0] = -sign;
	            result[1] = 0.0;
	            result[2] = 0.0;
	            result[3] = 0.0;
	            result[4] = 0.0;
	            result[5] = 0.0;
	            result[6] = sign;
	            result[7] = 0.0;
	            result[8] = 0.0;
	            result[9] = 1.0;
	            result[10] = 0.0;
	            result[11] = 0.0;
	            result[12] = origin.x;
	            result[13] = origin.y;
	            result[14] = origin.z;
	            result[15] = 1.0;
	            return result;
	        }

	        var normal = eastNorthUpToFixedFrameNormal;
	        var tangent  = eastNorthUpToFixedFrameTangent;
	        var bitangent = eastNorthUpToFixedFrameBitangent;

	        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	        ellipsoid.geodeticSurfaceNormal(origin, normal);

	        tangent.x = -origin.y;
	        tangent.y = origin.x;
	        tangent.z = 0.0;
	        Cartesian3.normalize(tangent, tangent);

	        Cartesian3.cross(normal, tangent, bitangent);

	        if (!defined(result)) {
	            return new Matrix4(
	                    bitangent.x, normal.x, tangent.x, origin.x,
	                    bitangent.y, normal.y, tangent.y, origin.y,
	                    bitangent.z, normal.z, tangent.z, origin.z,
	                    0.0,       0.0,         0.0,      1.0);
	        }
	        result[0] = bitangent.x;
	        result[1] = bitangent.y;
	        result[2] = bitangent.z;
	        result[3] = 0.0;
	        result[4] = normal.x;
	        result[5] = normal.y;
	        result[6] = normal.z;
	        result[7] = 0.0;
	        result[8] = tangent.x;
	        result[9] = tangent.y;
	        result[10] = tangent.z;
	        result[11] = 0.0;
	        result[12] = origin.x;
	        result[13] = origin.y;
	        result[14] = origin.z;
	        result[15] = 1.0;
	        return result;
	    };

	    var scratchHPRQuaternion = new Quaternion();
	    var scratchScale = new Cartesian3(1.0, 1.0, 1.0);
	    var scratchHPRMatrix4 = new Matrix4();

	    /**
	     * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles
	     * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north
	     * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
	     * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
	     *
	     * @param {Cartesian3} origin The center point of the local reference frame.
	     * @param {Number} heading The heading angle in radians.
	     * @param {Number} pitch The pitch angle in radians.
	     * @param {Number} roll The roll angle in radians.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
	     * @param {Matrix4} [result] The object onto which to store the result.
	     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
	     *
	     * @example
	     * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
	     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	     * var heading = -Cesium.Math.PI_OVER_TWO;
	     * var pitch = Cesium.Math.PI_OVER_FOUR;
	     * var roll = 0.0;
	     * var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, heading, pitch, roll);
	     */
	    Transforms.headingPitchRollToFixedFrame = function(origin, heading, pitch, roll, ellipsoid, result) {
	        // checks for required parameters happen in the called functions
	        var hprQuaternion = Quaternion.fromHeadingPitchRoll(heading, pitch, roll, scratchHPRQuaternion);
	        var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);
	        result = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, result);
	        return Matrix4.multiply(result, hprMatrix, result);
	    };

	    var scratchENUMatrix4 = new Matrix4();
	    var scratchHPRMatrix3 = new Matrix3();

	    /**
	     * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles
	     * centered at the provided origin. Heading is the rotation from the local north
	     * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
	     * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
	     *
	     * @param {Cartesian3} origin The center point of the local reference frame.
	     * @param {Number} heading The heading angle in radians.
	     * @param {Number} pitch The pitch angle in radians.
	     * @param {Number} roll The roll angle in radians.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
	     * @param {Quaternion} [result] The object onto which to store the result.
	     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
	     *
	     * @example
	     * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
	     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	     * var heading = -Cesium.Math.PI_OVER_TWO;
	     * var pitch = Cesium.Math.PI_OVER_FOUR;
	     * var roll = 0.0;
	     * var quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, heading, pitch, roll);
	     */
	    Transforms.headingPitchRollQuaternion = function(origin, heading, pitch, roll, ellipsoid, result) {
	        // checks for required parameters happen in the called functions
	        var transform = Transforms.headingPitchRollToFixedFrame(origin, heading, pitch, roll, ellipsoid, scratchENUMatrix4);
	        var rotation = Matrix4.getRotation(transform, scratchHPRMatrix3);
	        return Quaternion.fromRotationMatrix(rotation, result);
	    };


	    var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
	    var gmstConstant1 = 8640184.812866;
	    var gmstConstant2 = 0.093104;
	    var gmstConstant3 = -6.2E-6;
	    var rateCoef = 1.1772758384668e-19;
	    var wgs84WRPrecessing = 7.2921158553E-5;
	    var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;
	    var dateInUtc = new JulianDate();

	    /**
	     * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
	     * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
	     *
	     * @param {JulianDate} date The time at which to compute the rotation matrix.
	     * @param {Matrix3} [result] The object onto which to store the result.
	     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
	     *
	     * @example
	     * //Set the view to in the inertial frame.
	     * scene.preRender.addEventListener(function(scene, time) {
	     *    var now = new Cesium.JulianDate();
	     *    var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
	     *    var transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));
	     *    var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
	     *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
	     *    camera.lookAtTransform(transform, offset);
	     * });
	     */
	    Transforms.computeTemeToPseudoFixedMatrix = function (date, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(date)) {
	            throw new DeveloperError('date is required.');
	        }
	        //>>includeEnd('debug');

	        // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.
	        // We do not want to use the function like convertTaiToUtc in JulianDate because
	        // we explicitly do not want to fail when inside the leap second.

	        dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);
	        var utcDayNumber = dateInUtc.dayNumber;
	        var utcSecondsIntoDay = dateInUtc.secondsOfDay;

	        var t;
	        var diffDays = utcDayNumber - 2451545;
	        if (utcSecondsIntoDay >= 43200.0) {
	            t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
	        } else {
	            t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
	        }

	        var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
	        var angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;
	        var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);
	        var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;
	        var gha = angle + (ratio * secondsSinceMidnight);
	        var cosGha = Math.cos(gha);
	        var sinGha = Math.sin(gha);

	        if (!defined(result)) {
	            return new Matrix3(cosGha, sinGha, 0.0,
	                              -sinGha, cosGha, 0.0,
	                                  0.0,    0.0, 1.0);
	        }
	        result[0] = cosGha;
	        result[1] = -sinGha;
	        result[2] = 0.0;
	        result[3] = sinGha;
	        result[4] = cosGha;
	        result[5] = 0.0;
	        result[6] = 0.0;
	        result[7] = 0.0;
	        result[8] = 1.0;
	        return result;
	    };

	    /**
	     * The source of IAU 2006 XYS data, used for computing the transformation between the
	     * Fixed and ICRF axes.
	     * @type {Iau2006XysData}
	     *
	     * @see Transforms.computeIcrfToFixedMatrix
	     * @see Transforms.computeFixedToIcrfMatrix
	     *
	     * @private
	     */
	    Transforms.iau2006XysData = new Iau2006XysData();

	    /**
	     * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation
	     * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,
	     * yielding a reasonable but not completely accurate representation of the ICRF axes.
	     * @type {EarthOrientationParameters}
	     *
	     * @see Transforms.computeIcrfToFixedMatrix
	     * @see Transforms.computeFixedToIcrfMatrix
	     *
	     * @private
	     */
	    Transforms.earthOrientationParameters = EarthOrientationParameters.NONE;

	    var ttMinusTai = 32.184;
	    var j2000ttDays = 2451545.0;

	    /**
	     * Preloads the data necessary to transform between the ICRF and Fixed axes, in either
	     * direction, over a given interval.  This function returns a promise that, when resolved,
	     * indicates that the preload has completed.
	     *
	     * @param {TimeInterval} timeInterval The interval to preload.
	     * @returns {Promise} A promise that, when resolved, indicates that the preload has completed
	     *          and evaluation of the transformation between the fixed and ICRF axes will
	     *          no longer return undefined for a time inside the interval.
	     *
	     * @see Transforms.computeIcrfToFixedMatrix
	     * @see Transforms.computeFixedToIcrfMatrix
	     * @see when
	     *
	     * @example
	     * var interval = new Cesium.TimeInterval(...);
	     * when(preloadIcrfFixed(interval), function() {
	     *     // the data is now loaded
	     * });
	     */
	    Transforms.preloadIcrfFixed = function(timeInterval) {
	        var startDayTT = timeInterval.start.dayNumber;
	        var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;
	        var stopDayTT = timeInterval.stop.dayNumber;
	        var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;

	        var xysPromise = Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);
	        var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();

	        return when.all([xysPromise, eopPromise]);
	    };

	    /**
	     * Computes a rotation matrix to transform a point or vector from the International Celestial
	     * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)
	     * at a given time.  This function may return undefined if the data necessary to
	     * do the transformation is not yet loaded.
	     *
	     * @param {JulianDate} date The time at which to compute the rotation matrix.
	     * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
	     *                  not specified, a new instance is created and returned.
	     * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the
	     *                   transformation is not yet loaded.
	     *
	     * @see Transforms.preloadIcrfFixed
	     *
	     * @example
	     * scene.preRender.addEventListener(function(scene, time) {
	     *   var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
	     *   if (Cesium.defined(icrfToFixed)) {
	     *     var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
	     *     var transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed)
	     *     var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
	     *     Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
	     *     camera.lookAtTransform(transform, offset);
	     *   }
	     * });
	     */
	    Transforms.computeIcrfToFixedMatrix = function(date, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(date)) {
	            throw new DeveloperError('date is required.');
	        }
	        //>>includeEnd('debug');
	        if (!defined(result)) {
	            result = new Matrix3();
	        }

	        var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);
	        if (!defined(fixedToIcrfMtx)) {
	            return undefined;
	        }

	        return Matrix3.transpose(fixedToIcrfMtx, result);
	    };

	    var xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);
	    var eopScratch = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	    var rotation1Scratch = new Matrix3();
	    var rotation2Scratch = new Matrix3();

	    /**
	     * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)
	     * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
	     * at a given time.  This function may return undefined if the data necessary to
	     * do the transformation is not yet loaded.
	     *
	     * @param {JulianDate} date The time at which to compute the rotation matrix.
	     * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
	     *                  not specified, a new instance is created and returned.
	     * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the
	     *                   transformation is not yet loaded.
	     *
	     * @see Transforms.preloadIcrfFixed
	     *
	     * @example
	     * // Transform a point from the ICRF axes to the Fixed axes.
	     * var now = new Cesium.JulianDate();
	     * var pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
	     * var fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);
	     * var pointInInertial = new Cesium.Cartesian3();
	     * if (Cesium.defined(fixedToIcrf)) {
	     *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);
	     * }
	     */
	    Transforms.computeFixedToIcrfMatrix = function(date, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(date)) {
	            throw new DeveloperError('date is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            result = new Matrix3();
	        }

	        // Compute pole wander
	        var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);
	        if (!defined(eop)) {
	            return undefined;
	        }

	        // There is no external conversion to Terrestrial Time (TT).
	        // So use International Atomic Time (TAI) and convert using offsets.
	        // Here we are assuming that dayTT and secondTT are positive
	        var dayTT = date.dayNumber;
	        // It's possible here that secondTT could roll over 86400
	        // This does not seem to affect the precision (unit tests check for this)
	        var secondTT = date.secondsOfDay + ttMinusTai;

	        var xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);
	        if (!defined(xys)) {
	            return undefined;
	        }

	        var x = xys.x + eop.xPoleOffset;
	        var y = xys.y + eop.yPoleOffset;

	        // Compute XYS rotation
	        var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));

	        var rotation1 = rotation1Scratch;
	        rotation1[0] = 1.0 - a * x * x;
	        rotation1[3] = -a * x * y;
	        rotation1[6] = x;
	        rotation1[1] = -a * x * y;
	        rotation1[4] = 1 - a * y * y;
	        rotation1[7] = y;
	        rotation1[2] = -x;
	        rotation1[5] = -y;
	        rotation1[8] = 1 - a * (x * x + y * y);

	        var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);
	        var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);

	        // Similar to TT conversions above
	        // It's possible here that secondTT could roll over 86400
	        // This does not seem to affect the precision (unit tests check for this)
	        var dateUt1day = date.dayNumber;
	        var dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;

	        // Compute Earth rotation angle
	        // The IERS standard for era is
	        //    era = 0.7790572732640 + 1.00273781191135448 * Tu
	        // where
	        //    Tu = JulianDateInUt1 - 2451545.0
	        // However, you get much more precision if you make the following simplification
	        //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)
	        //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)
	        //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)
	        // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.
	        var daysSinceJ2000 = dateUt1day - 2451545;
	        var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;
	        var era = 0.7790572732640 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);
	        era = (era % 1.0) * CesiumMath.TWO_PI;

	        var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);

	        // pseudoFixed to ICRF
	        var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);

	        // Compute pole wander matrix
	        var cosxp = Math.cos(eop.xPoleWander);
	        var cosyp = Math.cos(eop.yPoleWander);
	        var sinxp = Math.sin(eop.xPoleWander);
	        var sinyp = Math.sin(eop.yPoleWander);

	        var ttt = (dayTT - j2000ttDays) + secondTT / TimeConstants.SECONDS_PER_DAY;
	        ttt /= 36525.0;

	        // approximate sp value in rad
	        var sp = -47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600.0;
	        var cossp = Math.cos(sp);
	        var sinsp = Math.sin(sp);

	        var fToPfMtx = rotation2Scratch;
	        fToPfMtx[0] = cosxp * cossp;
	        fToPfMtx[1] = cosxp * sinsp;
	        fToPfMtx[2] = sinxp;
	        fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;
	        fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;
	        fToPfMtx[5] = -sinyp * cosxp;
	        fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;
	        fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;
	        fToPfMtx[8] = cosyp * cosxp;

	        return Matrix3.multiply(pfToIcrf, fToPfMtx, result);
	    };

	    var pointToWindowCoordinatesTemp = new Cartesian4();

	    /**
	     * Transform a point from model coordinates to window coordinates.
	     *
	     * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.
	     * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.
	     * @param {Cartesian3} point The point to transform.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
	     */
	    Transforms.pointToWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {
	        result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);
	        result.y = 2.0 * viewportTransformation[5] - result.y;
	        return result;
	    };

	    /**
	     * @private
	     */
	    Transforms.pointToGLWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(modelViewProjectionMatrix)) {
	            throw new DeveloperError('modelViewProjectionMatrix is required.');
	        }

	        if (!defined(viewportTransformation)) {
	            throw new DeveloperError('viewportTransformation is required.');
	        }

	        if (!defined(point)) {
	            throw new DeveloperError('point is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            result = new Cartesian2();
	        }

	        var tmp = pointToWindowCoordinatesTemp;

	        Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);
	        Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);
	        Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);
	        return Cartesian2.fromCartesian4(tmp, result);
	    };

	    var normalScratch = new Cartesian3();
	    var rightScratch = new Cartesian3();
	    var upScratch = new Cartesian3();

	    /**
	     * @private
	     */
	    Transforms.rotationMatrixFromPositionVelocity = function(position, velocity, ellipsoid, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(position)) {
	            throw new DeveloperError('position is required.');
	        }

	        if (!defined(velocity)) {
	            throw new DeveloperError('velocity is required.');
	        }
	        //>>includeEnd('debug');

	        var normal = defaultValue(ellipsoid, Ellipsoid.WGS84).geodeticSurfaceNormal(position, normalScratch);
	        var right = Cartesian3.cross(velocity, normal, rightScratch);
	        if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
	            right = Cartesian3.clone(Cartesian3.UNIT_X, right);
	        }

	        var up = Cartesian3.cross(right, velocity, upScratch);
	        Cartesian3.cross(velocity, up, right);
	        Cartesian3.negate(right, right);

	        if (!defined(result)) {
	            result = new Matrix3();
	        }

	        result[0] = velocity.x;
	        result[1] = velocity.y;
	        result[2] = velocity.z;
	        result[3] = right.x;
	        result[4] = right.y;
	        result[5] = right.z;
	        result[6] = up.x;
	        result[7] = up.y;
	        result[8] = up.z;

	        return result;
	    };

	    return Transforms;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event) {
	    "use strict";

	    /**
	     * A {@link Property} whose value does not change with respect to simulation time.
	     *
	     * @alias ConstantProperty
	     * @constructor
	     *
	     * @param {Object} [value] The property value.
	     *
	     * @see ConstantPositionProperty
	     *
	     * @exception {DeveloperError} value.clone is a required function.
	     * @exception {DeveloperError} value.equals is a required function.
	     */
	    var ConstantProperty = function(value) {
	        this._value = undefined;
	        this._hasClone = false;
	        this._hasEquals = false;
	        this._definitionChanged = new Event();
	        this.setValue(value);
	    };

	    defineProperties(ConstantProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.
	         * This property always returns <code>true</code>.
	         * @memberof ConstantProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            value : true
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever setValue is called with data different
	         * than the current value.
	         * @memberof ConstantProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property.
	     *
	     * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    ConstantProperty.prototype.getValue = function(time, result) {
	        return this._hasClone ? this._value.clone(result) : this._value;
	    };

	    /**
	     * Sets the value of the property.
	     *
	     * @param {Object} value The property value.
	     *
	     * @exception {DeveloperError} value.clone is a required function.
	     * @exception {DeveloperError} value.equals is a required function.
	     */
	    ConstantProperty.prototype.setValue = function(value) {
	        var oldValue = this._value;
	        if (oldValue !== value) {
	            var isDefined = defined(value);
	            var hasClone = isDefined && typeof value.clone === 'function';
	            var hasEquals = isDefined && typeof value.equals === 'function';

	            this._hasClone = hasClone;
	            this._hasEquals = hasEquals;

	            var changed = !hasEquals || !value.equals(oldValue);
	            if (changed) {
	                this._value = !hasClone ? value : value.clone();
	                this._definitionChanged.raiseEvent(this);
	            }
	        }
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    ConstantProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof ConstantProperty && //
	                ((!this._hasEquals && (this._value === other._value)) || //
	                (this._hasEquals && this._value.equals(other._value))));
	    };

	    return ConstantProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(29),
	        __webpack_require__(44),
	        __webpack_require__(35),
	        __webpack_require__(21),
	        __webpack_require__(55),
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Matrix3,
	        Matrix4,
	        Quaternion,
	        ReferenceFrame,
	        Transforms) {
	    "use strict";

	    /**
	     * The interface for all {@link Property} objects that define a world
	     * location as a {@link Cartesian3} with an associated {@link ReferenceFrame}.
	     * This type defines an interface and cannot be instantiated directly.
	     *
	     * @alias PositionProperty
	     * @constructor
	     *
	     * @see CompositePositionProperty
	     * @see ConstantPositionProperty
	     * @see SampledPositionProperty
	     * @see TimeIntervalCollectionPositionProperty
	     */
	    var PositionProperty = function() {
	        DeveloperError.throwInstantiationError();
	    };

	    defineProperties(PositionProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof PositionProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof PositionProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets the reference frame that the position is defined in.
	         * @memberof PositionProperty.prototype
	         * @type {ReferenceFrame}
	         */
	        referenceFrame : {
	            get : DeveloperError.throwInstantiationError
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time in the fixed frame.
	     * @function
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    PositionProperty.prototype.getValue = DeveloperError.throwInstantiationError;

	    /**
	     * Gets the value of the property at the provided time and in the provided reference frame.
	     * @function
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    PositionProperty.prototype.getValueInReferenceFrame = DeveloperError.throwInstantiationError;

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    PositionProperty.prototype.equals = DeveloperError.throwInstantiationError;

	    function framesEqual(frame1, frame2) {
	      return frame1 && frame1.id ?
	          frame1.id === (frame2 && frame2.id) :
	          frame1 === frame2;
	    }

	    function frameParents(frame) {
	        var frames = [];
	        while (defined(frame) && frame !== null) {
	            frames.unshift(frame);
	            frame = frame.position && frame.position.referenceFrame;
	        }
	        return frames;
	    }

	    function lowestCommonAncestor(parents1, parents2) {
	        if (!framesEqual(parents1[0],parents2[0])) return -1;

	        var h = Math.min(parents1.length, parents2.length);
	        for (var i = 0; i <= h; i++) {
	            if (!framesEqual(parents1[i],parents2[i])) return i-1;
	        }

	        return -1;
	    }

	    var scratchIcrfToFixedMatrix3 = new Matrix3();

	    function getIcrfToFixed(time) {
	        var icrfToFixed = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
	        if (!defined(icrfToFixed)) {
	            icrfToFixed = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
	        }
	        return icrfToFixed;
	    }

	    var scratchMatrix3 = new Matrix3();
	    var scratchCartesian3 = new Cartesian3();
	    var scratchQuaternion = new Quaternion();

	    /**
	     * @private
	     */
	    PositionProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
	      if (!defined(value)) {
	          return value;
	      }
	      if (!defined(result)) {
	          result = new Cartesian3();
	      }

	      if (inputFrame === outputFrame) {
	          return Cartesian3.clone(value, result);
	      }

	      if (inputFrame === null || outputFrame === null) {
	          return undefined;
	      }

	      var inputFrameParents = frameParents(inputFrame);
	      var outputFrameParents = frameParents(outputFrame);
	      var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
	      var lcaFrame = inputFrameParents[lcaIndex];

	      var inputPositionAccumulator = function (accumulatedPositionValue, frame) {
	          if (!defined(accumulatedPositionValue)) return accumulatedPositionValue;

	          var framePositionProperty = frame.position;
	          if (!defined(framePositionProperty)) return undefined;

	          var frameReferenceFrame = framePositionProperty.referenceFrame;
	          var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
	          if (!defined(framePositionValue)) return undefined;

	          var frameOrientationProperty = frame.orientation;
	          if (defined(frameOrientationProperty)) {
	              var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	              if (!defined(frameOrientationValue)) return undefined;

	              Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
	              Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
	              return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
	          }

	          return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
	      }

	      var outputPositionAccumulator = function (accumulatedPositionValue, frame) {
	          if (!defined(accumulatedPositionValue)) return accumulatedPositionValue;

	          var framePositionProperty = frame.position;
	          if (!defined(framePositionProperty)) return undefined;

	          var frameReferenceFrame = framePositionProperty.referenceFrame;
	          var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
	          if (!defined(framePositionValue)) return undefined;

	          accumulatedPositionValue = Cartesian3.subtract(accumulatedPositionValue, framePositionValue, accumulatedPositionValue);

	          var frameOrientationProperty = frame.orientation;
	          if (defined(frameOrientationProperty)) {
	              var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	              if (!defined(frameOrientationValue)) return undefined;

	              Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
	              Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
	              Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
	          }

	          return accumulatedPositionValue;
	      }

	      if (defined(lcaFrame)) {
	          inputFrameParents = inputFrameParents.slice(lcaIndex+1);
	          outputFrameParents = outputFrameParents.slice(lcaIndex+1);

	          var lcaFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
	          if (!defined(lcaFrameValue)) return undefined;

	          return outputFrameParents.reduce(outputPositionAccumulator, lcaFrameValue);
	      }

	      var inputRootFrame = inputFrameParents.shift();
	      var outputRootFrame = outputFrameParents.shift();

	      if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
	          var inertialFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
	          if (!defined(inertialFrameValue)) return undefined;

	          var fixedFrameValue = Matrix3.multiplyByVector(getIcrfToFixed(time), inertialFrameValue, result);
	          return outputFrameParents.reduce(outputPositionAccumulator, fixedFrameValue);
	      }

	      if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
	          var fixedFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result))
	          if (!defined(fixedFrameValue)) return undefined;

	          var fixedToIcrf = Matrix3.transpose(getIcrfToFixed(time), scratchMatrix3);
	          var inertialFrameValue = Matrix3.multiplyByVector(fixedToIcrf, fixedFrameValue, result);
	          return outputFrameParents.reduce(outputPositionAccumulator, inertialFrameValue);
	      }

	      return undefined;
	    }

	    return PositionProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}

	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;

	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}

	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);

	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.

	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396

	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}

	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.jss
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;

	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}

	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html

	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.

	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }

	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.

	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }

	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.

	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.

	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);

	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}

	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(155), __esModule: true };

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $     = __webpack_require__(5)
	  , $def  = __webpack_require__(27)
	  , BUGGY = __webpack_require__(13).BUGGY
	  , forOf = __webpack_require__(31)
	  , species = __webpack_require__(107)
	  , assertInstance = __webpack_require__(20).inst;

	module.exports = function(NAME, methods, common, IS_MAP, IS_WEAK){
	  var Base  = $.g[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  function fixMethod(KEY, CHAIN){
	    var method = proto[KEY];
	    if($.FW)proto[KEY] = function(a, b){
	      var result = method.call(this, a === 0 ? 0 : a, b);
	      return CHAIN ? this : result;
	    };
	  }
	  if(!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)){
	    // create collection constructor
	    C = common.getConstructor(NAME, IS_MAP, ADDER);
	    $.mix(C.prototype, methods);
	  } else {
	    var inst  = new C
	      , chain = inst[ADDER](IS_WEAK ? {} : -0, 1)
	      , buggyZero;
	    // wrap for init collections from iterable
	    if(!__webpack_require__(106)(function(iter){ new C(iter); })){ // eslint-disable-line no-new
	      C = function(){
	        assertInstance(this, C, NAME);
	        var that     = new Base
	          , iterable = arguments[0];
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      };
	      C.prototype = proto;
	      if($.FW)proto.constructor = C;
	    }
	    IS_WEAK || inst.forEach(function(val, key){
	      buggyZero = 1 / key === -Infinity;
	    });
	    // fix converting -0 key to +0
	    if(buggyZero){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    // + fix .add & .set for chaining
	    if(buggyZero || chain !== inst)fixMethod(ADDER, true);
	  }

	  __webpack_require__(30).set(C, NAME);

	  O[NAME] = C;
	  $def($def.G + $def.W + $def.F * (C != Base), O);
	  species(C);
	  species($.core[NAME]); // for wrapper

	  if(!IS_WEAK)common.setIter(C, NAME, IS_MAP);

	  return C;
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var $          = __webpack_require__(5)
	  , setUnscope = __webpack_require__(109)
	  , ITER       = __webpack_require__(24).safe('iter')
	  , $iter      = __webpack_require__(13)
	  , step       = $iter.step
	  , Iterators  = $iter.Iterators;

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	__webpack_require__(42)(Array, 'Array', function(iterated, kind){
	  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var iter  = this[ITER]
	    , O     = iter.o
	    , kind  = iter.k
	    , index = iter.i++;
	  if(!O || index >= O.length){
	    iter.o = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	setUnscope('keys');
	setUnscope('values');
	setUnscope('entries');

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var $   = __webpack_require__(5)
	  , cof = __webpack_require__(30)
	  , src = String({}.toString)
	  , tmp = {};
	function toString(){
	  return '[object ' + cof.classof(this) + ']';
	}
	// lodash uses String(Object.prototype.toString) in isNative
	toString.toString = function(){
	  return src;
	};
	tmp[__webpack_require__(14)('toStringTag')] = 'z';
	if($.FW && cof(tmp) != 'z')$.hide(Object.prototype, 'toString', toString);

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var set   = __webpack_require__(5).set
	  , $at   = __webpack_require__(108)(true)
	  , ITER  = __webpack_require__(24).safe('iter')
	  , $iter = __webpack_require__(13)
	  , step  = $iter.step;

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(42)(String, 'String', function(iterated){
	  set(this, ITER, {o: String(iterated), i: 0});
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var iter  = this[ITER]
	    , O     = iter.o
	    , index = iter.i
	    , point;
	  if(index >= O.length)return step(1);
	  point = $at(O, index);
	  iter.i += point.length;
	  return step(0, point);
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(61);
	var $           = __webpack_require__(5)
	  , Iterators   = __webpack_require__(13).Iterators
	  , ITERATOR    = __webpack_require__(14)('iterator')
	  , ArrayValues = Iterators.Array
	  , NodeList    = $.g.NodeList;
	if($.FW && NodeList && !(ITERATOR in NodeList.prototype)){
	  $.hide(NodeList.prototype, ITERATOR, ArrayValues);
	}
	Iterators.NodeList = ArrayValues;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//
	//
	// @module Argon
	//

	'use strict';

	var Argon = module.exports = {};

	Argon.version = __webpack_require__(49).version;
	Argon.semver = __webpack_require__(49).semver;

	// XXX: oasis.js exports Oasis, oasis, and RSVP on the global object
	// Argon._oasisScript = require('raw!oasis.min')
	// new Function(Argon._oasisScript).call(window)

	// XXX: basket.js exports basket on the global object
	Argon._basketScript = __webpack_require__(219);
	new Function(Argon._basketScript).call(window);

	Argon.Promise = __webpack_require__(17);
	Argon.Promise.onPossiblyUnhandledRejection(function (e) {
	  console.error(e.message + e.stack);
	});

	Argon.alert = __webpack_require__(89);

	var events = __webpack_require__(32);
	Argon.Util = __webpack_require__(22);
	Argon.Util.mixinEventHandler(Argon);
	Argon.EventHandler = events.EventHandler;
	Argon.EventMapper = events.EventMapper;
	Argon.EventFilter = events.EventFilter;
	Argon.EventPort = __webpack_require__(39);

	Argon.Cesium = __webpack_require__(15);
	__webpack_require__(149);

	Argon.Platform = __webpack_require__(18);
	Argon.Context = __webpack_require__(87);
	Argon.Reality = __webpack_require__(25);
	Argon.RealityView = __webpack_require__(88);

	Argon.dataSource = __webpack_require__(23);
	Argon.immersiveContext = __webpack_require__(91);

	Argon.Vuforia = __webpack_require__(66);

	__webpack_require__(94);
	__webpack_require__(151);

	Argon.getPresentationMode = function () {
	  return Argon.immersiveContext.options.presentationMode;
	};
	Argon.setPresentationMode = function (mode) {
	  if (mode === 'page' && Argon.isPageModeAvailable() === false) return;
	  Argon.immersiveContext.set('presentationMode', mode);
	};
	Argon.isPageModeAvailable = function (mode) {
	  return Argon.immersiveContext.options.pageModeAvailable;
	};

	if (Argon.Platform.isManager) {
	  Argon.Channel = __webpack_require__(38);
	  Argon.channels = Argon.Channel.collection;
	  Argon.policy = __webpack_require__(93);
	  Argon.nativePort = __webpack_require__(92);
	} else {
	  Argon.ready = __webpack_require__(33)['default'];
	  Argon.setReady = __webpack_require__(33).setReady;
	  Argon.setUnavailable = __webpack_require__(33).setUnavailable;
	  Argon.managerPort = __webpack_require__(40);
	}

	__webpack_require__(145);
	__webpack_require__(146);

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _classCallCheck = __webpack_require__(26)['default'];

	var _inherits = __webpack_require__(70)['default'];

	var _Object$keys = __webpack_require__(95)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _Util = __webpack_require__(22);

	var _Util2 = _interopRequireDefault(_Util);

	var _Channel = __webpack_require__(38);

	var _Channel2 = _interopRequireDefault(_Channel);

	var _Platform = __webpack_require__(18);

	var _managerPort = __webpack_require__(40);

	var _managerPort2 = _interopRequireDefault(_managerPort);

	var _nativePort = __webpack_require__(92);

	var _nativePort2 = _interopRequireDefault(_nativePort);

	var _dataSource = __webpack_require__(23);

	var _dataSource2 = _interopRequireDefault(_dataSource);

	var _entitiesDevice = __webpack_require__(90);

	var _entitiesDevice2 = _interopRequireDefault(_entitiesDevice);

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _Reality2 = __webpack_require__(25);

	var _Reality3 = _interopRequireDefault(_Reality2);

	var _ready = __webpack_require__(33);

	var _ready2 = _interopRequireDefault(_ready);

	var _alert = __webpack_require__(89);

	var _alert2 = _interopRequireDefault(_alert);

	var _Argon = __webpack_require__(65);

	var _Argon2 = _interopRequireDefault(_Argon);

	var JulianDate = _cesiumCesiumImports2['default'].JulianDate;

	function entityIdFromTrackableInfo(trackableInfo) {
	  return 'VuforiaTrackable.' + trackableInfo.id + '.' + trackableInfo.name;
	}

	var Vuforia = {};
	_Util2['default'].mixinInputOutputEventHandlers(Vuforia);

	exports['default'] = Vuforia;

	if (_Platform.isChannel) {
	  (function () {

	    var vuforiaReady = (0, _ready2['default'])('Vuforia');

	    if (navigator.userAgent.indexOf('Vuforia') > -1) {
	      (0, _ready.setReady)('Vuforia');
	    } else {
	      vuforiaReady.timeout(100)['catch'](_bluebird2['default'].TimeoutError, function (e) {
	        (0, _ready.setUnavailable)('Vuforia');
	      });
	    }

	    var VuforiaDataSet = (function () {
	      function VuforiaDataSet(info) {
	        _classCallCheck(this, VuforiaDataSet);

	        this.url = info.url;
	        this.trackables = info.trackables.reduce(function (dict, trackableInfo) {
	          var entityId = entityIdFromTrackableInfo(trackableInfo);
	          dict[trackableInfo.name] = _dataSource2['default'].entities.getOrCreateEntity(entityId);
	          _dataSource2['default'].subscribeToEntityById(entityId);
	          return dict;
	        }, {});
	        // TODO: trackables do not have a position/orientation property yet,
	        // so we have to listen for changes to each trackable and wait until
	        // those properties are added before we can set the extrapolation settings
	        this._forwardExtrapolationType = _cesiumCesiumImports2['default'].ExtrapolationType.HOLD;
	        this._forwardExtrapolationDuration = 1 / 15;
	      }

	      /**
	       * Set forwardExtrapolationType for all trackables
	       */

	      VuforiaDataSet.prototype.setForwardExtrapolationType = function setForwardExtrapolationType(extrapolationType) {
	        this._forwardExtrapolationType = extrapolationType;
	        for (var _name in this.trackables) {
	          var t = this.trackables[_name];
	          if (t.position && t.position.addSample) t.position.forwardExtrapolationType = extrapolationType;
	          if (t.orientation && t.orientation.addSample) t.orientation.forwardExtrapolationType = extrapolationType;
	        }
	      };

	      /**
	       * Set forwardExtrapolationDuration for all trackables
	       */

	      VuforiaDataSet.prototype.setForwardExtrapolationDuration = function setForwardExtrapolationDuration(extrapolationDuration) {
	        this._forwardExtrapolationDuration = extrapolationDuration;
	        for (var _name2 in this.trackables) {
	          var t = this.trackables[_name2];
	          if (t.position && t.position.addSample) t.position.forwardExtrapolationDuration = extrapolationDuration;
	          if (t.orientation && t.orientation.addSample) t.orientation.forwardExtrapolationDuration = extrapolationDuration;
	        }
	      };

	      /**
	       * Unloads a DataSet
	       *
	       * @return {Promise.<null, Error>}
	       */

	      VuforiaDataSet.prototype.unload = function unload() {
	        return _managerPort2['default'].request('Vuforia.unloadDataSet', { url: this.url });
	      };

	      /**
	       * Returns a Promise that fulfills if the DataSet can be sucessfully activated.
	       *
	       * @return {Promise<null, Error>}
	       */

	      VuforiaDataSet.prototype.activate = function activate() {
	        return _managerPort2['default'].request('Vuforia.activateDataSet', { url: this.url });
	      };

	      /**
	       * Returns a Promise that fulfills if the DataSet can be sucessfully deactivated.
	       *
	       * @return {Promise<null, Error>}
	       */

	      VuforiaDataSet.prototype.deactivate = function deactivate() {
	        return _managerPort2['default'].request('Vuforia.deactivateDataSet', { url: this.url });
	      };

	      return VuforiaDataSet;
	    })();

	    var VuforiaAPI = (function () {
	      function VuforiaAPI() {
	        _classCallCheck(this, VuforiaAPI);
	      }

	      /**
	       * Loads and returns a (Promised) DataSet from the specified url
	       *
	       * @param {string} url The url of a dataset xml file
	       *
	       * @typedef {{url: string, trackables: Object.<string,Entity>}} DataSet
	       *
	       * @return {Promise.<DataSet, Error>} The loaded DataSet (Promise)
	       */

	      VuforiaAPI.prototype.loadDataSetFromURL = function loadDataSetFromURL(url) {
	        return _managerPort2['default'].request('Vuforia.loadDataSet', { url: _Util2['default'].resolveURL(url) }).then(function (dataSetInfo) {
	          return new VuforiaDataSet(dataSetInfo);
	        });
	      };

	      /**
	       * Start the camera
	       *
	       * @return {Promise<null, Error>}
	       */

	      VuforiaAPI.prototype.startCamera = function startCamera() {
	        return _managerPort2['default'].request('Vuforia.startCamera');
	      };

	      /**
	       * Stop the camera
	       *
	       * @return {Promise<null, Error>}
	       */

	      VuforiaAPI.prototype.stopCamera = function stopCamera() {
	        return _managerPort2['default'].request('Vuforia.stopCamera');
	      };

	      /**
	       * Start the object tracker
	       *
	       * @return {Promise<null, Error>}
	       */

	      VuforiaAPI.prototype.startObjectTracker = function startObjectTracker() {
	        return _managerPort2['default'].request('Vuforia.startObjectTracker');
	      };

	      /**
	       * Stop the object tracker
	       *
	       * @return {Promise<null, Error>}
	       */

	      VuforiaAPI.prototype.stopObjectTracker = function stopObjectTracker() {
	        return _managerPort2['default'].request('Vuforia.stopObjectTracker');
	      };

	      /**
	       * Hint max simultaneous image targets
	       *
	       * @return {Promise<null, Error>}
	       */

	      VuforiaAPI.prototype.hintMaxSimultaneousImageTargets = function hintMaxSimultaneousImageTargets(max) {
	        return _managerPort2['default'].request('Vuforia.hintMaxSimultaneousImageTargets', { max: max });
	      };

	      return VuforiaAPI;
	    })();

	    var vuforiaAPI = new VuforiaAPI();

	    /**
	     * Returns a promise that fulfills on successful initialization.
	     *
	     * @return {Promise.<VuforiaAPI, Error>}
	     */
	    Vuforia.initialize = function () {
	      var options = arguments[0] === undefined ? {} : arguments[0];

	      return vuforiaReady.then(function () {
	        return _managerPort2['default'].request('Vuforia.initialize', options);
	      }).then(function () {
	        return vuforiaAPI;
	      })['catch'](function (e) {
	        (0, _alert2['default'])('Vuforia: ' + JSON.parse(e.message).description);
	        throw e;
	      });
	    };

	    /**
	     * Returns a promise that fulfills on successful deinitialization.
	     *
	     * @return {Promise.<null, Error>}
	     */
	    Vuforia.deinitialize = function () {
	      return vuforiaReady.then(function () {
	        return _managerPort2['default'].request('Vuforia.deinitialize');
	      });
	    };
	  })();
	}

	if (_Platform.isManager) {
	  var waitForCalibrationDefer;

	  (function () {
	    var calculateVideoBackgroundConfig = function () {
	      var cameraCalibration = Vuforia.cameraCalibration;
	      if (!cameraCalibration) throw new Error('Camera calibration is required');

	      var frameSize = cameraCalibration.frameSize;
	      var displaySize = _entitiesDevice2['default'].display.size;

	      var ratio = Math.max(displaySize[0] / frameSize[0], displaySize[1] / frameSize[1]); // Math.max = ASPECT FILL, Math.min = ASPECT FIT

	      videoBackgroundConfig = {
	        size: [frameSize[0] * ratio, frameSize[1] * ratio],
	        position: [0, 0]
	      };
	      VuforiaPlugin.setVideoBackgroundConfig(videoBackgroundConfig);

	      calculateVideoEyeFrustum();
	    };

	    var calculateVideoEyeFrustum = function () {
	      if (!videoBackgroundConfig || !Vuforia.cameraCalibration) return;

	      var cameraFov = Vuforia.cameraCalibration.fov;
	      var videoBackgroundSize = videoBackgroundConfig.size;
	      var displaySize = _entitiesDevice2['default'].display.size;

	      var h = _entitiesDevice2['default'].display.horizontalDirection;
	      var v = _entitiesDevice2['default'].display.verticalDirection;

	      var aspectRatio = displaySize[h] / displaySize[v];

	      var fov = aspectRatio > 1 ? cameraFov[h] * (displaySize[h] / videoBackgroundSize[h]) : cameraFov[v] * (displaySize[v] / videoBackgroundSize[v]);

	      videoEyeFrustum = {
	        fov: fov * Math.PI / 180,
	        aspectRatio: aspectRatio };
	    };

	    var initializeDefault = function () {
	      return _nativePort2['default'].whenReady.then(function () {
	        return VuforiaPlugin.initialize({ startCamera: true });
	      })['catch'](function (error) {
	        var code = JSON.parse(error.message).code;
	        switch (code) {
	          case -1:
	            (0, _alert2['default'])('Vuforia: Error during initialization');break;
	          case -2:
	            (0, _alert2['default'])('Vuforia: The device is not supported');break;
	          case -3:
	            (0, _alert2['default'])('Vuforia: Cannot access the camera');break;
	          case -4:
	            (0, _alert2['default'])('Vuforia: License key is missing');break;
	          case -5:
	            (0, _alert2['default'])('Vuforia: Invalid license key passed to SDK');break;
	          case -6:
	            (0, _alert2['default'])('Vuforia: Unable to verify license key due to network (Permanent error)');break;
	          case -7:
	            (0, _alert2['default'])('Vuforia: Unable to verify license key due to network (Transient error)');break;
	          case -8:
	            (0, _alert2['default'])('Vuforia: Provided key is no longer valid');break;
	          case -9:
	            (0, _alert2['default'])('Vuforia: Dependent external device not detected/plugged in');break;
	          default:
	            (0, _alert2['default'])('Vuforia: Unknown initialization error. ' + error.message);
	        }
	      });
	    };

	    waitForCalibrationDefer = _bluebird2['default'].defer();

	    _nativePort2['default'].on('Vuforia.cameraCalibration', function (e) {
	      var cameraCalibration = {};
	      var frameSize = e.eventInfo.frameSize;
	      var focalLength = e.eventInfo.focalLength;
	      var fovH = 2 * Math.atan(frameSize[0] / (focalLength[0] * 2)) * 180 / Math.PI;
	      var fovV = 2 * Math.atan(frameSize[1] / (focalLength[0] * 2)) * 180 / Math.PI;
	      cameraCalibration.frameSize = frameSize;
	      cameraCalibration.focalLength = focalLength;
	      cameraCalibration.fov = [fovH, fovV];
	      Vuforia.cameraCalibration = cameraCalibration;
	      waitForCalibrationDefer.resolve();
	    });

	    _nativePort2['default'].on('pluginsReady', function () {

	      Vuforia.states = {};
	      Vuforia.currentState = undefined;

	      // wrap VuforiaPlugin with nicer Promise-based api
	      // TODO: all native webscriptplugins should expose a promise api
	      _Object$keys(window.VuforiaPlugin).forEach(function (command) {
	        var fn = window.VuforiaPlugin[command];
	        VuforiaPlugin[command] = function (options) {
	          var requestId = _Util2['default'].cuid();
	          fn({ userData: requestId, options: options });
	          var response = _nativePort2['default'].afterResponse(requestId);
	          response.then(function (response) {
	            console.log('succeed: ' + command + ' ' + JSON.stringify(options) + ' ' + JSON.stringify(response));
	          })['catch'](function (e) {
	            console.log('fail: ' + command + ' ' + JSON.stringify(options) + ' ' + JSON.stringify(e));
	            throw e;
	          });
	          return response;
	        };
	      });

	      var dataSetPromiseMap = {};

	      var initialize = VuforiaPlugin.initialize;
	      VuforiaPlugin.initialize = function (options) {
	        return VuforiaPlugin.deinitialize().then(function () {
	          return initialize(options);
	        }).then(function () {
	          return waitForCalibrationDefer.promise;
	        }).then(function () {
	          calculateVideoBackgroundConfig();
	        });
	      };

	      var loadDataSet = VuforiaPlugin.loadDataSet;
	      VuforiaPlugin.loadDataSet = function (options) {
	        // if we already know about this dataSet... don't load it again
	        var dataSetPromise = dataSetPromiseMap[options.url];
	        if (dataSetPromise) return dataSetPromise;
	        dataSetPromise = dataSetPromiseMap[options.url] = loadDataSet(options);
	        // add entities to our dataSource for each trackable that the channel can subscribe to
	        dataSetPromise.then(function (dataSet) {
	          dataSet.trackables.forEach(function (trackableInfo) {
	            var e = _dataSource2['default'].entities.add({ id: entityIdFromTrackableInfo(trackableInfo) });
	          });
	        });
	        return dataSetPromise;
	      };

	      var unloadDataSet = VuforiaPlugin.unloadDataSet;
	      VuforiaPlugin.unloadDataSet = function (options) {
	        var unloadPromise = unloadDataSet(options).then(function () {
	          // remove the entities we added to our dataSource and delete the dataSource
	          return dataSetPromiseMap[options.url].then(function (dataSet) {
	            dataSet.trackables.forEach(function (trackableInfo) {
	              _dataSource2['default'].entities.removeById(entityIdFromTrackableInfo(trackableInfo));
	            });
	            delete dataSetPromiseMap[options.url];
	          });
	        });
	        return unloadPromise;
	      };

	      var deinitialize = VuforiaPlugin.deinitialize;
	      VuforiaPlugin.deinitialize = function () {
	        return deinitialize().then(function () {
	          var _loop = function (url) {
	            dataSetPromiseMap[url].then(function (dataSet) {
	              dataSet.trackables.forEach(function (trackableInfo) {
	                _dataSource2['default'].entities.removeById(entityIdFromTrackableInfo(trackableInfo));
	              });
	              delete dataSetPromiseMap[url];
	            });
	          };

	          // the native deinitialize function takes care of unloading and deactivaing all datasets
	          // so we need to remove all references to our trackable entities
	          for (var url in dataSetPromiseMap) {
	            _loop(url);
	          }
	        });
	      };
	    });

	    var videoEyeFrustum = undefined;
	    var videoBackgroundConfig = undefined;

	    window.addEventListener('orientationchange', function () {
	      calculateVideoEyeFrustum();
	    });

	    _Channel2['default'].events.on('unload', function (channel) {
	      if (Vuforia.states) {
	        var state = Vuforia.states[channel.id];
	        if (state) {
	          delete Vuforia.states[channel.id];
	          if (!channel.inLoad) initializeDefault();
	        }
	      }
	    });

	    _Channel2['default'].events.on('focus', function (channel) {
	      if (Vuforia.states) {
	        if (Vuforia.states[channel.id]) {
	          _setStateForChannel(channel)['catch'](function (e) {
	            (0, _alert2['default'])('Unable to restore Vuforia state', e);
	          });
	        }
	      }
	    });

	    var _setStateForChannel = function _setStateForChannel(channel) {
	      return channel.whenFocussed().then(function () {
	        var state = Vuforia.states[channel.id];
	        if (!state) return _bluebird2['default'].reject(new Error('Must call Vuforia.initialize() first'));

	        if (state !== Vuforia.currentState) {
	          Vuforia.currentState = state;
	          return _initializeFromState(Vuforia.currentState);
	        }

	        return state;
	      });
	    };

	    var _initializeFromState = function _initializeFromState(state) {
	      return VuforiaPlugin.initialize(state.initializationOptions).then(function () {
	        if (state.initializationOptions.startCamera) {
	          state.cameraStarted = true;
	          return state;
	        }
	        return _setCameraFromState(state);
	      }).then(_loadDataSetsFromState).then(_activateDataSetsFromState).then(_setObjectTrackerFromState).then(_setHintMaxSimultaneousImageTargetsFromState);
	    };

	    var _setCameraFromState = function _setCameraFromState(state) {
	      return state.cameraStarted ? VuforiaPlugin.startCamera().then(function () {
	        return state;
	      }) : state;
	    };

	    var _loadDataSetsFromState = function _loadDataSetsFromState(state) {
	      if (state.loadedDataSetUrls) {
	        return _bluebird2['default'].all(_Object$keys(state.loadedDataSetUrls).map(function (url) {
	          return VuforiaPlugin.loadDataSet({ url: url });
	        })).then(function () {
	          return state;
	        });
	      }
	      return state;
	    };

	    var _activateDataSetsFromState = function _activateDataSetsFromState(state) {
	      if (state.activatedDataSetUrls) {
	        return _bluebird2['default'].all(_Object$keys(state.activatedDataSetUrls).map(function (url) {
	          return VuforiaPlugin.activateDataSet({ url: url });
	        })).then(function () {
	          return state;
	        });
	      }
	      return state;
	    };

	    var _setObjectTrackerFromState = function _setObjectTrackerFromState(state) {
	      return state.objectTrackerStarted ? VuforiaPlugin.startObjectTracker().then(function () {
	        return state;
	      }) : state;
	    };

	    var _setHintMaxSimultaneousImageTargetsFromState = function _setHintMaxSimultaneousImageTargetsFromState(state) {
	      var max = state.hintMaxSimultaneousImageTargets;
	      return max !== undefined ? VuforiaPlugin.hintMaxSimultaneousImageTargets({ max: max }) : state;
	    };

	    _Channel2['default'].requestHandler['Vuforia.initialize'] = function (_ref) {
	      var channel = _ref.channel;
	      var data = _ref.data;

	      var state = Vuforia.states[channel.id];
	      var options = data;
	      options.url = channel.getURL();

	      if (!state) {
	        state = Vuforia.states[channel.id] = {
	          initializationOptions: options,
	          cameraStarted: false,
	          loadedDataSetUrls: {},
	          activatedDataSetUrls: {}
	        };
	      }

	      return _setStateForChannel(channel);
	    };

	    _Channel2['default'].requestHandler['Vuforia.deinitialize'] = function (_ref2) {
	      var channel = _ref2.channel;
	      var data = _ref2.data;

	      return _setStateForChannel(channel).then(function () {
	        delete Vuforia.states[channel.id];
	        VuforiaPlugin.deinitialize();
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.loadDataSet'] = function (_ref3) {
	      var channel = _ref3.channel;
	      var data = _ref3.data;

	      return _setStateForChannel(channel).then(function (state) {
	        var url = data.url;
	        var dataSetPromise = VuforiaPlugin.loadDataSet({ url: url });
	        return dataSetPromise.then(function (dataSet) {
	          state.loadedDataSetUrls[url] = true;
	        }).then(function () {
	          return dataSetPromise;
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.unloadDataSet'] = function (_ref4) {
	      var channel = _ref4.channel;
	      var data = _ref4.data;

	      return _setStateForChannel(channel).then(function (state) {
	        var url = data.url;
	        return VuforiaPlugin.unloadDataSet({ url: url }).then(function () {
	          delete state.loadedDataSetUrls[url];
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.activateDataSet'] = function (_ref5) {
	      var channel = _ref5.channel;
	      var data = _ref5.data;

	      return _setStateForChannel(channel).then(function (state) {
	        var url = data.url;
	        return VuforiaPlugin.activateDataSet({ url: url }).then(function () {
	          state.activatedDataSetUrls[url] = true;
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.deactivateDataSet'] = function (_ref6) {
	      var channel = _ref6.channel;
	      var data = _ref6.data;

	      return _setStateForChannel(channel).then(function (state) {
	        var url = data.url;
	        return VuforiaPlugin.deactivateDataSet({ url: url }).then(function () {
	          delete state.activatedDataSet[url];
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.startCamera'] = function (_ref7) {
	      var channel = _ref7.channel;
	      var data = _ref7.data;

	      return _setStateForChannel(channel).then(function (state) {
	        return VuforiaPlugin.startCamera().then(function () {
	          state.cameraStarted = true;
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.stopCamera'] = function (_ref8) {
	      var channel = _ref8.channel;
	      var data = _ref8.data;

	      return _setStateForChannel(channel).then(function (state) {
	        return VuforiaPlugin.stopCamera().then(function () {
	          state.cameraStarted = false;
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.startObjectTracker'] = function (_ref9) {
	      var channel = _ref9.channel;
	      var data = _ref9.data;

	      return _setStateForChannel(channel).then(function (state) {
	        return VuforiaPlugin.startObjectTracker().then(function () {
	          state.objectTrackerStarted = true;
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.stopObjectTracker'] = function (_ref10) {
	      var channel = _ref10.channel;
	      var data = _ref10.data;

	      return _setStateForChannel(channel).then(function (state) {
	        return VuforiaPlugin.stopObjectTracker().then(function () {
	          state.objectTrackerStarted = false;
	        });
	      });
	    };

	    _Channel2['default'].requestHandler['Vuforia.hintMaxSimultaneousImageTargets'] = function (_ref11) {
	      var channel = _ref11.channel;
	      var data = _ref11.data;

	      return _setStateForChannel(channel).then(function (state) {
	        var max = data.max;
	        return VuforiaPlugin.hintMaxSimultaneousImageTargets({ max: max }).then(function () {
	          state.hintMaxSimultaneousImageTargets = max;
	        });
	      });
	    };

	    var VuforiaVideoReality = (function (_Reality) {
	      function VuforiaVideoReality() {
	        var _this = this;

	        _classCallCheck(this, VuforiaVideoReality);

	        _Reality.call(this, {
	          type: 'VuforiaVideo',
	          referenceFrame: _entitiesDevice2['default'],
	          autoTick: false
	        });
	        var epsilon = -0.0001;
	        _Argon2['default'].on('VuforiaVideoFrameTime', function (frameTime) {
	          if (!videoEyeFrustum) return;
	          _this.frustum = videoEyeFrustum;
	          JulianDate.addSeconds(frameTime, epsilon, _this.clock.currentTime);
	          _this.clock.tick();
	        });

	        this.on('change:enabled', function (e) {
	          if (e.value) {
	            initializeDefault();
	          } else {
	            VuforiaPlugin.deinitialize();
	          }
	        });
	      }

	      _inherits(VuforiaVideoReality, _Reality);

	      return VuforiaVideoReality;
	    })(_Reality3['default']);

	    Vuforia.reality = new VuforiaVideoReality();
	  })();
	}
	module.exports = exports['default'];
	// TODO: (if we have an error here, it is most likely our fault -
	// we are doing something wrong)... either way, notify the channel that
	// their Vuforia state was unable to be recreated for some reason

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(98), __esModule: true };

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(71), __esModule: true };

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Object$defineProperty = __webpack_require__(59)["default"];

	exports["default"] = (function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;

	      _Object$defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	})();

	exports.__esModule = true;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _Object$create = __webpack_require__(68)["default"];

	exports["default"] = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = _Object$create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) subClass.__proto__ = superClass;
	};

	exports.__esModule = true;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(5);
	module.exports = function create(P, D){
	  return $.create(P, D);
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function($){
	  $.FW   = false;
	  $.path = $.core;
	  return $;
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var $        = __webpack_require__(5)
	  , $def     = __webpack_require__(27)
	  , isObject = $.isObject
	  , toObject = $.toObject;
	function wrapObjectMethod(METHOD, MODE){
	  var fn  = ($.core.Object || {})[METHOD] || Object[METHOD]
	    , f   = 0
	    , o   = {};
	  o[METHOD] = MODE == 1 ? function(it){
	    return isObject(it) ? fn(it) : it;
	  } : MODE == 2 ? function(it){
	    return isObject(it) ? fn(it) : true;
	  } : MODE == 3 ? function(it){
	    return isObject(it) ? fn(it) : false;
	  } : MODE == 4 ? function getOwnPropertyDescriptor(it, key){
	    return fn(toObject(it), key);
	  } : MODE == 5 ? function getPrototypeOf(it){
	    return fn(Object($.assertDefined(it)));
	  } : function(it){
	    return fn(toObject(it));
	  };
	  try {
	    fn('z');
	  } catch(e){
	    f = 1;
	  }
	  $def($def.S + $def.F * f, 'Object', o);
	}
	wrapObjectMethod('freeze', 1);
	wrapObjectMethod('seal', 1);
	wrapObjectMethod('preventExtensions', 1);
	wrapObjectMethod('isFrozen', 2);
	wrapObjectMethod('isSealed', 2);
	wrapObjectMethod('isExtensible', 3);
	wrapObjectMethod('getOwnPropertyDescriptor', 4);
	wrapObjectMethod('getPrototypeOf', 5);
	wrapObjectMethod('keys');
	wrapObjectMethod('getOwnPropertyNames');

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Constants to determine how much time advances with each call
	     * to {@link Clock#tick}.
	     *
	     * @namespace
	     * @alias ClockStep
	     *
	     * @see Clock
	     * @see ClockRange
	     */
	    var ClockStep = {
	        /**
	         * {@link Clock#tick} advances the current time by a fixed step,
	         * which is the number of seconds specified by {@link Clock#multiplier}.
	         *
	         * @type {Number}
	         * @constant
	         */
	        TICK_DEPENDENT : 0,

	        /**
	         * {@link Clock#tick} advances the current time by the amount of system
	         * time elapsed since the previous call multiplied by {@link Clock#multiplier}.
	         *
	         * @type {Number}
	         * @constant
	         */
	        SYSTEM_CLOCK_MULTIPLIER : 1,

	        /**
	         * {@link Clock#tick} sets the clock to the current system time;
	         * ignoring all other settings.
	         *
	         * @type {Number}
	         * @constant
	         */
	        SYSTEM_CLOCK : 2
	    };

	    return freezeObject(ClockStep);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Constants to determine how an interpolated value is extrapolated
	     * when querying outside the bounds of available data.
	     * @namespace
	     * @alias ExtrapolationType
	     *
	     * @see SampledProperty
	     */
	    var ExtrapolationType = {
	        /**
	         * No extrapolation occurs.
	         *
	         * @type {Number}
	         * @constant
	         */
	        NONE : 0,

	        /**
	         * The first or last value is used when outside the range of sample data.
	         *
	         * @type {Number}
	         * @constant
	         */
	        HOLD : 1,

	        /**
	         * The value is extrapolated.
	         *
	         * @type {Number}
	         * @constant
	         */
	        EXTRAPOLATE : 2
	    };

	    return freezeObject(ExtrapolationType);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7),
	        __webpack_require__(16),
	        __webpack_require__(53)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject,
	        JulianDate,
	        TimeInterval) {
	    "use strict";

	    var MINIMUM_VALUE = freezeObject(JulianDate.fromIso8601('0000-01-01T00:00:00Z'));
	    var MAXIMUM_VALUE = freezeObject(JulianDate.fromIso8601('9999-12-31T24:00:00Z'));
	    var MAXIMUM_INTERVAL = freezeObject(new TimeInterval({
	        start : MINIMUM_VALUE,
	        stop : MAXIMUM_VALUE
	    }));

	    /**
	     * Constants related to ISO8601 support.
	     *
	     * @namespace
	     * @alias Iso8601
	     *
	     * @see {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601 on Wikipedia}
	     * @see JulianDate
	     * @see TimeInterval
	     */
	    var Iso8601 = {
	        /**
	         * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
	         * This is equivalent to the date string '0000-01-01T00:00:00Z'
	         */
	        MINIMUM_VALUE : MINIMUM_VALUE,

	        /**
	         * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
	         * This is equivalent to the date string '9999-12-31T24:00:00Z'
	         */
	        MAXIMUM_VALUE : MAXIMUM_VALUE,

	        /**
	         * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
	         * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
	         */
	        MAXIMUM_INTERVAL : MAXIMUM_INTERVAL
	    };

	    return Iso8601;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Constants for time conversions like those done by {@link JulianDate}.
	     *
	     * @namespace
	     * @alias TimeConstants
	     *
	     * @see JulianDate
	     *
	     * @private
	     */
	    var TimeConstants = {
	        /**
	         * The number of seconds in one millisecond: <code>0.001</code>
	         * @type {Number}
	         * @constant
	         */
	        SECONDS_PER_MILLISECOND : 0.001,

	        /**
	         * The number of seconds in one minute: <code>60</code>.
	         * @type {Number}
	         * @constant
	         */
	        SECONDS_PER_MINUTE : 60.0,

	        /**
	         * The number of minutes in one hour: <code>60</code>.
	         * @type {Number}
	         * @constant
	         */
	        MINUTES_PER_HOUR : 60.0,

	        /**
	         * The number of hours in one day: <code>24</code>.
	         * @type {Number}
	         * @constant
	         */
	        HOURS_PER_DAY : 24.0,

	        /**
	         * The number of seconds in one hour: <code>3600</code>.
	         * @type {Number}
	         * @constant
	         */
	        SECONDS_PER_HOUR : 3600.0,

	        /**
	         * The number of minutes in one day: <code>1440</code>.
	         * @type {Number}
	         * @constant
	         */
	        MINUTES_PER_DAY : 1440.0,

	        /**
	         * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.
	         * @type {Number}
	         * @constant
	         */
	        SECONDS_PER_DAY : 86400.0,

	        /**
	         * The number of days in one Julian century: <code>36525</code>.
	         * @type {Number}
	         * @constant
	         */
	        DAYS_PER_JULIAN_CENTURY : 36525.0,

	        /**
	         * One trillionth of a second.
	         * @type {Number}
	         * @constant
	         */
	        PICOSECOND : 0.000000001,

	        /**
	         * The number of days to subtract from a Julian date to determine the
	         * modified Julian date, which gives the number of days since midnight
	         * on November 17, 1858.
	         * @type {Number}
	         * @constant
	         */
	        MODIFIED_JULIAN_DATE_DIFFERENCE : 2400000.5
	    };

	    return freezeObject(TimeConstants);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Provides the type of time standards which JulianDate can take as input.
	     *
	     * @namespace
	     * @alias TimeStandard
	     *
	     * @see JulianDate
	     */
	    var TimeStandard = {
	        /**
	         * Represents the coordinated Universal Time (UTC) time standard.
	         *
	         * UTC is related to TAI according to the relationship
	         * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
	         * seconds which have been introduced as of the time in TAI.
	         *
	         */
	        UTC : 0,

	        /**
	         * Represents the International Atomic Time (TAI) time standard.
	         * TAI is the principal time standard to which the other time standards are related.
	         */
	        TAI : 1
	    };

	    return freezeObject(TimeStandard);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(173),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(178)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        clone,
	        defined,
	        DeveloperError,
	        loadText) {
	    "use strict";

	    var defaultHeaders = {
	        Accept : 'application/json,*/*;q=0.01'
	    };

	    // note: &#42;&#47;&#42; below is */* but that ends the comment block early
	    /**
	     * Asynchronously loads the given URL as JSON.  Returns a promise that will resolve to
	     * a JSON object once loaded, or reject if the URL failed to load.  The data is loaded
	     * using XMLHttpRequest, which means that in order to make requests to another origin,
	     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
	     * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not
	     * already specified.
	     *
	     * @exports loadJson
	     *
	     * @param {String|Promise} url The URL to request, or a promise for the URL.
	     * @param {Object} [headers] HTTP headers to send with the request.
	     * 'Accept: application/json,&#42;&#47;&#42;;q=0.01' is added to the request headers automatically
	     * if not specified.
	     * @returns {Promise} a promise that will resolve to the requested data when loaded.
	     *
	     * @see loadText
	     * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	     * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	     *
	     * @example
	     * Cesium.loadJson('http://someUrl.com/someJson.txt').then(function(jsonData) {
	     *     // Do something with the JSON object
	     * }).otherwise(function(error) {
	     *     // an error occurred
	     * });
	     */
	    var loadJson = function loadJson(url, headers) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(url)) {
	            throw new DeveloperError('url is required.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(headers)) {
	            headers = defaultHeaders;
	        } else if (!defined(headers.Accept)) {
	            // clone before adding the Accept header
	            headers = clone(headers);
	            headers.Accept = defaultHeaders.Accept;
	        }

	        return loadText(url, headers).then(function(value) {
	            return JSON.parse(value);
	        });
	    };

	    return loadJson;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(118),
	        __webpack_require__(54),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        EventHelper,
	        TimeIntervalCollection,
	        Property) {
	    "use strict";

	    function subscribeAll(property, eventHelper, definitionChanged, intervals) {
	        var callback = function() {
	            definitionChanged.raiseEvent(property);
	        };

	        var items = [];
	        eventHelper.removeAll();
	        var length = intervals.length;
	        for (var i = 0; i < length; i++) {
	            var interval = intervals.get(i);
	            if (defined(interval.data) && items.indexOf(interval.data) === -1) {
	                eventHelper.add(interval.data.definitionChanged, callback);
	            }
	        }
	    }

	    /**
	     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
	     * data property of each {@link TimeInterval} is another Property instance which is
	     * evaluated at the provided time.
	     *
	     * @alias CompositeProperty
	     * @constructor
	     *
	     * @see CompositeMaterialProperty
	     * @see CompositePositionProperty
	     *
	     * @example
	     * var constantProperty = ...;
	     * var sampledProperty = ...;
	     *
	     * //Create a composite property from two previously defined properties
	     * //where the property is valid on August 1st, 2012 and uses a constant
	     * //property for the first half of the day and a sampled property for the
	     * //remaining half.
	     * var composite = new Cesium.CompositeProperty();
	     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',
	     *     data : constantProperty
	     * }));
	     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',
	     *     isStartIncluded : false,
	     *     isStopIncluded : false,
	     *     data : sampledProperty
	     * }));
	     */
	    var CompositeProperty = function() {
	        this._eventHelper = new EventHelper();
	        this._definitionChanged = new Event();
	        this._intervals = new TimeIntervalCollection();
	        this._intervals.changedEvent.addEventListener(CompositeProperty.prototype._intervalsChanged, this);
	    };

	    defineProperties(CompositeProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof CompositeProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._intervals.isEmpty;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever setValue is called with data different
	         * than the current value.
	         * @memberof CompositeProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the interval collection.
	         * @memberof CompositeProperty.prototype
	         *
	         * @type {TimeIntervalCollection}
	         */
	        intervals : {
	            get : function() {
	                return this._intervals;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    CompositeProperty.prototype.getValue = function(time, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required');
	        }
	        //>>includeEnd('debug');

	        var innerProperty = this._intervals.findDataForIntervalContainingDate(time);
	        if (defined(innerProperty)) {
	            return innerProperty.getValue(time, result);
	        }
	        return undefined;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    CompositeProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof CompositeProperty && //
	                this._intervals.equals(other._intervals, Property.equals));
	    };

	    /**
	     * @private
	     */
	    CompositeProperty.prototype._intervalsChanged = function() {
	        subscribeAll(this, this._eventHelper, this._definitionChanged, this._intervals);
	        this._definitionChanged.raiseEvent(this);
	    };

	    return CompositeProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(21),
	        __webpack_require__(57)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        ReferenceFrame,
	        PositionProperty) {
	    "use strict";

	    /**
	     * A {@link PositionProperty} whose value does not change in respect to the
	     * {@link ReferenceFrame} in which is it defined.
	     *
	     * @alias ConstantPositionProperty
	     * @constructor
	     *
	     * @param {Cartesian3} [value] The property value.
	     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	     */
	    var ConstantPositionProperty = function(value, referenceFrame) {
	        this._definitionChanged = new Event();
	        this._value = Cartesian3.clone(value);
	        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
	    };

	    defineProperties(ConstantPositionProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof ConstantPositionProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return !defined(this._value) || this._referenceFrame === ReferenceFrame.FIXED;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof ConstantPositionProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the reference frame in which the position is defined.
	         * @memberof ConstantPositionProperty.prototype
	         * @type {ReferenceFrame}
	         * @default ReferenceFrame.FIXED;
	         */
	        referenceFrame : {
	            get : function() {
	                return this._referenceFrame;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time in the fixed frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    ConstantPositionProperty.prototype.getValue = function(time, result) {
	        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
	    };

	    /**
	     * Sets the value of the property.
	     *
	     * @param {Cartesian3} value The property value.
	     * @param {ReferenceFrame} [referenceFrame=this.referenceFrame] The reference frame in which the position is defined.
	     */
	    ConstantPositionProperty.prototype.setValue = function(value, referenceFrame) {
	        var definitionChanged = false;
	        if (!Cartesian3.equals(this._value, value)) {
	            definitionChanged = true;
	            this._value = Cartesian3.clone(value);
	        }
	        if (defined(referenceFrame) && this._referenceFrame !== referenceFrame) {
	            definitionChanged = true;
	            this._referenceFrame = referenceFrame;
	        }
	        if (definitionChanged) {
	            this._definitionChanged.raiseEvent(this);
	        }
	    };

	    /**
	     * Gets the value of the property at the provided time and in the provided reference frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    ConstantPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        if (!defined(referenceFrame)) {
	            throw new DeveloperError('referenceFrame is required.');
	        }
	        //>>includeEnd('debug');

	        return PositionProperty.convertToReferenceFrame(time, this._value, this._referenceFrame, referenceFrame, result);
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    ConstantPositionProperty.prototype.equals = function(other) {
	        return this === other ||
	               (other instanceof ConstantPositionProperty &&
	                Cartesian3.equals(this._value, other._value) &&
	                this._referenceFrame === other._referenceFrame);
	    };

	    return ConstantPositionProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(46),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(37),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(29),
	        __webpack_require__(44),
	        __webpack_require__(35),
	        __webpack_require__(55),
	        __webpack_require__(124),
	        __webpack_require__(181),
	        __webpack_require__(81),
	        __webpack_require__(186),
	        __webpack_require__(8),
	        __webpack_require__(141),
	        __webpack_require__(187),
	        __webpack_require__(126),
	        __webpack_require__(127),
	        __webpack_require__(129),
	        __webpack_require__(130),
	        __webpack_require__(131),
	        __webpack_require__(132),
	        __webpack_require__(133),
	        __webpack_require__(134),
	        __webpack_require__(195),
	        __webpack_require__(10),
	        __webpack_require__(135),
	        __webpack_require__(140)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        createGuid,
	        defaultValue,
	        defined,
	        defineProperties,
	        deprecationWarning,
	        DeveloperError,
	        Event,
	        Matrix3,
	        Matrix4,
	        Quaternion,
	        Transforms,
	        BillboardGraphics,
	        BoxGraphics,
	        ConstantPositionProperty,
	        CorridorGraphics,
	        createPropertyDescriptor,
	        createRawPropertyDescriptor,
	        CylinderGraphics,
	        EllipseGraphics,
	        EllipsoidGraphics,
	        LabelGraphics,
	        ModelGraphics,
	        PathGraphics,
	        PointGraphics,
	        PolygonGraphics,
	        PolylineGraphics,
	        PolylineVolumeGraphics,
	        Property,
	        RectangleGraphics,
	        WallGraphics) {
	    "use strict";

	    function createConstantPositionProperty(value) {
	        return new ConstantPositionProperty(value);
	    }

	    function createPositionPropertyDescriptor(name) {
	        return createPropertyDescriptor(name, undefined, createConstantPositionProperty);
	    }

	    function createPropertyTypeDescriptor(name, Type) {
	        return createPropertyDescriptor(name, undefined, function(value) {
	            if (value instanceof Type) {
	                return value;
	            }
	            return new Type(value);
	        });
	    }

	    /**
	     * Entity instances aggregate multiple forms of visualization into a single high-level object.
	     * They can be created manually and added to {@link Viewer#entities} or be produced by
	     * data sources, such as {@link CzmlDataSource} and {@link GeoJsonDataSource}.
	     * @alias Entity
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {String} [options.id] A unique identifier for this object. If none is provided, a GUID is generated.
	     * @param {String} [options.name] A human readable name to display to users. It does not have to be unique.
	     * @param {Boolean} [options.show] A boolean value indicating if the entity and its children are displayed.
	     * @param {Property} [options.description] A string Property specifying an HTML description for this entity.
	     * @param {PositionProperty} [options.position] A Property specifying the entity position.
	     * @param {Property} [options.orientation] A Property specifying the entity orientation.
	     * @param {Property} [options.viewFrom] A suggested initial offset for viewing this object.
	     * @param {Entity} [options.parent] A parent entity to associate with this entity.
	     * @param {BillboardGraphics} [options.billboard] A billboard to associate with this entity.
	     * @param {BoxGraphics} [options.box] A box to associate with this entity.
	     * @param {CorridorGraphics} [options.corridor] A corridor to associate with this entity.
	     * @param {CylinderGraphics} [options.cylinder] A cylinder to associate with this entity.
	     * @param {EllipseGraphics} [options.ellipse] A ellipse to associate with this entity.
	     * @param {EllipsoidGraphics} [options.ellipsoid] A ellipsoid to associate with this entity.
	     * @param {LabelGraphics} [options.label] A options.label to associate with this entity.
	     * @param {ModelGraphics} [options.model] A model to associate with this entity.
	     * @param {PathGraphics} [options.path] A path to associate with this entity.
	     * @param {PointGraphics} [options.point] A point to associate with this entity.
	     * @param {PolygonGraphics} [options.polygon] A polygon to associate with this entity.
	     * @param {PolylineGraphics} [options.polyline] A polyline to associate with this entity.
	     * @param {PolylineVolumeGraphics} [options.polylineVolume] A polylineVolume to associate with this entity.
	     * @param {RectangleGraphics} [options.rectangle] A rectangle to associate with this entity.
	     * @param {WallGraphics} [options.wall] A wall to associate with this entity.
	     *
	     * @see {@link http://cesiumjs.org/2015/02/02/Visualizing-Spatial-Data/|Visualizing Special Data}
	     */
	    var Entity = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        var id = options.id;
	        if (typeof options === 'string') {
	            deprecationWarning('Entity', 'The Entity constructor taking a string was deprecated in Cesium 1.5.  It will be removed in 1.9.  Use "new Entity({ id : \'id\'})" instead.');
	            id = options;
	            options = defaultValue.EMPTY_OBJECT;
	        }

	        if (!defined(id)) {
	            id = createGuid();
	        }

	        this._availability = undefined;
	        this._id = id;
	        this._definitionChanged = new Event();
	        this._name = options.name;
	        this._show = defaultValue(options.show, true);
	        this._parent = undefined;
	        this._propertyNames = ['billboard', 'box', 'corridor', 'cylinder', 'description', 'ellipse', //
	                               'ellipsoid', 'label', 'model', 'orientation', 'path', 'point', 'polygon', //
	                               'polyline', 'polylineVolume', 'position', 'rectangle', 'viewFrom', 'wall'];

	        this._billboard = undefined;
	        this._billboardSubscription = undefined;
	        this._box = undefined;
	        this._boxSubscription = undefined;
	        this._corridor = undefined;
	        this._corridorSubscription = undefined;
	        this._cylinder = undefined;
	        this._cylinderSubscription = undefined;
	        this._description = undefined;
	        this._descriptionSubscription = undefined;
	        this._ellipse = undefined;
	        this._ellipseSubscription = undefined;
	        this._ellipsoid = undefined;
	        this._ellipsoidSubscription = undefined;
	        this._label = undefined;
	        this._labelSubscription = undefined;
	        this._model = undefined;
	        this._modelSubscription = undefined;
	        this._orientation = undefined;
	        this._orientationSubscription = undefined;
	        this._path = undefined;
	        this._pathSubscription = undefined;
	        this._point = undefined;
	        this._pointSubscription = undefined;
	        this._polygon = undefined;
	        this._polygonSubscription = undefined;
	        this._polyline = undefined;
	        this._polylineSubscription = undefined;
	        this._polylineVolume = undefined;
	        this._polylineVolumeSubscription = undefined;
	        this._position = undefined;
	        this._positionSubscription = undefined;
	        this._rectangle = undefined;
	        this._rectangleSubscription = undefined;
	        this._viewFrom = undefined;
	        this._viewFromSubscription = undefined;
	        this._wall = undefined;
	        this._wallSubscription = undefined;
	        this._children = [];

	        this.parent = options.parent;
	        this.merge(options);
	    };

	    function updateShow(entity, isShowing) {
	        var children = entity._children;
	        var length = children.length;
	        for (var i = 0; i < length; i++) {
	            var child = children[i];
	            var childShow = child._show;
	            var oldValue = !isShowing && childShow;
	            var newValue = isShowing && childShow;
	            if (oldValue !== newValue) {
	                child._definitionChanged.raiseEvent(child, 'isShowing', newValue, oldValue);
	            }
	        }
	        entity._definitionChanged.raiseEvent(entity, 'isShowing', isShowing, !isShowing);
	    }

	    defineProperties(Entity.prototype, {
	        /**
	         * The availability, if any, associated with this object.
	         * If availability is undefined, it is assumed that this object's
	         * other properties will return valid data for any provided time.
	         * If availability exists, the objects other properties will only
	         * provide valid data if queried within the given interval.
	         * @memberof Entity.prototype
	         * @type {TimeIntervalCollection}
	         */
	        availability : createRawPropertyDescriptor('availability'),
	        /**
	         * Gets the unique ID associated with this object.
	         * @memberof Entity.prototype
	         * @type {String}
	         */
	        id : {
	            get : function() {
	                return this._id;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof Entity.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets or sets the name of the object.  The name is intended for end-user
	         * consumption and does not need to be unique.
	         * @memberof Entity.prototype
	         * @type {String}
	         */
	        name : createRawPropertyDescriptor('name'),
	        /**
	         * Gets or sets whether this entity should be displayed. When set to true,
	         * the entity is only displayed if the parent entity's show property is also true.
	         * @memberof Entity.prototype
	         * @type {Boolean}
	         */
	        show : {
	            get : function() {
	                return this._show;
	            },
	            set : function(value) {
	                //>>includeStart('debug', pragmas.debug);
	                if (!defined(value)) {
	                    throw new DeveloperError('value is required.');
	                }
	                //>>includeEnd('debug');

	                if (value === this._show) {
	                    return;
	                }

	                var wasShowing = this.isShowing;
	                this._show = value;
	                var isShowing = this.isShowing;

	                if (wasShowing !== isShowing) {
	                    updateShow(this, isShowing);
	                }

	                this._definitionChanged.raiseEvent(this, 'show', value, !value);
	            }
	        },
	        /**
	         * Gets whether this entity is being displayed, taking into account
	         * the visibility of any ancestor entities.
	         * @memberof Entity.prototype
	         * @type {Boolean}
	         */
	        isShowing : {
	            get : function() {
	                return this._show && (!defined(this._parent) || this._parent._show);
	            }
	        },
	        /**
	         * Gets or sets the parent object.
	         * @memberof Entity.prototype
	         * @type {Entity}
	         */
	        parent : {
	            get : function() {
	                return this._parent;
	            },
	            set : function(value) {
	                var oldValue = this._parent;

	                if (oldValue === value) {
	                    return;
	                }

	                var wasShowing = this.isShowing;
	                if (defined(oldValue)) {
	                    var index = oldValue._children.indexOf(this);
	                    oldValue._children.splice(index, 1);
	                }

	                this._parent = value;
	                value._children.push(this);

	                var isShowing = this.isShowing;

	                if (wasShowing !== isShowing) {
	                    updateShow(this, isShowing);
	                }

	                this._definitionChanged.raiseEvent(this, 'parent', value, oldValue);
	            }
	        },
	        /**
	         * Gets the names of all properties registered on this instance.
	         * @memberof Entity.prototype
	         * @type {Event}
	         */
	        propertyNames : {
	            get : function() {
	                return this._propertyNames;
	            }
	        },
	        /**
	         * Gets or sets the billboard.
	         * @memberof Entity.prototype
	         * @type {BillboardGraphics}
	         */
	        billboard : createPropertyTypeDescriptor('billboard', BillboardGraphics),
	        /**
	         * Gets or sets the box.
	         * @memberof Entity.prototype
	         * @type {BoxGraphics}
	         */
	        box : createPropertyTypeDescriptor('box', BoxGraphics),
	        /**
	         * Gets or sets the corridor.
	         * @memberof Entity.prototype
	         * @type {CorridorGraphics}
	         */
	        corridor : createPropertyTypeDescriptor('corridor', CorridorGraphics),
	        /**
	         * Gets or sets the cylinder.
	         * @memberof Entity.prototype
	         * @type {CylinderGraphics}
	         */
	        cylinder : createPropertyTypeDescriptor('cylinder', CylinderGraphics),
	        /**
	         * Gets or sets the description.
	         * @memberof Entity.prototype
	         * @type {Property}
	         */
	        description : createPropertyDescriptor('description'),
	        /**
	         * Gets or sets the ellipse.
	         * @memberof Entity.prototype
	         * @type {EllipseGraphics}
	         */
	        ellipse : createPropertyTypeDescriptor('ellipse', EllipseGraphics),
	        /**
	         * Gets or sets the ellipsoid.
	         * @memberof Entity.prototype
	         * @type {EllipsoidGraphics}
	         */
	        ellipsoid : createPropertyTypeDescriptor('ellipsoid', EllipsoidGraphics),
	        /**
	         * Gets or sets the label.
	         * @memberof Entity.prototype
	         * @type {LabelGraphics}
	         */
	        label : createPropertyTypeDescriptor('label', LabelGraphics),
	        /**
	         * Gets or sets the model.
	         * @memberof Entity.prototype
	         * @type {ModelGraphics}
	         */
	        model : createPropertyTypeDescriptor('model', ModelGraphics),
	        /**
	         * Gets or sets the orientation.
	         * @memberof Entity.prototype
	         * @type {Property}
	         */
	        orientation : createPropertyDescriptor('orientation'),
	        /**
	         * Gets or sets the path.
	         * @memberof Entity.prototype
	         * @type {PathGraphics}
	         */
	        path : createPropertyTypeDescriptor('path', PathGraphics),
	        /**
	         * Gets or sets the point graphic.
	         * @memberof Entity.prototype
	         * @type {PointGraphics}
	         */
	        point : createPropertyTypeDescriptor('point', PointGraphics),
	        /**
	         * Gets or sets the polygon.
	         * @memberof Entity.prototype
	         * @type {PolygonGraphics}
	         */
	        polygon : createPropertyTypeDescriptor('polygon', PolygonGraphics),
	        /**
	         * Gets or sets the polyline.
	         * @memberof Entity.prototype
	         * @type {PolylineGraphics}
	         */
	        polyline : createPropertyTypeDescriptor('polyline', PolylineGraphics),
	        /**
	         * Gets or sets the polyline volume.
	         * @memberof Entity.prototype
	         * @type {PolylineVolumeGraphics}
	         */
	        polylineVolume : createPropertyTypeDescriptor('polylineVolume', PolylineVolumeGraphics),
	        /**
	         * Gets or sets the position.
	         * @memberof Entity.prototype
	         * @type {PositionProperty}
	         */
	        position : createPositionPropertyDescriptor('position'),
	        /**
	         * Gets or sets the rectangle.
	         * @memberof Entity.prototype
	         * @type {RectangleGraphics}
	         */
	        rectangle : createPropertyTypeDescriptor('rectangle', RectangleGraphics),
	        /**
	         * Gets or sets the suggested initial offset for viewing this object
	         * with the camera.  The offset is defined in the east-north-up reference frame.
	         * @memberof Entity.prototype
	         * @type {Property}
	         */
	        viewFrom : createPropertyDescriptor('viewFrom'),
	        /**
	         * Gets or sets the wall.
	         * @memberof Entity.prototype
	         * @type {WallGraphics}
	         */
	        wall : createPropertyTypeDescriptor('wall', WallGraphics)
	    });

	    /**
	     * Given a time, returns true if this object should have data during that time.
	     *
	     * @param {JulianDate} time The time to check availability for.
	     * @returns true if the object should have data during the provided time, false otherwise.
	     */
	    Entity.prototype.isAvailable = function(time) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        //>>includeEnd('debug');

	        var availability = this._availability;
	        return !defined(availability) || availability.contains(time);
	    };

	    /**
	     * Adds a property to this object.  Once a property is added, it can be
	     * observed with {@link Entity#definitionChanged} and composited
	     * with {@link CompositeEntityCollection}
	     *
	     * @param {String} propertyName The name of the property to add.
	     *
	     * @exception {DeveloperError} "propertyName" is a reserved property name.
	     * @exception {DeveloperError} "propertyName" is already a registered property.
	     */
	    Entity.prototype.addProperty = function(propertyName) {
	        var propertyNames = this._propertyNames;

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(propertyName)) {
	            throw new DeveloperError('propertyName is required.');
	        }
	        if (propertyNames.indexOf(propertyName) !== -1) {
	            throw new DeveloperError(propertyName + ' is already a registered property.');
	        }
	        if (propertyName in this) {
	            throw new DeveloperError(propertyName + ' is a reserved property name.');
	        }
	        //>>includeEnd('debug');

	        propertyNames.push(propertyName);
	        Object.defineProperty(this, propertyName, createRawPropertyDescriptor(propertyName, true));
	    };

	    /**
	     * Removed a property previously added with addProperty.
	     *
	     * @param {String} propertyName The name of the property to remove.
	     *
	     * @exception {DeveloperError} "propertyName" is a reserved property name.
	     * @exception {DeveloperError} "propertyName" is not a registered property.
	     */
	    Entity.prototype.removeProperty = function(propertyName) {
	        var propertyNames = this._propertyNames;

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(propertyName)) {
	            throw new DeveloperError('propertyName is required.');
	        }
	        if (propertyNames.indexOf(propertyName) === -1) {
	            throw new DeveloperError(propertyName + ' is not a registered property.');
	        }
	        //>>includeEnd('debug');

	        this._propertyNames.push(propertyName);
	        delete this[propertyName];
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {Entity} source The object to be merged into this object.
	     */
	    Entity.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        //Name, show, and availability are not Property objects and are currently handled differently.
	        //source.show is intentionally ignored because this.show always has a value.
	        this.name = defaultValue(this.name, source.name);
	        this.availability = defaultValue(source.availability, this.availability);

	        var propertyNames = this._propertyNames;
	        var sourcePropertyNames = defined(source._propertyNames) ? source._propertyNames : Object.keys(source);
	        var propertyNamesLength = sourcePropertyNames.length;
	        for (var i = 0; i < propertyNamesLength; i++) {
	            var name = sourcePropertyNames[i];

	            //Ignore parent when merging, this only happens at construction time.
	            if (name === 'parent') {
	                continue;
	            }

	            var targetProperty = this[name];
	            var sourceProperty = source[name];

	            //Custom properties that are registered on the source entity must also
	            //get registered on this entity.
	            if (!defined(targetProperty) && propertyNames.indexOf(name) === -1) {
	                this.addProperty(name);
	            }

	            if (defined(sourceProperty)) {
	                if (defined(targetProperty)) {
	                    if (defined(targetProperty.merge)) {
	                        targetProperty.merge(sourceProperty);
	                    }
	                } else if (defined(sourceProperty.merge) && defined(sourceProperty.clone)) {
	                    this[name] = sourceProperty.clone();
	                } else {
	                    this[name] = sourceProperty;
	                }
	            }
	        }
	    };

	    var matrix3Scratch = new Matrix3();
	    var positionScratch = new Cartesian3();
	    var orientationScratch = new Quaternion();

	    /**
	     * @private
	     */
	    Entity.prototype._getModelMatrix = function(time, result) {
	        var position = Property.getValueOrUndefined(this._position, time, positionScratch);
	        if (!defined(position)) {
	            return undefined;
	        }
	        var orientation = Property.getValueOrUndefined(this._orientation, time, orientationScratch);
	        if (!defined(orientation)) {
	            result = Transforms.eastNorthUpToFixedFrame(position, undefined, result);
	        } else {
	            result = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, result);
	        }
	        return result;
	    };

	    return Entity;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(161),
	        __webpack_require__(46),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(37),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(76),
	        __webpack_require__(16),
	        __webpack_require__(36),
	        __webpack_require__(53),
	        __webpack_require__(82)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        AssociativeArray,
	        createGuid,
	        defined,
	        defineProperties,
	        deprecationWarning,
	        DeveloperError,
	        Event,
	        Iso8601,
	        JulianDate,
	        RuntimeError,
	        TimeInterval,
	        Entity) {
	    "use strict";

	    var entityOptionsScratch = {
	        id : undefined
	    };

	    function fireChangedEvent(collection) {
	        if (collection._suspendCount === 0) {
	            var added = collection._addedEntities;
	            var removed = collection._removedEntities;
	            var changed = collection._changedEntities;
	            if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {
	                collection._collectionChanged.raiseEvent(collection, added.values, removed.values, changed.values);
	                added.removeAll();
	                removed.removeAll();
	                changed.removeAll();
	            }
	        }
	    }

	    /**
	     * An observable collection of {@link Entity} instances where each entity has a unique id.
	     * @alias EntityCollection
	     * @constructor
	     */
	    var EntityCollection = function() {
	        this._entities = new AssociativeArray();
	        this._addedEntities = new AssociativeArray();
	        this._removedEntities = new AssociativeArray();
	        this._changedEntities = new AssociativeArray();
	        this._suspendCount = 0;
	        this._collectionChanged = new Event();
	        this._id = createGuid();
	    };

	    /**
	     * Prevents {@link EntityCollection#collectionChanged} events from being raised
	     * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
	     * point a single event will be raised that covers all suspended operations.
	     * This allows for many items to be added and removed efficiently.
	     * This function can be safely called multiple times as long as there
	     * are corresponding calls to {@link EntityCollection#resumeEvents}.
	     */
	    EntityCollection.prototype.suspendEvents = function() {
	        this._suspendCount++;
	    };

	    /**
	     * Resumes raising {@link EntityCollection#collectionChanged} events immediately
	     * when an item is added or removed.  Any modifications made while while events were suspended
	     * will be triggered as a single event when this function is called.
	     * This function is reference counted and can safely be called multiple times as long as there
	     * are corresponding calls to {@link EntityCollection#resumeEvents}.
	     *
	     * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.
	     */
	    EntityCollection.prototype.resumeEvents = function() {
	        //>>includeStart('debug', pragmas.debug);
	        if (this._suspendCount === 0) {
	            throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
	        }
	        //>>includeEnd('debug');

	        this._suspendCount--;
	        fireChangedEvent(this);
	    };

	    /**
	     * The signature of the event generated by {@link EntityCollection#collectionChanged}.
	     * @function
	     *
	     * @param {EntityCollection} collection The collection that triggered the event.
	     * @param {Entity[]} added The array of {@link Entity} instances that have been added to the collection.
	     * @param {Entity[]} removed The array of {@link Entity} instances that have been removed from the collection.
	     * @param {Entity[]} changed The array of {@link Entity} instances that have been modified.
	     */
	    EntityCollection.collectionChangedEventCallback = undefined;

	    defineProperties(EntityCollection.prototype, {
	        /**
	         * Gets the event that is fired when entities are added or removed from the collection.
	         * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.
	         * @memberof EntityCollection.prototype
	         * @readonly
	         * @type {Event}
	         */
	        collectionChanged : {
	            get : function() {
	                return this._collectionChanged;
	            }
	        },
	        /**
	         * Gets a globally unique identifier for this collection.
	         * @memberof EntityCollection.prototype
	         * @readonly
	         * @type {String}
	         */
	        id : {
	            get : function() {
	                return this._id;
	            }
	        },
	        /**
	         * Gets the array of Entity instances in the collection.
	         * This array should not be modified directly.
	         * @memberof EntityCollection.prototype
	         * @readonly
	         * @type {Entity[]}
	         * @deprecated
	         */
	        entities : {
	            get : function() {
	                deprecationWarning('EntityCollection.entities', 'EntityCollection.entities has been deprecated and will be removed in Cesium 1.9, use EntityCollection.values instead');
	                return this._entities.values;
	            }
	        },
	        /**
	         * Gets the array of Entity instances in the collection.
	         * This array should not be modified directly.
	         * @memberof EntityCollection.prototype
	         * @readonly
	         * @type {Entity[]}
	         */
	        values : {
	            get : function() {
	                return this._entities.values;
	            }
	        }
	    });

	    /**
	     * Computes the maximum availability of the entities in the collection.
	     * If the collection contains a mix of infinitely available data and non-infinite data,
	     * it will return the interval pertaining to the non-infinite data only.  If all
	     * data is infinite, an infinite interval will be returned.
	     *
	     * @returns {TimeInterval} The availability of entities in the collection.
	     */
	    EntityCollection.prototype.computeAvailability = function() {
	        var startTime = Iso8601.MAXIMUM_VALUE;
	        var stopTime = Iso8601.MINIMUM_VALUE;
	        var entities = this._entities.values;
	        for (var i = 0, len = entities.length; i < len; i++) {
	            var entity = entities[i];
	            var availability = entity.availability;
	            if (defined(availability)) {
	                var start = availability.start;
	                var stop = availability.stop;
	                if (JulianDate.lessThan(start, startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {
	                    startTime = start;
	                }
	                if (JulianDate.greaterThan(stop, stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {
	                    stopTime = stop;
	                }
	            }
	        }

	        if (Iso8601.MAXIMUM_VALUE.equals(startTime)) {
	            startTime = Iso8601.MINIMUM_VALUE;
	        }
	        if (Iso8601.MINIMUM_VALUE.equals(stopTime)) {
	            stopTime = Iso8601.MAXIMUM_VALUE;
	        }
	        return new TimeInterval({
	            start : startTime,
	            stop : stopTime
	        });
	    };

	    /**
	     * Add an entity to the collection.
	     *
	     * @param {Entity} entity The entity to be added.
	     * @exception {DeveloperError} An entity with <entity.id> already exists in this collection.
	     */
	    EntityCollection.prototype.add = function(entity) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(entity)) {
	            throw new DeveloperError('entity is required.');
	        }
	        //>>includeEnd('debug');

	        if (!(entity instanceof Entity)) {
	            entity = new Entity(entity);
	        }

	        var id = entity.id;
	        var entities = this._entities;
	        if (entities.contains(id)) {
	            throw new RuntimeError('An entity with id ' + id + ' already exists in this collection.');
	        }

	        entities.set(id, entity);

	        var removedEntities = this._removedEntities;
	        if (!this._removedEntities.remove(id)) {
	            this._addedEntities.set(id, entity);
	        }
	        entity.definitionChanged.addEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);

	        fireChangedEvent(this);
	        return entity;
	    };

	    /**
	     * Removes an entity from the collection.
	     *
	     * @param {Entity} entity The entity to be removed.
	     * @returns {Boolean} true if the item was removed, false if it did not exist in the collection.
	     */
	    EntityCollection.prototype.remove = function(entity) {
	        if (!defined(entity)) {
	            return false;
	        }
	        return this.removeById(entity.id);
	    };

	    /**
	     * Returns true if the provided entity is in this collection, false otherwise.
	     *
	     * @param entity The entity.
	     * @returns {Boolean} true if the provided entity is in this collection, false otherwise.
	     */
	    EntityCollection.prototype.contains = function(entity) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(entity)) {
	            throw new DeveloperError('entity is required');
	        }
	        //>>includeEnd('debug');
	        return this._entities.get(entity.id) === entity;
	    };

	    /**
	     * Removes an entity with the provided id from the collection.
	     *
	     * @param {Object} id The id of the entity to remove.
	     * @returns {Boolean} true if the item was removed, false if no item with the provided id existed in the collection.
	     */
	    EntityCollection.prototype.removeById = function(id) {
	        if (!defined(id)) {
	            return false;
	        }

	        var entities = this._entities;
	        var entity = entities.get(id);
	        if (!this._entities.remove(id)) {
	            return false;
	        }

	        if (!this._addedEntities.remove(id)) {
	            this._removedEntities.set(id, entity);
	            this._changedEntities.remove(id);
	        }
	        this._entities.remove(id);
	        entity.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
	        fireChangedEvent(this);

	        return true;
	    };

	    /**
	     * Removes all Entities from the collection.
	     */
	    EntityCollection.prototype.removeAll = function() {
	        //The event should only contain items added before events were suspended
	        //and the contents of the collection.
	        var entities = this._entities;
	        var entitiesLength = entities.length;
	        var array = entities.values;

	        var addedEntities = this._addedEntities;
	        var removed = this._removedEntities;

	        for (var i = 0; i < entitiesLength; i++) {
	            var existingItem = array[i];
	            var existingItemId = existingItem.id;
	            var addedItem = addedEntities.get(existingItemId);
	            if (!defined(addedItem)) {
	                existingItem.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
	                removed.set(existingItemId, existingItem);
	            }
	        }

	        entities.removeAll();
	        addedEntities.removeAll();
	        this._changedEntities.removeAll();
	        fireChangedEvent(this);
	    };

	    /**
	     * Gets an entity with the specified id.
	     *
	     * @param {Object} id The id of the entity to retrieve.
	     * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.
	     */
	    EntityCollection.prototype.getById = function(id) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(id)) {
	            throw new DeveloperError('id is required.');
	        }
	        //>>includeEnd('debug');

	        return this._entities.get(id);
	    };

	    /**
	     * Gets an entity with the specified id or creates it and adds it to the collection if it does not exist.
	     *
	     * @param {Object} id The id of the entity to retrieve or create.
	     * @returns {Entity} The new or existing object.
	     */
	    EntityCollection.prototype.getOrCreateEntity = function(id) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(id)) {
	            throw new DeveloperError('id is required.');
	        }
	        //>>includeEnd('debug');

	        var entity = this._entities.get(id);
	        if (!defined(entity)) {
	            entityOptionsScratch.id = id;
	            entity = new Entity(entityOptionsScratch);
	            this.add(entity);
	        }
	        return entity;
	    };

	    EntityCollection.prototype._onEntityDefinitionChanged = function(entity) {
	        var id = entity.id;
	        if (!this._addedEntities.contains(id)) {
	            this._changedEntities.set(id, entity);
	        }
	        fireChangedEvent(this);
	    };

	    return EntityCollection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(45),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(75),
	        __webpack_require__(16),
	        __webpack_require__(123)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        binarySearch,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        ExtrapolationType,
	        JulianDate,
	        LinearApproximation) {
	    "use strict";

	    var PackableNumber = {
	        packedLength : 1,
	        pack : function(value, array, startingIndex) {
	            startingIndex = defaultValue(startingIndex, 0);
	            array[startingIndex] = value;
	        },
	        unpack : function(array, startingIndex, result) {
	            startingIndex = defaultValue(startingIndex, 0);
	            return array[startingIndex];
	        }
	    };

	    //We can't use splice for inserting new elements because function apply can't handle
	    //a huge number of arguments.  See https://code.google.com/p/chromium/issues/detail?id=56588
	    function arrayInsert(array, startIndex, items) {
	        var i;
	        var arrayLength = array.length;
	        var itemsLength = items.length;
	        var newLength = arrayLength + itemsLength;

	        array.length = newLength;
	        if (arrayLength !== startIndex) {
	            var q = arrayLength - 1;
	            for (i = newLength - 1; i >= startIndex; i--) {
	                array[i] = array[q--];
	            }
	        }

	        for (i = 0; i < itemsLength; i++) {
	            array[startIndex++] = items[i];
	        }
	    }

	    function convertDate(date, epoch) {
	        if (date instanceof JulianDate) {
	            return date;
	        }
	        if (typeof date === 'string') {
	            return JulianDate.fromIso8601(date);
	        }
	        return JulianDate.addSeconds(epoch, date, new JulianDate());
	    }

	    var timesSpliceArgs = [];
	    var valuesSpliceArgs = [];

	    var mergeNewSamples = function(epoch, times, values, newData, packedLength) {
	        var newDataIndex = 0;
	        var i;
	        var prevItem;
	        var timesInsertionPoint;
	        var valuesInsertionPoint;
	        var currentTime;
	        var nextTime;

	        while (newDataIndex < newData.length) {
	            currentTime = convertDate(newData[newDataIndex], epoch);
	            timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);
	            var timesSpliceArgsCount = 0;
	            var valuesSpliceArgsCount = 0;

	            if (timesInsertionPoint < 0) {
	                //Doesn't exist, insert as many additional values as we can.
	                timesInsertionPoint = ~timesInsertionPoint;

	                valuesInsertionPoint = timesInsertionPoint * packedLength;
	                prevItem = undefined;
	                nextTime = times[timesInsertionPoint];
	                while (newDataIndex < newData.length) {
	                    currentTime = convertDate(newData[newDataIndex], epoch);
	                    if ((defined(prevItem) && JulianDate.compare(prevItem, currentTime) >= 0) || (defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0)) {
	                        break;
	                    }
	                    timesSpliceArgs[timesSpliceArgsCount++] = currentTime;
	                    newDataIndex = newDataIndex + 1;
	                    for (i = 0; i < packedLength; i++) {
	                        valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];
	                        newDataIndex = newDataIndex + 1;
	                    }
	                    prevItem = currentTime;
	                }

	                if (timesSpliceArgsCount > 0) {
	                    valuesSpliceArgs.length = valuesSpliceArgsCount;
	                    arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);

	                    timesSpliceArgs.length = timesSpliceArgsCount;
	                    arrayInsert(times, timesInsertionPoint, timesSpliceArgs);
	                }
	            } else {
	                //Found an exact match
	                for (i = 0; i < packedLength; i++) {
	                    newDataIndex++;
	                    values[(timesInsertionPoint * packedLength) + i] = newData[newDataIndex];
	                }
	                newDataIndex++;
	            }
	        }
	    };

	    /**
	     * A {@link Property} whose value is interpolated for a given time from the
	     * provided set of samples and specified interpolation algorithm and degree.
	     * @alias SampledProperty
	     * @constructor
	     *
	     * @param {Number|Packable} type The type of property.
	     * @param {Packable[]} [derivativeTypes] When supplied, indicates that samples will contain derivative information of the specified types.
	     *
	     * @see SampledPositionProperty
	     *
	     * @example
	     * //Create a linearly interpolated Cartesian2
	     * var property = new Cesium.SampledProperty(Cesium.Cartesian2);
	     *
	     * //Populate it with data
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:00:00.00Z`), new Cesium.Cartesian2(0, 0));
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-02T00:00:00.00Z`), new Cesium.Cartesian2(4, 7));
	     *
	     * //Retrieve an interpolated value
	     * var result = property.getValue(Cesium.JulianDate.fromIso8601(`2012-08-01T12:00:00.00Z`));
	     *
	     * @example
	     * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation
	     * var property = new Cesium.SampledProperty(Number);
	     * property.setInterpolationOptions({
	     *     interpolationDegree : 3,
	     *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation
	     * });
	     *
	     * //Populate it with data
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:00:00.00Z`), 1.0);
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:01:00.00Z`), 6.0);
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:02:00.00Z`), 12.0);
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:03:30.00Z`), 5.0);
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:06:30.00Z`), 2.0);
	     *
	     * //Samples can be added in any order.
	     * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:00:30.00Z`), 6.2);
	     *
	     * //Retrieve an interpolated value
	     * var result = property.getValue(Cesium.JulianDate.fromIso8601(`2012-08-01T00:02:34.00Z`));
	     */
	    var SampledProperty = function(type, derivativeTypes) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(type)) {
	            throw new DeveloperError('type is required.');
	        }
	        //>>includeEnd('debug');

	        var innerType = type;
	        if (innerType === Number) {
	            innerType = PackableNumber;
	        }
	        var packedLength = innerType.packedLength;
	        var packedInterpolationLength = defaultValue(innerType.packedInterpolationLength, packedLength);

	        var inputOrder = 0;
	        var innerDerivativeTypes;
	        if (defined(derivativeTypes)) {
	            var length = derivativeTypes.length;
	            innerDerivativeTypes = new Array(length);
	            for (var i = 0; i < length; i++) {
	                var derivativeType = derivativeTypes[i];
	                if (derivativeType === Number) {
	                    derivativeType = PackableNumber;
	                }
	                var derivativePackedLength = derivativeType.packedLength;
	                packedLength += derivativePackedLength;
	                packedInterpolationLength += defaultValue(derivativeType.packedInterpolationLength, derivativePackedLength);
	                innerDerivativeTypes[i] = derivativeType;
	            }
	            inputOrder = length;
	        }

	        this._type = type;
	        this._innerType = innerType;
	        this._interpolationDegree = 1;
	        this._interpolationAlgorithm = LinearApproximation;
	        this._numberOfPoints = 0;
	        this._times = [];
	        this._values = [];
	        this._xTable = [];
	        this._yTable = [];
	        this._packedLength = packedLength;
	        this._packedInterpolationLength = packedInterpolationLength;
	        this._updateTableLength = true;
	        this._interpolationResult = new Array(packedInterpolationLength);
	        this._definitionChanged = new Event();
	        this._derivativeTypes = derivativeTypes;
	        this._innerDerivativeTypes = innerDerivativeTypes;
	        this._inputOrder = inputOrder;
	        this._forwardExtrapolationType = ExtrapolationType.NONE;
	        this._forwardExtrapolationDuration = 0;
	        this._backwardExtrapolationType = ExtrapolationType.NONE;
	        this._backwardExtrapolationDuration = 0;
	    };

	    defineProperties(SampledProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof SampledProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._values.length === 0;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof SampledProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the type of property.
	         * @memberof SampledProperty.prototype
	         * @type {Object}
	         */
	        type : {
	            get : function() {
	                return this._type;
	            }
	        },
	        /**
	         * Gets the derivative types used by this property.
	         * @memberof SampledProperty.prototype
	         * @type {Packable[]}
	         */
	        derivativeTypes : {
	            get : function() {
	                return this._derivativeTypes;
	            }
	        },
	        /**
	         * Gets the degree of interpolation to perform when retrieving a value.
	         * @memberof SampledProperty.prototype
	         * @type {Number}
	         * @default 1
	         */
	        interpolationDegree : {
	            get : function() {
	                return this._interpolationDegree;
	            }
	        },
	        /**
	         * Gets the interpolation algorithm to use when retrieving a value.
	         * @memberof SampledProperty.prototype
	         * @type {InterpolationAlgorithm}
	         * @default LinearApproximation
	         */
	        interpolationAlgorithm : {
	            get : function() {
	                return this._interpolationAlgorithm;
	            }
	        },
	        /**
	         * Gets or sets the type of extrapolation to perform when a value
	         * is requested at a time after any available samples.
	         * @memberof SampledProperty.prototype
	         * @type {ExtrapolationType}
	         * @default ExtrapolationType.NONE
	         */
	        forwardExtrapolationType : {
	            get : function() {
	                return this._forwardExtrapolationType;
	            },
	            set : function(value) {
	                if (this._forwardExtrapolationType !== value) {
	                    this._forwardExtrapolationType = value;
	                    this._definitionChanged.raiseEvent(this);
	                }
	            }
	        },
	        /**
	         * Gets or sets the amount of time to extrapolate forward before
	         * the property becomes undefined.  A value of 0 will extrapolate forever.
	         * @memberof SampledProperty.prototype
	         * @type {Number}
	         * @default 0
	         */
	        forwardExtrapolationDuration : {
	            get : function() {
	                return this._forwardExtrapolationDuration;
	            },
	            set : function(value) {
	                if (this._forwardExtrapolationDuration !== value) {
	                    this._forwardExtrapolationDuration = value;
	                    this._definitionChanged.raiseEvent(this);
	                }
	            }
	        },
	        /**
	         * Gets or sets the type of extrapolation to perform when a value
	         * is requested at a time before any available samples.
	         * @memberof SampledProperty.prototype
	         * @type {ExtrapolationType}
	         * @default ExtrapolationType.NONE
	         */
	        backwardExtrapolationType : {
	            get : function() {
	                return this._backwardExtrapolationType;
	            },
	            set : function(value) {
	                if (this._backwardExtrapolationType !== value) {
	                    this._backwardExtrapolationType = value;
	                    this._definitionChanged.raiseEvent(this);
	                }
	            }
	        },
	        /**
	         * Gets or sets the amount of time to extrapolate backward
	         * before the property becomes undefined.  A value of 0 will extrapolate forever.
	         * @memberof SampledProperty.prototype
	         * @type {Number}
	         * @default 0
	         */
	        backwardExtrapolationDuration : {
	            get : function() {
	                return this._backwardExtrapolationDuration;
	            },
	            set : function(value) {
	                if (this._backwardExtrapolationDuration !== value) {
	                    this._backwardExtrapolationDuration = value;
	                    this._definitionChanged.raiseEvent(this);
	                }
	            }
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    SampledProperty.prototype.getValue = function(time, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        //>>includeEnd('debug');

	        var times = this._times;
	        var timesLength = times.length;
	        if (timesLength === 0) {
	            return undefined;
	        }

	        var timeout;
	        var innerType = this._innerType;
	        var values = this._values;
	        var index = binarySearch(times, time, JulianDate.compare);

	        if (index < 0) {
	            index = ~index;

	            if (index === 0) {
	                var startTime = times[index];
	                timeout = this._backwardExtrapolationDuration;
	                if (this._backwardExtrapolationType === ExtrapolationType.NONE || (timeout !== 0 && JulianDate.secondsDifference(startTime, time) > timeout)) {
	                    return undefined;
	                }
	                if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {
	                    return innerType.unpack(values, 0, result);
	                }
	            }

	            if (index >= timesLength) {
	                index = timesLength - 1;
	                var endTime = times[index];
	                timeout = this._forwardExtrapolationDuration;
	                if (this._forwardExtrapolationType === ExtrapolationType.NONE || (timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout)) {
	                    return undefined;
	                }
	                if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {
	                    index = timesLength - 1;
	                    return innerType.unpack(values, index * innerType.packedLength, result);
	                }
	            }

	            var xTable = this._xTable;
	            var yTable = this._yTable;
	            var interpolationAlgorithm = this._interpolationAlgorithm;
	            var packedInterpolationLength = this._packedInterpolationLength;
	            var inputOrder = this._inputOrder;

	            if (this._updateTableLength) {
	                this._updateTableLength = false;
	                var numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(this._interpolationDegree, inputOrder), timesLength);
	                if (numberOfPoints !== this._numberOfPoints) {
	                    this._numberOfPoints = numberOfPoints;
	                    xTable.length = numberOfPoints;
	                    yTable.length = numberOfPoints * packedInterpolationLength;
	                }
	            }

	            var degree = this._numberOfPoints - 1;
	            if (degree < 1) {
	                return undefined;
	            }

	            var firstIndex = 0;
	            var lastIndex = timesLength - 1;
	            var pointsInCollection = lastIndex - firstIndex + 1;

	            if (pointsInCollection < degree + 1) {
	                // Use the entire range.
	            } else {
	                var computedFirstIndex = index - ((degree / 2) | 0) - 1;
	                if (computedFirstIndex < firstIndex) {
	                    computedFirstIndex = firstIndex;
	                }
	                var computedLastIndex = computedFirstIndex + degree;
	                if (computedLastIndex > lastIndex) {
	                    computedLastIndex = lastIndex;
	                    computedFirstIndex = computedLastIndex - degree;
	                    if (computedFirstIndex < firstIndex) {
	                        computedFirstIndex = firstIndex;
	                    }
	                }

	                firstIndex = computedFirstIndex;
	                lastIndex = computedLastIndex;
	            }
	            var length = lastIndex - firstIndex + 1;

	            // Build the tables
	            for (var i = 0; i < length; ++i) {
	                xTable[i] = JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);
	            }

	            if (!defined(innerType.convertPackedArrayForInterpolation)) {
	                var destinationIndex = 0;
	                var packedLength = this._packedLength;
	                var sourceIndex = firstIndex * packedLength;
	                var stop = (lastIndex + 1) * packedLength;

	                while (sourceIndex < stop) {
	                    yTable[destinationIndex] = values[sourceIndex];
	                    sourceIndex++;
	                    destinationIndex++;
	                }
	            } else {
	                innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);
	            }

	            // Interpolate!
	            var x = JulianDate.secondsDifference(time, times[lastIndex]);
	            var interpolationResult;
	            if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {
	                interpolationResult = interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, packedInterpolationLength, this._interpolationResult);
	            } else {
	                var yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
	                interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, this._interpolationResult);
	            }

	            if (!defined(innerType.unpackInterpolationResult)) {
	                return innerType.unpack(interpolationResult, 0, result);
	            }
	            return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result);
	        }
	        return innerType.unpack(values, index * this._packedLength, result);
	    };

	    /**
	     * Sets the algorithm and degree to use when interpolating a value.
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.
	     * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.
	     */
	    SampledProperty.prototype.setInterpolationOptions = function(options) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(options)) {
	            throw new DeveloperError('options is required.');
	        }
	        //>>includeEnd('debug');

	        var valuesChanged = false;

	        var interpolationAlgorithm = options.interpolationAlgorithm;
	        var interpolationDegree = options.interpolationDegree;

	        if (this._interpolationAlgorithm !== interpolationAlgorithm) {
	            this._interpolationAlgorithm = interpolationAlgorithm;
	            valuesChanged = true;
	        }

	        if (this._interpolationDegree !== interpolationDegree) {
	            this._interpolationDegree = interpolationDegree;
	            valuesChanged = true;
	        }

	        if (valuesChanged) {
	            this._updateTableLength = true;
	            this._definitionChanged.raiseEvent(this);
	        }
	    };

	    /**
	     * Adds a new sample
	     *
	     * @param {JulianDate} time The sample time.
	     * @param {Packable} value The value at the provided time.
	     * @param {Packable[]} [derivatives] The array of derivatives at the provided time.
	     */
	    SampledProperty.prototype.addSample = function(time, value, derivatives) {
	        var innerDerivativeTypes = this._innerDerivativeTypes;
	        var hasDerivatives = defined(innerDerivativeTypes);

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        if (!defined(value)) {
	            throw new DeveloperError('value is required.');
	        }
	        if (hasDerivatives && !defined(derivatives)) {
	            throw new DeveloperError('derivatives is required.');
	        }
	        //>>includeEnd('debug');

	        var innerType = this._innerType;
	        var data = [];
	        data.push(time);
	        innerType.pack(value, data, data.length);

	        if (hasDerivatives) {
	            var derivativesLength = innerDerivativeTypes.length;
	            for (var x = 0; x < derivativesLength; x++) {
	                innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
	            }
	        }
	        mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
	        this._updateTableLength = true;
	        this._definitionChanged.raiseEvent(this);
	    };

	    /**
	     * Adds an array of samples
	     *
	     * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.
	     * @param {Packable[]} values The array of values, where each value corresponds to the provided times index.
	     * @param {Array[]} [derivativeValues] An array where each item is the array of derivatives at the equivalent time index.
	     *
	     * @exception {DeveloperError} times and values must be the same length.
	     * @exception {DeveloperError} times and derivativeValues must be the same length.
	     */
	    SampledProperty.prototype.addSamples = function(times, values, derivativeValues) {
	        var innerDerivativeTypes = this._innerDerivativeTypes;
	        var hasDerivatives = defined(innerDerivativeTypes);

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(times)) {
	            throw new DeveloperError('times is required.');
	        }
	        if (!defined(values)) {
	            throw new DeveloperError('values is required.');
	        }
	        if (times.length !== values.length) {
	            throw new DeveloperError('times and values must be the same length.');
	        }
	        if (hasDerivatives && (!defined(derivativeValues) || derivativeValues.length !== times.length)) {
	            throw new DeveloperError('times and derivativeValues must be the same length.');
	        }
	        //>>includeEnd('debug');

	        var innerType = this._innerType;
	        var length = times.length;
	        var data = [];
	        for (var i = 0; i < length; i++) {
	            data.push(times[i]);
	            innerType.pack(values[i], data, data.length);

	            if (hasDerivatives) {
	                var derivatives = derivativeValues[i];
	                var derivativesLength = innerDerivativeTypes.length;
	                for (var x = 0; x < derivativesLength; x++) {
	                    innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
	                }
	            }
	        }
	        mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
	        this._updateTableLength = true;
	        this._definitionChanged.raiseEvent(this);
	    };

	    /**
	     * Adds samples as a single packed array where each new sample is represented as a date,
	     * followed by the packed representation of the corresponding value and derivatives.
	     *
	     * @param {Number[]} packedSamples The array of packed samples.
	     * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
	     */
	    SampledProperty.prototype.addSamplesPackedArray = function(packedSamples, epoch) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(packedSamples)) {
	            throw new DeveloperError('packedSamples is required.');
	        }
	        //>>includeEnd('debug');

	        mergeNewSamples(epoch, this._times, this._values, packedSamples, this._packedLength);
	        this._updateTableLength = true;
	        this._definitionChanged.raiseEvent(this);
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    SampledProperty.prototype.equals = function(other) {
	        if (this === other) {
	            return true;
	        }
	        if (!defined(other)) {
	            return false;
	        }

	        if (this._type !== other._type || //
	            this._interpolationDegree !== other._interpolationDegree || //
	            this._interpolationAlgorithm !== other._interpolationAlgorithm) {
	            return false;
	        }

	        var derivativeTypes = this._derivativeTypes;
	        var hasDerivatives = defined(derivativeTypes);
	        var otherDerivativeTypes = other._derivativeTypes;
	        var otherHasDerivatives = defined(otherDerivativeTypes);
	        if (hasDerivatives !== otherHasDerivatives) {
	            return false;
	        }

	        var i;
	        var length;
	        if (hasDerivatives) {
	            length = derivativeTypes.length;
	            if (length !== otherDerivativeTypes.length) {
	                return false;
	            }

	            for (i = 0; i < length; i++) {
	                if (derivativeTypes[i] !== otherDerivativeTypes[i]) {
	                    return false;
	                }
	            }
	        }

	        var times = this._times;
	        var otherTimes = other._times;
	        length = times.length;

	        if (length !== otherTimes.length) {
	            return false;
	        }

	        for (i = 0; i < length; i++) {
	            if (!JulianDate.equals(times[i], otherTimes[i])) {
	                return false;
	            }
	        }

	        var values = this._values;
	        var otherValues = other._values;
	        for (i = 0; i < length; i++) {
	            if (values[i] !== otherValues[i]) {
	                return false;
	            }
	        }

	        return true;
	    };

	    //Exposed for testing.
	    SampledProperty._mergeNewSamples = mergeNewSamples;

	    return SampledProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @license
	 *
	 * Grauw URI utilities
	 *
	 * See: http://hg.grauw.nl/grauw-lib/file/tip/src/uri.js
	 *
	 * @author Laurens Holst (http://www.grauw.nl/)
	 *
	 *   Copyright 2012 Laurens Holst
	 *
	 *   Licensed under the Apache License, Version 2.0 (the "License");
	 *   you may not use this file except in compliance with the License.
	 *   You may obtain a copy of the License at
	 *
	 *       http://www.apache.org/licenses/LICENSE-2.0
	 *
	 *   Unless required by applicable law or agreed to in writing, software
	 *   distributed under the License is distributed on an "AS IS" BASIS,
	 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 *   See the License for the specific language governing permissions and
	 *   limitations under the License.
	 *
	 */
	/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

		/**
		 * Constructs a URI object.
		 * @constructor
		 * @class Implementation of URI parsing and base URI resolving algorithm in RFC 3986.
		 * @param {string|URI} uri A string or URI object to create the object from.
		 */
		function URI(uri) {
			if (uri instanceof URI) {  // copy constructor
				this.scheme = uri.scheme;
				this.authority = uri.authority;
				this.path = uri.path;
				this.query = uri.query;
				this.fragment = uri.fragment;
			} else if (uri) {  // uri is URI string or cast to string
				var c = parseRegex.exec(uri);
				this.scheme = c[1];
				this.authority = c[2];
				this.path = c[3];
				this.query = c[4];
				this.fragment = c[5];
			}
		};

		// Initial values on the prototype
		URI.prototype.scheme    = null;
		URI.prototype.authority = null;
		URI.prototype.path      = '';
		URI.prototype.query     = null;
		URI.prototype.fragment  = null;

		// Regular expression from RFC 3986 appendix B
		var parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$');

		/**
		 * Returns the scheme part of the URI.
		 * In "http://example.com:80/a/b?x#y" this is "http".
		 */
		URI.prototype.getScheme = function() {
			return this.scheme;
		};

		/**
		 * Returns the authority part of the URI.
		 * In "http://example.com:80/a/b?x#y" this is "example.com:80".
		 */
		URI.prototype.getAuthority = function() {
			return this.authority;
		};

		/**
		 * Returns the path part of the URI.
		 * In "http://example.com:80/a/b?x#y" this is "/a/b".
		 * In "mailto:mike@example.com" this is "mike@example.com".
		 */
		URI.prototype.getPath = function() {
			return this.path;
		};

		/**
		 * Returns the query part of the URI.
		 * In "http://example.com:80/a/b?x#y" this is "x".
		 */
		URI.prototype.getQuery = function() {
			return this.query;
		};

		/**
		 * Returns the fragment part of the URI.
		 * In "http://example.com:80/a/b?x#y" this is "y".
		 */
		URI.prototype.getFragment = function() {
			return this.fragment;
		};

		/**
		 * Tests whether the URI is an absolute URI.
		 * See RFC 3986 section 4.3.
		 */
		URI.prototype.isAbsolute = function() {
			return !!this.scheme && !this.fragment;
		};

		///**
		//* Extensive validation of the URI against the ABNF in RFC 3986
		//*/
		//URI.prototype.validate

		/**
		 * Tests whether the URI is a same-document reference.
		 * See RFC 3986 section 4.4.
		 *
		 * To perform more thorough comparison, you can normalise the URI objects.
		 */
		URI.prototype.isSameDocumentAs = function(uri) {
			return uri.scheme == this.scheme &&
			    uri.authority == this.authority &&
			         uri.path == this.path &&
			        uri.query == this.query;
		};

		/**
		 * Simple String Comparison of two URIs.
		 * See RFC 3986 section 6.2.1.
		 *
		 * To perform more thorough comparison, you can normalise the URI objects.
		 */
		URI.prototype.equals = function(uri) {
			return this.isSameDocumentAs(uri) && uri.fragment == this.fragment;
		};

		/**
		 * Normalizes the URI using syntax-based normalization.
		 * This includes case normalization, percent-encoding normalization and path segment normalization.
		 * XXX: Percent-encoding normalization does not escape characters that need to be escaped.
		 *      (Although that would not be a valid URI in the first place. See validate().)
		 * See RFC 3986 section 6.2.2.
		 */
		URI.prototype.normalize = function() {
			this.removeDotSegments();
			if (this.scheme)
				this.scheme = this.scheme.toLowerCase();
			if (this.authority)
				this.authority = this.authority.replace(authorityRegex, replaceAuthority).
										replace(caseRegex, replaceCase);
			if (this.path)
				this.path = this.path.replace(caseRegex, replaceCase);
			if (this.query)
				this.query = this.query.replace(caseRegex, replaceCase);
			if (this.fragment)
				this.fragment = this.fragment.replace(caseRegex, replaceCase);
		};

		var caseRegex = /%[0-9a-z]{2}/gi;
		var percentRegex = /[a-zA-Z0-9\-\._~]/;
		var authorityRegex = /(.*@)?([^@:]*)(:.*)?/;

		function replaceCase(str) {
			var dec = unescape(str);
			return percentRegex.test(dec) ? dec : str.toUpperCase();
		}

		function replaceAuthority(str, p1, p2, p3) {
			return (p1 || '') + p2.toLowerCase() + (p3 || '');
		}

		/**
		 * Resolve a relative URI (this) against a base URI.
		 * The base URI must be an absolute URI.
		 * See RFC 3986 section 5.2
		 */
		URI.prototype.resolve = function(baseURI) {
			var uri = new URI();
			if (this.scheme) {
				uri.scheme = this.scheme;
				uri.authority = this.authority;
				uri.path = this.path;
				uri.query = this.query;
			} else {
				uri.scheme = baseURI.scheme;
				if (this.authority) {
					uri.authority = this.authority;
					uri.path = this.path;
					uri.query = this.query;
				} else {
					uri.authority = baseURI.authority;
					if (this.path == '') {
						uri.path = baseURI.path;
						uri.query = this.query || baseURI.query;
					} else {
						if (this.path.charAt(0) == '/') {
							uri.path = this.path;
							uri.removeDotSegments();
						} else {
							if (baseURI.authority && baseURI.path == '') {
								uri.path = '/' + this.path;
							} else {
								uri.path = baseURI.path.substring(0, baseURI.path.lastIndexOf('/') + 1) + this.path;
							}
							uri.removeDotSegments();
						}
						uri.query = this.query;
					}
				}
			}
			uri.fragment = this.fragment;
			return uri;
		};

		/**
		 * Remove dot segments from path.
		 * See RFC 3986 section 5.2.4
		 * @private
		 */
		URI.prototype.removeDotSegments = function() {
			var input = this.path.split('/'),
				output = [],
				segment,
				absPath = input[0] == '';
			if (absPath)
				input.shift();
			var sFirst = input[0] == '' ? input.shift() : null;
			while (input.length) {
				segment = input.shift();
				if (segment == '..') {
					output.pop();
				} else if (segment != '.') {
					output.push(segment);
				}
			}
			if (segment == '.' || segment == '..')
				output.push('');
			if (absPath)
				output.unshift('');
			this.path = output.join('/');
		};

		// We don't like this function because it builds up a cache that is never cleared.
	//	/**
	//	 * Resolves a relative URI against an absolute base URI.
	//	 * Convenience method.
	//	 * @param {String} uri the relative URI to resolve
	//	 * @param {String} baseURI the base URI (must be absolute) to resolve against
	//	 */
	//	URI.resolve = function(sURI, sBaseURI) {
	//		var uri = cache[sURI] || (cache[sURI] = new URI(sURI));
	//		var baseURI = cache[sBaseURI] || (cache[sBaseURI] = new URI(sBaseURI));
	//		return uri.resolve(baseURI).toString();
	//	};

	//	var cache = {};

		/**
		 * Serialises the URI to a string.
		 */
		URI.prototype.toString = function() {
			var result = '';
			if (this.scheme)
				result += this.scheme + ':';
			if (this.authority)
				result += '//' + this.authority;
			result += this.path;
			if (this.query)
				result += '?' + this.query;
			if (this.fragment)
				result += '#' + this.fragment;
			return result;
		};

	return URI;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(216).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(86).setImmediate, __webpack_require__(86).clearImmediate))

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _classCallCheck = __webpack_require__(26)['default'];

	var _Object$seal = __webpack_require__(96)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _Platform = __webpack_require__(18);

	var _Reality = __webpack_require__(25);

	var _Reality2 = _interopRequireDefault(_Reality);

	var _RealityView = __webpack_require__(88);

	var _RealityView2 = _interopRequireDefault(_RealityView);

	var _Util = __webpack_require__(22);

	var _Util2 = _interopRequireDefault(_Util);

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _dataSource = __webpack_require__(23);

	var _dataSource2 = _interopRequireDefault(_dataSource);

	__webpack_require__(218);

	var Matrix3 = _cesiumCesiumImports2['default'].Matrix3;
	var Matrix4 = _cesiumCesiumImports2['default'].Matrix4;
	var Transforms = _cesiumCesiumImports2['default'].Transforms;
	var Cartesian3 = _cesiumCesiumImports2['default'].Cartesian3;
	var Quaternion = _cesiumCesiumImports2['default'].Quaternion;
	var JulianDate = _cesiumCesiumImports2['default'].JulianDate;
	var OrientationProperty = _cesiumCesiumImports2['default'].OrientationProperty;
	var ReferenceFrame = _cesiumCesiumImports2['default'].ReferenceFrame;
	var getValueOrUndefined = _cesiumCesiumImports2['default'].Property.getValueOrUndefined;
	var defined = _cesiumCesiumImports2['default'].defined;
	var defaultValue = _cesiumCesiumImports2['default'].defaultValue;

	var scratchMatrix3 = new _cesiumCesiumImports2['default'].Matrix3();
	var scratchMatrix4 = new Matrix4();
	var scratchCartesian3 = new Cartesian3();
	var scratchQuaternion = new Quaternion();
	var scratchOriginCartesian3 = new Cartesian3();

	function framesEqual(frame1, frame2) {
	  return frame1 && frame1.id ? frame1.id === (frame2 && frame2.id) : frame1 === frame2;
	}

	function rootReferenceFrame(frame) {
	  var frames = [];
	  while (defined(frame) && frame !== null) {
	    frames.unshift(frame);
	    frame = frame.position && frame.position.referenceFrame;
	  }
	  return frames[0];
	}

	/**
	 * @class Argon.Context
	 * @description Contexts are 2D regions of 3D graphics registered
	 * against a representation of reality.
	 */

	var Context = (function () {
	  function Context(args) {
	    _classCallCheck(this, Context);

	    this.id = _Util2['default'].cuid();
	    _Util2['default'].mixinInputOutputEventHandlers(this);
	    _Util2['default'].mixinOptionsManager(this);
	    Context.collection[this.id] = this;

	    /**
	     * This context's DOM element
	     * @type Element
	     */
	    this.element = document.createElement('div');
	    this.element.classList.add('argon-context');
	    this.element.style.position = 'absolute';
	    this.element.style.height = '100%';
	    this.element.style.width = '100%';
	    this.element.style.left = 0;
	    this.element.style.top = 0;
	    this.element.style.margin = 0;
	    this.element.style.zIndex = -1;

	    // By default, the containing element is the documentElement
	    var container = document.documentElement;
	    if (args && args.container) container = args.container;
	    container.appendChild(this.element);

	    // the eye (a.k.a. the camera)
	    // The scene is always rendered from this viewpoint.
	    this.eye = new _cesiumCesiumImports2['default'].Entity({
	      name: 'eye',
	      position: new _cesiumCesiumImports2['default'].ConstantPositionProperty(),
	      orientation: new _cesiumCesiumImports2['default'].ConstantProperty()
	    });

	    // an origin centered at the eye, in the North-East-Up
	    // coordinate system
	    this.eyeOrigin = new _cesiumCesiumImports2['default'].Entity({
	      name: 'eyeOrigin',
	      position: new _cesiumCesiumImports2['default'].ConstantPositionProperty(),
	      orientation: new _cesiumCesiumImports2['default'].ConstantProperty()
	    });

	    // an origin near the eye which doesn't change very often,
	    // in the North-East-Up coordinate system
	    this.localOrigin = new _cesiumCesiumImports2['default'].Entity({
	      name: 'origin',
	      position: new _cesiumCesiumImports2['default'].ConstantPositionProperty(),
	      orientation: new _cesiumCesiumImports2['default'].ConstantProperty()
	    });

	    // the localOrigin rotated by 90 around X such that it is
	    // in the East-Up-South coordinate system.
	    // This is useful for converting to the Y-Up convention
	    // in some libraries, such as three.js.
	    this.localOriginEastUpSouth = new _cesiumCesiumImports2['default'].Entity({
	      name: 'originEastUpSouth',
	      position: new _cesiumCesiumImports2['default'].ConstantPositionProperty(_cesiumCesiumImports2['default'].Cartesian3.ZERO, this.localOrigin),
	      orientation: new _cesiumCesiumImports2['default'].ConstantProperty(Quaternion.fromAxisAngle(Cartesian3.UNIT_X, -Math.PI / 2))
	      // XXX: Gheric - I'm a bit confused here... I feel like the sign should be positive due to
	      // right hand rule, but then y appears to be upside-down on desktop..
	    });

	    // The fov, aspectRatio, and projection matrix of the eye
	    this.frustum = new _cesiumCesiumImports2['default'].PerspectiveFrustum();

	    // The realityView is responsible for rendering the requested reality
	    // While running in a multi-channel environment, the realityView is
	    // disabled for each channel's immersiveContext, with the manager instead
	    // supplying it's own realityView which is rendered behind all other
	    // channels (while Argon takes responsibility for updating each
	    // channel's immersiveContext)
	    this.realityView = new _RealityView2['default']();
	    this.element.appendChild(this.realityView.element);
	    this.realityView.on('update', this.update.bind(this));
	    this._currentReality = undefined;

	    // Each channel can provide a set of capabilities and referenceFrames
	    // it requires (the manager will try to provide these, but there
	    // is no gaurantee)
	    this._requiredCapabilities = undefined;
	    this._requiredReferenceFrames = undefined;

	    this.resize();

	    // seal for better debugging
	    if (args && args.seal !== false) {
	      _Object$seal(this);
	      _Object$seal(this.realityView);
	    }

	    this.setRequiredReality(undefined);
	  }

	  /**
	   * Called interally, either in response to this context's realityView
	   * `update` event, or (in the case of the immersiveContext), in response to the
	   * manager's `update` event
	   */

	  Context.prototype.update = function update(frameState) {
	    // frameState is associated with the currently displayed reality,
	    // which is not necessarily this context's required reality.
	    var time = frameState.time;
	    var position = frameState.position.cartesian;
	    var orientation = frameState.orientation.unitQuaternion;

	    // frameState.referenceFrame refers to the root referenceFrame  of the
	    // current reality's eye, which is either going to be the FIXED frame
	    // (usually) or an Entity (which itself would have a null referenceFrame)
	    var frameStateReferenceFrame = frameState.referenceFrame;
	    var frame = this.eye.position.referenceFrame;
	    if (!framesEqual(frame, frameStateReferenceFrame)) {
	      if (frameStateReferenceFrame.id) frame = new _cesiumCesiumImports2['default'].ReferenceEntity(_dataSource2['default'].entities, frameStateReferenceFrame.id);else frame = frameStateReferenceFrame;
	    }

	    this.eye.position.setValue(position, frame);
	    this.eye.orientation.setValue(orientation);
	    this.eyeOrigin.position.setValue(position, frame);
	    this.frustum.fov = frameState.frustum.fov;
	    this.frustum.aspectRatio = frameState.frustum.aspectRatio;
	    this._updateOrigin(time, position, frame);

	    var previousReality = this._currentReality;
	    var currentReality = frameState.reality;
	    if (!previousReality || previousReality.id != currentReality.id) {
	      var realityInstance = _Reality2['default'].getById(currentReality.id);
	      this._currentReality = realityInstance || currentReality;
	      this._emit('realityChange', { reality: this._currentReality, previousReality: previousReality });
	    }

	    // if we receive an update from a reality that is not our required reality,
	    // then we assume there is a global reality view updating this context,
	    // and we disable our local reality view.
	    if (this.realityView.enabled) {
	      var requiredReality = this.getRequiredReality();
	      if (requiredReality && requiredReality.id != currentReality.id) {
	        this.realityView.enabled = false;
	      }
	    }

	    this._emit('update', frameState);
	  };

	  Context.prototype._updateOrigin = function _updateOrigin(time, position, frame) {
	    var originFrame = this.localOrigin.position.referenceFrame;
	    var originPosition = this.localOrigin.position.getValueInReferenceFrame(time, originFrame, scratchOriginCartesian3);
	    if (!originPosition || originFrame !== frame || Cartesian3.magnitudeSquared(Cartesian3.subtract(position, originPosition, scratchOriginCartesian3)) > 25000000) {
	      if (frame === ReferenceFrame.FIXED) {
	        if (Cartesian3.equals(Cartesian3.ZERO, position)) throw new Error('invalid cartographic position');
	        var enuQuaternion = Transforms.headingPitchRollQuaternion(position, 0, 0, 0, undefined, scratchQuaternion);
	        this.localOrigin.position.setValue(position, frame);
	        this.localOrigin.orientation.setValue(enuQuaternion);
	      } else {
	        this.localOrigin.position.setValue(Cartesian3.ZERO, frame);
	        this.localOrigin.orientation.setValue(Quaternion.IDENTITY);
	      }
	      this._emit('originChange');
	    }
	  };

	  /**
	  * Require a specific reality
	  */

	  Context.prototype.setRequiredReality = function setRequiredReality(reality) {
	    var previousRequiredReality = this.realityView.getReality();
	    if (previousRequiredReality === reality) return;
	    this.realityView.setReality(reality);
	    this._emit('requiredReality', { reality: reality, previousRequiredReality: previousRequiredReality });
	  };

	  /**
	  * Get the required reality
	  */

	  Context.prototype.getRequiredReality = function getRequiredReality() {
	    return this.realityView.getReality();
	  };

	  /**
	  * Get the current reality
	  */

	  Context.prototype.getCurrentReality = function getCurrentReality() {
	    return this._currentReality;
	  };

	  /**
	  * Require a set of capabilities
	  */

	  Context.prototype.setRequiredCapabilities = function setRequiredCapabilities(capabilities) {
	    this._requiredCapabilities = capabilities;
	    this._emit('requiredCapabilities', { capabilities: capabilities });
	  };

	  /**
	  * Require a set of reference frames
	  */

	  Context.prototype.setRequiredReferenceFrames = function setRequiredReferenceFrames(referenceFrames) {
	    this._requiredReferenceFrames = referenceFrames;
	    this._emit('requiredReferenceFrames', { referenceFrames: referenceFrames });
	  };

	  /**
	   * Get size
	   */

	  Context.prototype.getSize = function getSize() {
	    return this._size;
	  };

	  /**
	   * Update the context _size
	   */

	  Context.prototype.resize = function resize() {
	    var container = this.element.parentNode;
	    this._size = [container.clientWidth, container.clientHeight];
	    this.realityView.resize(this._size);
	    this._emit('resize', this._size);
	  };

	  /**
	   * Get screen position.
	   * (Does not report the correct position if the element or any ancessors
	   * has a transform applied). Performs DOM access, so should be used
	   * sparingly XXX: Algorithm for getting correct transform is in Ethereal,
	   * but its lengthly, and again, performs a lot of DOM access, so it's not
	   * ideal. Also, its probably unlikely that normal webpages would apply css
	   * transforms to top-level content. Famo.us webpages, on the other hand...
	   * these would allow us to access the true final transform of a surface/view
	   * (without accessing the DOM!)
	   *
	   */

	  Context.prototype.getScreenBounds = function getScreenBounds() {
	    var left = 0;
	    var top = 0;

	    var element = this.element;
	    while (element) {
	      // eek DOM access.... need to use famous!
	      left += element.offsetLeft - element.scrollLeft + element.clientLeft;
	      top += element.offsetTop - element.scrollTop + element.clientTop;
	      element = element.offsetParent;
	    }

	    var width = this._size[0];
	    var height = this._size[1];

	    return { left: left, top: top, width: width, height: height, size: [width, height] };
	  };

	  Context.prototype.destroy = function destroy() {
	    this.realityView.detach();
	    delete Context.collection[this.id];
	    if (this.element.parentNode) this.element.parentNode.removeChild(this.element);
	  };

	  return Context;
	})();

	Context.collection = {};

	Context.className = 'Context';

	Context.componentBindHandlers = [];

	exports['default'] = Context;

	if (_Platform.isChannel) {

	  // Context.defaultBackground = new Argon.Background
	  // Context.defaultBackground.set
	  // Context.defaultBackground.set('fov', 60)

	  var _setupPanAndZoomGestures = function _setupPanAndZoomGestures(context) {
	    var _this = this;

	    var Hammer = __webpack_require__(217);
	    var hammer = new Hammer(this.element);
	    var pinch = hammer.get('pinch');
	    var pan = hammer.get('pan');
	    var doubletap = hammer.get('doubletap');
	    pinch.set({ enable: true, threshold: 0 });
	    pan.set({ enable: true, threshold: 0, pointers: 2 }); // two-finger pan
	    pan.recognizeWith(pinch);
	    pinch.recognizeWith(pan);
	    doubletap.recognizeWith(pinch);
	    doubletap.recognizeWith(pan);
	    doubletap.set({ pointers: 2, posThreshold: 100, threshold: 40, interval: 500, time: 350 });

	    hammer.on('pinchstart', function (event) {
	      _this.backgroundView.trigger('zoomStart');
	    });
	    hammer.on('pinchmove', function (event) {
	      _this.backgroundView.trigger('zoomMove', {
	        scale: event.scale
	      });
	    });
	    hammer.on('pinchend', function (event) {
	      _this.backgroundView.trigger('zoomEnd');
	    });

	    hammer.on('panstart', function (event) {
	      _this.backgroundView.trigger('panStart');
	    });
	    hammer.on('panmove', function (event) {
	      _this.backgroundView.trigger('panMove', {
	        deltaX: event.deltaX,
	        deltaY: event.deltaY
	      });
	    });
	    hammer.on('panend', function (event) {
	      _this.backgroundView.trigger('panEnd', {
	        velocityX: event.velocityX,
	        velocityY: event.velocityY
	      });
	    });

	    hammer.on('doubletap', function (event) {
	      _this.backgroundView.trigger('zoomReset');
	      _this.backgroundView.trigger('panReset');
	    });
	  };
	}
	module.exports = exports['default'];
	// this.element.addEventListener('gesturestart', event => {
	//   currentFOV = this.backgroundView.cameraFrame.currentState.fov
	// }, false)
	//
	// this.element.addEventListener('gesturechange', event => {
	//   this.context.set('zoomFOV',
	//     Math.max(Math.min(currentFOV / event.scale, maxFOV), minFOV)
	//   )
	// }, false)

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _createClass = __webpack_require__(69)['default'];

	var _classCallCheck = __webpack_require__(26)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _Util = __webpack_require__(22);

	var _Util2 = _interopRequireDefault(_Util);

	var _EventPort = __webpack_require__(39);

	var _EventPort2 = _interopRequireDefault(_EventPort);

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _dataSource = __webpack_require__(23);

	var _dataSource2 = _interopRequireDefault(_dataSource);

	var _Vuforia = __webpack_require__(66);

	var _Vuforia2 = _interopRequireDefault(_Vuforia);

	var _Platform = __webpack_require__(18);

	var Quaternion = _cesiumCesiumImports2['default'].Quaternion;
	var ReferenceFrame = _cesiumCesiumImports2['default'].ReferenceFrame;
	var CesiumMath = _cesiumCesiumImports2['default'].Math;
	var JulianDate = _cesiumCesiumImports2['default'].JulianDate;
	var Transforms = _cesiumCesiumImports2['default'].Transforms;
	var CSSClass = 'argon-reality';

	var scratchMatrix4 = new _cesiumCesiumImports2['default'].Matrix4();
	var scratchMatrix3 = new _cesiumCesiumImports2['default'].Matrix3();

	var RealityView = (function () {
	  function RealityView(args) {
	    var _this = this;

	    _classCallCheck(this, RealityView);

	    _Util2['default'].mixinInputOutputEventHandlers(this);

	    // XXX: allow-same-origin creates a security hole here.
	    // need to switch to something like oasis.js for iframe messaging
	    this.element = document.createElement('iframe');
	    this.element.sandbox = 'allow-scripts allow-same-origin';
	    this.element.classList.add(CSSClass);
	    this.element.style.position = 'absolute';
	    this.element.style.height = '100%';
	    this.element.style.width = '100%';
	    this.element.style.left = 0;
	    this.element.style.top = 0;
	    this.element.style.margin = 0;
	    this.element.style.zIndex = -2;
	    this.element.style.border = 0;
	    this.element.style.pointerEvents = 'none';
	    this.element.argonRealityView = this;

	    // workaround for bug with copy/paste menu over an iframe in UIWebView
	    // (I think we can remove the overlayElement when we switch to WKWebView)
	    this.overlayElement = document.createElement('div');
	    this.overlayElement.style.position = 'absolute';
	    this.overlayElement.style.height = '100%';
	    this.overlayElement.style.width = '100%';
	    this.overlayElement.style.left = 0;
	    this.overlayElement.style.top = 0;
	    this.overlayElement.style.zIndex = -1;
	    this.overlayElement.style.pointerEvents = 'none';

	    this.container = args && args.container || document.documentElement;

	    this.resources = null;

	    this.renderPort = new _EventPort2['default']();
	    this.renderPort.input.pipe(function (type, event) {
	      var contentWindow = _this.element.contentWindow;
	      if (contentWindow && _this.renderPort.connected) {
	        var listeners = contentWindow.__listeners[type];
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].call(null, event);
	          }
	        }
	      }
	    });

	    window.addEventListener('message', function (message) {
	      if (message.data._key === _this._key) {
	        var type = message.data.type;
	        var event = message.data.event;
	        if (type === 'connect') {
	          _this.renderPort.connected = true;
	          try {
	            _this.renderPort.input.emit('startRenderScript');
	          } catch (e) {
	            _this._deferredReady.reject(e);
	          }
	        }
	        if (type === 'ready') {
	          _this._deferredReady.resolve();
	        }
	        _this.renderPort.output.emit(type, event);
	      }
	    });

	    this.defaultEyeFrustum = new _cesiumCesiumImports2['default'].PerspectiveFrustum();
	    this.defaultEyeFrustum.fov = Math.PI * 0.4;
	    this.defaultEyeFrustum.near = 0.0001;
	    this.defaultEyeFrustum.far = 100000000;

	    this._frameState = {
	      frameNumber: 0,
	      time: undefined,
	      referenceFrame: undefined,
	      position: {
	        cartesian: {},
	        cartographicDegrees: {}
	      },
	      orientation: {
	        unitQuaternion: {},
	        unitQuaternionRelative: {}
	      },
	      frustum: undefined,
	      reality: undefined
	    };

	    this._enabled = true;
	  }

	  RealityView.prototype.resize = function resize(size) {
	    // if (isManager && Vuforia.reality && Vuforia.reality.frustum) {
	    //   this.defaultEyeFrustum = Vuforia.reality.frustum
	    // } else {
	    this.defaultEyeFrustum.aspectRatio = size[0] / size[1]
	    // }
	    ;
	  };

	  RealityView.prototype.setReality = function setReality(reality) {
	    var _this2 = this;

	    var previousReality = this._reality;
	    if (previousReality) {
	      previousReality.removeListener('message', this._realityMessageListener);
	      previousReality.removeListener('change', this._realityOptionsChangeListener);
	      previousReality.removeListener('tick', this._realityTickListener);
	      previousReality.enabled = false;
	    }

	    if (!reality) {
	      this.resources = null;
	      return this._commit();
	    }

	    reality.enabled = true;
	    this._reality = reality;
	    this._setJSResources(reality.getJSResources());
	    this._setCSSResources(reality.getCSSResources());
	    this._setRenderScript(reality.renderScript);

	    this._realityMessageListener = function (message) {
	      if (!_this2._enabled) return;
	      _this2.renderPort.input.emit('message', message);
	    };

	    this._realityOptionsChangeListener = function () {
	      _this2._sendRealityOptions();
	    };

	    this._realityTickListener = function (event) {
	      if (!_this2._enabled) return;

	      var time = event.time;
	      var eye = reality.eye;

	      var rootFrame = _Util2['default'].rootReferenceFrame(eye);
	      var frustum = reality.frustum || _this2.defaultEyeFrustum;

	      var frameState = _this2._frameState;
	      frameState.frameNumber = CesiumMath.incrementWrap(frameState.frameNumber, 15000000, 1);
	      frameState.time = JulianDate.clone(time, frameState.time);

	      if (rootFrame === ReferenceFrame.FIXED) {
	        frameState.referenceFrame = ReferenceFrame.FIXED;
	      } else if (rootFrame.id) {
	        frameState.referenceFrame = { id: rootFrame.id };
	      } else {
	        throw new Error('Unsupported root reference frame: ' + rootFrame);
	      }

	      // position.cartesian
	      var cartesian = frameState.position.cartesian = _Util2['default'].getEntityPositionInReferenceFrame(eye, time, rootFrame, frameState.position.cartesian);
	      if (!cartesian) return;

	      // orientation.unitQuaternion
	      var unitQuaternion = frameState.orientation.unitQuaternion = _Util2['default'].getEntityOrientationInReferenceFrame(eye, time, rootFrame, frameState.orientation.unitQuaternion);
	      if (!unitQuaternion) return;

	      // position.cartographicDegrees [long, lat, height]
	      if (rootFrame === ReferenceFrame.FIXED) {
	        var cart = _cesiumCesiumImports2['default'].Ellipsoid.WGS84.cartesianToCartographic(cartesian, frameState.position.cartographicDegrees);
	        frameState.position.cartographicDegrees = [CesiumMath.toDegrees(cart.longitude), CesiumMath.toDegrees(cart.latitude), cart.height];
	      } else {
	        frameState.position.cartographicDegrees = undefined;
	      }

	      // orientation.unitQuaternionRelative (orientation relative to the local ENU frame)
	      if (rootFrame === ReferenceFrame.FIXED) {
	        var enuQuaternion = Transforms.headingPitchRollQuaternion(cartesian, 0, 0, 0, undefined, frameState.orientation.unitQuaternionRelative);
	        var invEnuQuaternion = Quaternion.conjugate(enuQuaternion, enuQuaternion);
	        frameState.orientation.unitQuaternionRealtive = Quaternion.multiply(invEnuQuaternion, unitQuaternion, invEnuQuaternion);
	      } else {
	        frameState.orientation.unitQuaternionRelative = Quaternion.clone(unitQuaternion, frameState.orientation.unitQuaternionRelative);
	      }

	      frameState.frustum = { fov: frustum.fov, fovy: frustum.fovy, aspectRatio: frustum.aspectRatio };
	      frameState.reality = { id: reality.id };

	      _this2.renderPort.input.emit('update', frameState);
	      _this2._emit('update', frameState);
	    };

	    reality.on('message', this._realityMessageListener);
	    reality.on('options', this._realityOptionsChangeListener);
	    reality.on('tick', this._realityTickListener);

	    return this._commit();
	  };

	  RealityView.prototype.getReality = function getReality() {
	    return this._reality;
	  };

	  RealityView.prototype._sendRealityOptions = function _sendRealityOptions() {
	    if (!this._enabled || !this._reality) return;
	    this.renderPort.input.emit('options', this._reality.options);
	  };

	  RealityView.prototype._setCSSResources = function _setCSSResources(cssResources) {
	    this.resources = this.resources || {};
	    this.resources.css = cssResources;
	  };

	  RealityView.prototype._setJSResources = function _setJSResources(jsResources) {
	    this.resources = this.resources || {};
	    this.resources.js = jsResources;
	  };

	  RealityView.prototype._setRenderScript = function _setRenderScript(script) {
	    this.resources = this.resources || {};
	    this.resources.renderScript = script || function () {};
	  };

	  RealityView.prototype._commit = function _commit() {
	    var _this3 = this;

	    if (this._commitPromise && this._commitPromise.isPending()) this._commitPromise.cancel();

	    if (!this.resources || !this._enabled) {
	      this.detach();
	      return _bluebird2['default'].resolve();
	    }

	    var resources = [this.resources.css, this.resources.js, this.resources.renderScript];

	    this._commitPromise = _bluebird2['default'].all(resources).then(function (resources) {
	      _commitContent.call(_this3, resources[0], resources[1], resources[2]);
	      _this3._deferredReady = _bluebird2['default'].defer();
	      return _this3._deferredReady.promise;
	    }).then(function () {
	      _this3._sendRealityOptions();
	    }).cancellable()['catch'](_bluebird2['default'].CancellationError, function () {});

	    return this._commitPromise;
	  };

	  RealityView.prototype.detach = function detach() {
	    if (this.element.parentNode) this.element.parentNode.removeChild(this.element);
	  };

	  _createClass(RealityView, [{
	    key: 'enabled',

	    /**
	     * When the reality view is enabled, it becomes responsible
	     * for calculating the frameState and rendering it's background,
	     * Otherwise, the reality view is effectively does nothing,
	     * which means any context that was listening to this reality view
	     * should be updated externally. The immersiveContext has a disabled
	     * reality view when running in a multi-channel environment, and is updated
	     * by the manager.
	     * @type {Boolean}
	     */
	    set: function (flag) {
	      if (this._enabled !== flag) {
	        this._enabled = flag;
	        this._commit();
	      }
	    },
	    get: function () {
	      return this._enabled;
	    }
	  }]);

	  return RealityView;
	})();

	exports['default'] = RealityView;

	var beginScript = '<scr' + 'ipt>';
	var endScript = '</scr' + 'ipt>';

	var _commitContent = function _commitContent(cssResources, jsResources, renderScript) {

	  this._key = _Util2['default'].cuid();

	  var content = [];

	  content.push('<!DOCTYPE html>');

	  if (cssResources) cssResources.forEach(function (css) {
	    content.push('<st' + 'yle>' + css + '</sty' + 'le>');
	  });

	  content.push(beginScript);
	  content.push('window.__key = "' + this._key + '"');
	  content.push('document.documentElement.style.position = "fixed"');
	  content.push('document.documentElement.style.width = "100%"');
	  content.push('document.documentElement.style.height = "100%"');
	  content.push(endScript);

	  content.push('<body></body>');

	  if (jsResources) jsResources.forEach(function (js) {
	    content.push(beginScript + js + endScript);
	  });

	  content.push(beginScript);
	  content.push('window.__listeners = {}');
	  content.push('var port = {}');
	  content.push('port.on = function(type, listener) { __listeners[type] = __listeners[type] || []; __listeners[type].push(listener) }');
	  content.push('port.emit = function(type, listener) { window.parent.postMessage({_key:__key, type:type, event:event}, "*") }');
	  content.push('port.on("startRenderScript", function() { (' + renderScript + ')(port); port.emit("ready") })');
	  content.push('port.emit("connect")');
	  content.push(endScript);

	  this.renderPort.connected = false;
	  var b = new Blob([content.join('\n')], { type: 'text/html' });
	  this.element.src = URL.createObjectURL(b);
	  // this.element.srcdoc = content.join('\n')

	  if (!this.element.parentNode) {
	    this.container.appendChild(this.element);
	    this.container.appendChild(this.overlayElement);
	  }

	  basket.clear(true);
	};
	module.exports = exports['default'];
	// transpiler parsers were confused
	// clear expired files

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;
	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	var alert = function alert(content) {
	  return setTimeout(function () {
	    return window.alert(content);
	  }, 0);
	};

	exports["default"] = alert;
	module.exports = exports["default"];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _Platform = __webpack_require__(18);

	var _Channel = __webpack_require__(38);

	var _Channel2 = _interopRequireDefault(_Channel);

	var _managerPort = __webpack_require__(40);

	var _managerPort2 = _interopRequireDefault(_managerPort);

	var _dataSource = __webpack_require__(23);

	var _dataSource2 = _interopRequireDefault(_dataSource);

	var deviceEntity = _dataSource2['default'].entities.add({
	  id: 'DEVICE',
	  name: 'DEVICE'
	});

	deviceEntity.position = new _cesiumCesiumImports2['default'].ConstantPositionProperty(_cesiumCesiumImports2['default'].Cartesian3.ZERO, null);
	deviceEntity.orientation = new _cesiumCesiumImports2['default'].ConstantProperty(_cesiumCesiumImports2['default'].Quaternion.IDENTITY);

	exports['default'] = deviceEntity;

	function updateDisplay() {
	  var o = window.orientation || 0;
	  var verticalDirection = o === 90 || o === -90 ? 0 : 1;
	  deviceEntity.display = {
	    size: [window.screen.width, window.screen.height],
	    orientation: o,
	    verticalDirection: verticalDirection,
	    horizontalDirection: +!verticalDirection };
	  if (_Platform.isManager) _Channel2['default'].port.trigger('deviceEntity.display', deviceEntity.display);
	}
	updateDisplay();

	window.addEventListener('orientationchange', updateDisplay);

	if (_Platform.isChannel) {
	  _dataSource2['default'].subscribeToEntityById('DEVICE');

	  _managerPort2['default'].whenConnected.then(function () {
	    window.removeEventListener('orientationchange', updateDisplay);
	  });
	  _managerPort2['default'].on('deviceEntity.display', function (display) {
	    deviceEntity.display = display;
	  });
	}
	module.exports = exports['default'];

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _Object$seal = __webpack_require__(96)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _Platform = __webpack_require__(18);

	var _managerPort = __webpack_require__(40);

	var _managerPort2 = _interopRequireDefault(_managerPort);

	var _Channel = __webpack_require__(38);

	var _Channel2 = _interopRequireDefault(_Channel);

	var _Context = __webpack_require__(87);

	var _Context2 = _interopRequireDefault(_Context);

	var _Reality = __webpack_require__(25);

	var _Reality2 = _interopRequireDefault(_Reality);

	var _policy = __webpack_require__(93);

	var _policy2 = _interopRequireDefault(_policy);

	var _Platform2 = _interopRequireDefault(_Platform);

	var iC = new _Context2['default']({ seal: false });
	iC.element.style.position = 'fixed';
	iC.element.style.width = '100vw';
	iC.element.style.height = '100vh';

	window.addEventListener('resize', function () {
	  iC.resize([window.screen.width, window.screen.height]);
	});

	if (_Platform.isManager) {

	  iC.setRequiredReality(_policy2['default'].defaultImmersiveReality());

	  iC.requiredRealityMap = {};
	  iC.requiredCapabilitiesMap = {};
	  iC.requiredReferenceFramesMap = {};
	  iC.optionsMap = {};
	  _Object$seal(iC);

	  iC.set('presentationMode', 'immersive');
	  iC.set('pageModeAvailable', false);
	  iC.on('change:presentationMode', function (e) {
	    _Channel2['default'].focussedChannel.port.trigger('immersiveContext.presentationMode', { mode: e.value });
	  });

	  iC.on('update', function (frameState) {
	    _Channel2['default'].port.trigger('immersiveContext.update', frameState);
	  });

	  _Channel2['default'].events.on('focus', function (channel) {
	    iC.set('pageModeAvailable', false);
	    // TODO: need better options handling (the previous line shouldn't be required)
	    iC.setOptions(iC.optionsMap[channel.id]);
	    iC.setRequiredReality(_policy2['default'].chooseImmersiveReality(iC, channel));
	  });

	  _Channel2['default'].events.on('unload', function (channel) {
	    delete iC.requiredRealityMap[channel.id];
	    delete iC.requiredCapabilitiesMap[channel.id];
	    delete iC.requiredReferenceFramesMap[channel.id];
	    delete iC.optionsMap[channel.id]
	    // iC.setRequiredReality(policy.chooseImmersiveReality(iC, channel))
	    ;
	  });

	  _Channel2['default'].port.on('immersiveContext.requiredReality', function (event) {
	    var channel = _Channel2['default'].eventMap.get(event);
	    var configuration = event.configuration;
	    if (iC.requiredRealityMap[channel.id]) {
	      iC.requiredRealityMap[channel.id].destroy();
	    }
	    if (configuration) {
	      (function () {
	        var reality = _Reality2['default'].fromConfiguration(configuration);
	        iC.requiredRealityMap[channel.id] = reality;
	        if (channel.hasFocus) {
	          iC.setRequiredReality(_policy2['default'].chooseImmersiveReality(iC, channel));
	        }
	        channel.on('unload', function () {
	          return reality.destroy();
	        });
	      })();
	    } else {
	      iC.requiredRealityMap[channel.id] = null;
	      if (channel.hasFocus) {
	        iC.reality = _policy2['default'].chooseImmersiveReality(iC.requiredRealityMap);
	      }
	    }
	  });

	  _Channel2['default'].port.on('immersiveContext.requiredRealityOptionsChange', function (e) {
	    var channel = _Channel2['default'].eventMap.get(e);
	    var reality = iC.requiredRealityMap[channel.id];

	    if (reality) reality.set(e.id, e.value);
	  });

	  _Channel2['default'].port.on('immersiveContext.options', function (options) {
	    var channel = _Channel2['default'].eventMap.get(options);
	    iC.optionsMap[channel.id] = options;
	    if (channel.hasFocus) {
	      iC.setOptions(options);
	    }
	  });
	}

	if (_Platform.isChannel) {
	  (function () {
	    var _nodeIsContent = function (node) {
	      switch (node.nodeName) {
	        case '#text':
	          return node.nodeValue.trim().length > 0;
	        case '#comment':
	          return false;
	        case 'SCRIPT':
	          return false;
	        default:
	          return true;
	      }
	    };

	    var _documentHasContent = function () {
	      if (!document.body.hasChildNodes()) return false;
	      var childNodes = [].slice.call(document.body.childNodes);
	      return childNodes.some(_nodeIsContent);
	    };

	    var _checkBodyContent = function () {
	      if (document.body) {
	        var userProvidedImmersiveContextDiv = document.querySelector('#argon-immersive-context');
	        if (userProvidedImmersiveContextDiv) {
	          iC.element.appendChild(userProvidedImmersiveContextDiv);
	        }
	        if (!_documentHasContent()) {
	          iC.set('pageModeAvailable', false);
	          var observer = new MutationObserver(function (mutations) {
	            if (_documentHasContent()) {
	              iC.set('pageModeAvailable', true);
	              observer.disconnect();
	            }
	          });
	          observer.observe(document.body, { childList: true });
	        } else {
	          iC.set('pageModeAvailable', true);
	        }
	      } else {
	        iC.set('pageModeAvailable', false);
	        document.addEventListener('DOMContentLoaded', _checkBodyContent);
	      }
	    };

	    var _setChannelDefaultReality = function () {
	      if (!iC.getRequiredReality()) {
	        // set the default transparent reality if the user hasn't set one
	        iC.realityView.setReality(transparentReality);
	        iC.realityView.enabled = true;
	        _managerPort2['default'].whenConnected.then(function () {
	          // If we eventually connect, disable the realityView
	          iC.realityView.enabled = false;
	        });
	      }
	    };

	    var _realityOptionsChangeListener = function (e) {
	      _managerPort2['default'].trigger('immersiveContext.requiredRealityOptionsChange', e);
	    };

	    document.documentElement.style.position = 'fixed';
	    document.documentElement.style.width = '100vw';
	    document.documentElement.style.height = '100vh';
	    document.documentElement.style.paddingTop = '44px'; // TODO: make this dynamic
	    document.documentElement.style.boxSizing = 'border-box';

	    var sheet = (function () {
	      var style = document.createElement('style');
	      style.appendChild(document.createTextNode('')); // WebKit hack :(
	      document.head.appendChild(style);
	      return style.sheet;
	    })();
	    sheet.insertRule('body { display: none; }');

	    _Object$seal(iC);

	    _checkBodyContent();

	    var transparentReality = new _Reality2['default']({ autoTick: true });

	    if (_Platform.isRunningInIFrame) {
	      // Disable the realityView incase we are in a multi-channel environment
	      iC.realityView.enabled = false;
	      // If we haven't heard from the manager in half a second, we
	      // assume we aren't running in the manager.
	      document.addEventListener('DOMContentLoaded', function (event) {
	        _managerPort2['default'].whenConnected.timeout(500)['catch'](function (e) {
	          _setChannelDefaultReality();
	        });
	      });
	    } else {
	      if (document.body) _setChannelDefaultReality();else document.addEventListener('DOMContentLoaded', _setChannelDefaultReality);
	    }

	    _managerPort2['default'].on('immersiveContext.presentationMode', function (e) {
	      if (e.mode === 'page') {
	        iC.element.style.display = 'none';
	        document.body.style.display = 'block';
	        document.documentElement.style.position = '';
	      } else if (e.mode === 'immersive') {
	        iC.element.style.display = 'block';
	        document.body.style.display = 'none';
	        document.documentElement.style.position = 'fixed';
	      }
	    });

	    _managerPort2['default'].on('immersiveContext.update', function (frameState) {
	      iC.update(frameState);
	    });

	    iC.on('requiredReality', function (_ref) {
	      var reality = _ref.reality;
	      var previousReality = _ref.previousReality;

	      _managerPort2['default'].trigger('immersiveContext.requiredReality', {
	        configuration: reality && reality.configuration || null
	      });

	      if (previousReality) {
	        previousReality.removeListener('change', _realityOptionsChangeListener);
	      }
	      if (reality) {
	        reality.on('change', _realityOptionsChangeListener);
	      }
	    });

	    // function _realityTickListener(e) {
	    //   if (iC.currentReality === iC.requiredReality)
	    //     managerPort.trigger('immersiveContext.requiredRealityTick', e)
	    // }

	    iC.on('requiredCapabilities', function (e) {
	      _managerPort2['default'].trigger('immersiveContext.requiredCapabilities', e);
	    });

	    iC.on('requiredReferenceFrames', function (e) {
	      _managerPort2['default'].trigger('immersiveContext.requiredReferenceFrames', e);
	    });

	    iC.on('change', function (e) {
	      _managerPort2['default'].trigger('immersiveContext.options', iC.options);
	    });
	  })();
	}

	exports['default'] = iC;
	module.exports = exports['default'];
	// alert('focus')
	// previousReality.removeListener('tick', _realityTickListener)
	// reality.on('tick', _realityTickListener)

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _EventPort = __webpack_require__(39);

	var _EventPort2 = _interopRequireDefault(_EventPort);

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	// native <-> channel manager communication

	var nativePort = new _EventPort2['default']();
	var requests = {};

	nativePort.afterResponse = function (requestId) {
	  var deferred = _bluebird2['default'].defer();
	  requests[requestId] = deferred;
	  return deferred.promise;
	};

	nativePort.on('RESPONSE', function responseHandler(e) {
	  var requestId = e.userData;
	  var request = requests[requestId];
	  if (request) {
	    delete requests[requestId];
	    if (e.eventInfo && e.eventInfo.error) {
	      console.log('native error: ' + JSON.stringify(e.eventInfo.error));
	      var err = new Error(JSON.stringify(e.eventInfo.error));
	      return request.reject(err);
	    }
	    return request.resolve(e.eventInfo);
	  }
	});

	var readyDeferred = _bluebird2['default'].defer();
	nativePort.whenReady = readyDeferred.promise;

	nativePort.on('pluginsReady', function () {
	  readyDeferred.resolve();
	});

	exports['default'] = nativePort;
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _Platform = __webpack_require__(18);

	var _Platform2 = _interopRequireDefault(_Platform);

	var _Reality = __webpack_require__(25);

	var _Reality2 = _interopRequireDefault(_Reality);

	var _immersiveContext = __webpack_require__(91);

	var _immersiveContext2 = _interopRequireDefault(_immersiveContext);

	var _Vuforia = __webpack_require__(66);

	var _Vuforia2 = _interopRequireDefault(_Vuforia);

	var _realitiesColor = __webpack_require__(94);

	var _realitiesColor2 = _interopRequireDefault(_realitiesColor);

	var policy = {};

	if (_Platform2['default'].isManager) {
	  (function () {

	    var colorReality = new _realitiesColor2['default']();

	    policy.defaultImmersiveReality = function () {
	      if (_Platform2['default'].isRunningInArgonApp) return _Vuforia2['default'].reality;
	      return colorReality;
	    };

	    policy.chooseImmersiveReality = function (immersiveContext, focussedChannel) {
	      var reality = immersiveContext.requiredRealityMap[focussedChannel.id];
	      if (!reality) {
	        var requiredCapabilities = immersiveContext.requiredCapabilitiesMap[focussedChannel.id];
	        var requiredReferenceFrames = immersiveContext.requiredReferenceFramesMap[focussedChannel.id];
	        // check current reality and see if it meets our requirements
	        // otherwise, find a reality that meets the most of our requirments
	        reality = _Reality2['default'].query({
	          capabilities: requiredCapabilities,
	          referenceFrames: requiredReferenceFrames
	        })[0];
	      }

	      return reality;
	    };
	  })();
	}

	exports['default'] = policy;
	module.exports = exports['default'];

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _inherits = __webpack_require__(70)['default'];

	var _classCallCheck = __webpack_require__(26)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _Reality2 = __webpack_require__(25);

	var _Reality3 = _interopRequireDefault(_Reality2);

	_Reality3['default'].Color = (function (_Reality) {
	  function Color() {
	    var _ref = arguments[0] === undefined ? {} : arguments[0];

	    var id = _ref.id;
	    var referenceFrame = _ref.referenceFrame;
	    var _ref$options = _ref.options;
	    var options = _ref$options === undefined ? { color: 'white' } : _ref$options;

	    _classCallCheck(this, Color);

	    _Reality.call(this, {
	      type: 'Color',
	      autoTick: true,
	      id: id,
	      referenceFrame: referenceFrame,
	      options: options,
	      renderScript: function renderScript(port) {
	        port.on('options', function (options) {
	          document.documentElement.style.backgroundColor = options.color;
	        });
	      }
	    });
	  }

	  _inherits(Color, _Reality);

	  return Color;
	})(_Reality3['default']);

	exports['default'] = _Reality3['default'].Color;
	module.exports = exports['default'];

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(157), __esModule: true };

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(158), __esModule: true };

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(99), __esModule: true };

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(64);
	__webpack_require__(63);
	__webpack_require__(110);
	module.exports = __webpack_require__(5).core.getIterator;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(111);
	__webpack_require__(113);
	module.exports = __webpack_require__(5).core.Set;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(61);
	__webpack_require__(112);
	module.exports = __webpack_require__(5).core.WeakMap;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var $   = __webpack_require__(5)
	  , ctx = __webpack_require__(41);
	module.exports = function(TYPE){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
	  return function($this, callbackfn, that){
	    var O      = Object($.assertDefined($this))
	      , self   = $.ES5Object(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = $.toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? Array(length) : IS_FILTER ? [] : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $        = __webpack_require__(5)
	  , ctx      = __webpack_require__(41)
	  , safe     = __webpack_require__(24).safe
	  , assert   = __webpack_require__(20)
	  , forOf    = __webpack_require__(31)
	  , step     = __webpack_require__(13).step
	  , has      = $.has
	  , set      = $.set
	  , isObject = $.isObject
	  , hide     = $.hide
	  , isFrozen = Object.isFrozen || $.core.Object.isFrozen
	  , ID       = safe('id')
	  , O1       = safe('O1')
	  , LAST     = safe('last')
	  , FIRST    = safe('first')
	  , ITER     = safe('iter')
	  , SIZE     = $.DESC ? safe('size') : 'size'
	  , id       = 0;

	function fastKey(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
	  // can't set id to frozen object
	  if(isFrozen(it))return 'F';
	  if(!has(it, ID)){
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	}

	function getEntry(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index != 'F')return that[O1][index];
	  // frozen object case
	  for(entry = that[FIRST]; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	}

	module.exports = {
	  getConstructor: function(NAME, IS_MAP, ADDER){
	    function C(){
	      var that     = assert.inst(this, C, NAME)
	        , iterable = arguments[0];
	      set(that, O1, $.create(null));
	      set(that, SIZE, 0);
	      set(that, LAST, undefined);
	      set(that, FIRST, undefined);
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    }
	    $.mix(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that[FIRST] = that[LAST] = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that[O1][entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that[FIRST] == entry)that[FIRST] = next;
	          if(that[LAST] == entry)that[LAST] = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments[1], 3)
	          , entry;
	        while(entry = entry ? entry.n : this[FIRST]){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if($.DESC)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return assert.def(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that[LAST] = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that[LAST],          // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that[FIRST])that[FIRST] = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index != 'F')that[O1][index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  // add .keys, .values, .entries, [@@iterator]
	  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	  setIter: function(C, NAME, IS_MAP){
	    __webpack_require__(42)(C, NAME, function(iterated, kind){
	      set(this, ITER, {o: iterated, k: kind});
	    }, function(){
	      var iter  = this[ITER]
	        , kind  = iter.k
	        , entry = iter.l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
	        // or finish the iteration
	        iter.o = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	  }
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $def  = __webpack_require__(27)
	  , forOf = __webpack_require__(31);
	module.exports = function(NAME){
	  $def($def.P, NAME, {
	    toJSON: function toJSON(){
	      var arr = [];
	      forOf(this, false, arr.push, arr);
	      return arr;
	    }
	  });
	};

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $         = __webpack_require__(5)
	  , safe      = __webpack_require__(24).safe
	  , assert    = __webpack_require__(20)
	  , forOf     = __webpack_require__(31)
	  , _has      = $.has
	  , isObject  = $.isObject
	  , hide      = $.hide
	  , isFrozen  = Object.isFrozen || $.core.Object.isFrozen
	  , id        = 0
	  , ID        = safe('id')
	  , WEAK      = safe('weak')
	  , LEAK      = safe('leak')
	  , method    = __webpack_require__(101)
	  , find      = method(5)
	  , findIndex = method(6);
	function findFrozen(store, key){
	  return find(store.array, function(it){
	    return it[0] === key;
	  });
	}
	// fallback for frozen keys
	function leakStore(that){
	  return that[LEAK] || hide(that, LEAK, {
	    array: [],
	    get: function(key){
	      var entry = findFrozen(this, key);
	      if(entry)return entry[1];
	    },
	    has: function(key){
	      return !!findFrozen(this, key);
	    },
	    set: function(key, value){
	      var entry = findFrozen(this, key);
	      if(entry)entry[1] = value;
	      else this.array.push([key, value]);
	    },
	    'delete': function(key){
	      var index = findIndex(this.array, function(it){
	        return it[0] === key;
	      });
	      if(~index)this.array.splice(index, 1);
	      return !!~index;
	    }
	  })[LEAK];
	}

	module.exports = {
	  getConstructor: function(NAME, IS_MAP, ADDER){
	    function C(){
	      $.set(assert.inst(this, C, NAME), ID, id++);
	      var iterable = arguments[0];
	      if(iterable != undefined)forOf(iterable, IS_MAP, this[ADDER], this);
	    }
	    $.mix(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        if(isFrozen(key))return leakStore(this)['delete'](key);
	        return _has(key, WEAK) && _has(key[WEAK], this[ID]) && delete key[WEAK][this[ID]];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        if(isFrozen(key))return leakStore(this).has(key);
	        return _has(key, WEAK) && _has(key[WEAK], this[ID]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    if(isFrozen(assert.obj(key))){
	      leakStore(that).set(key, value);
	    } else {
	      _has(key, WEAK) || hide(key, WEAK, {});
	      key[WEAK][that[ID]] = value;
	    } return that;
	  },
	  leakStore: leakStore,
	  WEAK: WEAK,
	  ID: ID
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var assertObject = __webpack_require__(20).obj;
	function close(iterator){
	  var ret = iterator['return'];
	  if(ret !== undefined)assertObject(ret.call(iterator));
	}
	function call(iterator, fn, value, entries){
	  try {
	    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
	  } catch(e){
	    close(iterator);
	    throw e;
	  }
	}
	call.close = close;
	module.exports = call;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var SYMBOL_ITERATOR = __webpack_require__(14)('iterator')
	  , SAFE_CLOSING    = false;
	try {
	  var riter = [7][SYMBOL_ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	module.exports = function(exec){
	  if(!SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[SYMBOL_ITERATOR]();
	    iter.next = function(){ safe = true; };
	    arr[SYMBOL_ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var $       = __webpack_require__(5)
	  , SPECIES = __webpack_require__(14)('species');
	module.exports = function(C){
	  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: $.that
	  });
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// true  -> String#at
	// false -> String#codePointAt
	var $ = __webpack_require__(5);
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String($.assertDefined(that))
	      , i = $.toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l
	      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	        ? TO_STRING ? s.charAt(i) : a
	        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var $           = __webpack_require__(5)
	  , UNSCOPABLES = __webpack_require__(14)('unscopables');
	if($.FW && !(UNSCOPABLES in []))$.hide(Array.prototype, UNSCOPABLES, {});
	module.exports = function(key){
	  if($.FW)[][UNSCOPABLES][key] = true;
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(5).core
	  , $iter = __webpack_require__(13);
	core.isIterable  = $iter.is;
	core.getIterator = $iter.get;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(102);

	// 23.2 Set Objects
	__webpack_require__(60)('Set', {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $         = __webpack_require__(5)
	  , weak      = __webpack_require__(104)
	  , leakStore = weak.leakStore
	  , ID        = weak.ID
	  , WEAK      = weak.WEAK
	  , has       = $.has
	  , isObject  = $.isObject
	  , isFrozen  = Object.isFrozen || $.core.Object.isFrozen
	  , tmp       = {};

	// 23.3 WeakMap Objects
	var WeakMap = __webpack_require__(60)('WeakMap', {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      if(isFrozen(key))return leakStore(this).get(key);
	      if(has(key, WEAK))return key[WEAK][this[ID]];
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	}, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if($.FW && new WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  $.each.call(['delete', 'has', 'get', 'set'], function(key){
	    var method = WeakMap.prototype[key];
	    WeakMap.prototype[key] = function(a, b){
	      // store frozen objects on leaky map
	      if(isObject(a) && isFrozen(a)){
	        var result = leakStore(this)[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    };
	  });
	}

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	__webpack_require__(103)('Set');

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 114;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(116),
	        __webpack_require__(74),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(175),
	        __webpack_require__(16)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        ClockRange,
	        ClockStep,
	        defaultValue,
	        defined,
	        DeveloperError,
	        Event,
	        getTimestamp,
	        JulianDate) {
	    "use strict";

	    /**
	     * A simple clock for keeping track of simulated time.
	     *
	     * @alias Clock
	     * @constructor
	     *
	     * @param {Object} options Object with the following properties:
	     * @param {JulianDate} [options.startTime] The start time of the clock.
	     * @param {JulianDate} [options.stopTime] The stop time of the clock.
	     * @param {JulianDate} [options.currentTime] The current time.
	     * @param {Number} [options.multiplier=1.0] Determines how much time advances when tick is called, negative values allow for advancing backwards.
	     * @param {ClockStep} [options.clockStep=ClockStep.SYSTEM_CLOCK_MULTIPLIER] Determines if calls to <code>tick</code> are frame dependent or system clock dependent.
	     * @param {ClockRange} [options.clockRange=ClockRange.UNBOUNDED] Determines how the clock should behave when <code>startTime</code> or <code>stopTime</code> is reached.
	     * @param {Boolean} [options.canAnimate=true] Indicates whether tick can advance time.  This could be false if data is being buffered, for example.  The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
	     * @param {Boolean} [options.shouldAnimate=true] Indicates whether tick should attempt to advance time.  The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
	     *
	     * @exception {DeveloperError} startTime must come before stopTime.
	     *
	     * @see ClockStep
	     * @see ClockRange
	     * @see JulianDate
	     *
	     * @example
	     * // Create a clock that loops on Christmas day 2013 and runs in real-time.
	     * var clock = new Cesium.Clock({
	     *    startTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
	     *    currentTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
	     *    stopTime : Cesium.JulianDate.fromIso8601("2013-12-26"),
	     *    clockRange : Cesium.ClockRange.LOOP_STOP,
	     *    clockStep : Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER
	     * });
	     */
	    var Clock = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        var startTime = options.startTime;
	        var startTimeUndefined = !defined(startTime);

	        var stopTime = options.stopTime;
	        var stopTimeUndefined = !defined(stopTime);

	        var currentTime = options.currentTime;
	        var currentTimeUndefined = !defined(currentTime);

	        if (startTimeUndefined && stopTimeUndefined && currentTimeUndefined) {
	            currentTime = JulianDate.now();
	            startTime = JulianDate.clone(currentTime);
	            stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
	        } else if (startTimeUndefined && stopTimeUndefined) {
	            startTime = JulianDate.clone(currentTime);
	            stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
	        } else if (startTimeUndefined && currentTimeUndefined) {
	            startTime = JulianDate.addDays(stopTime, -1.0, new JulianDate());
	            currentTime = JulianDate.clone(startTime);
	        } else if (currentTimeUndefined && stopTimeUndefined) {
	            currentTime = JulianDate.clone(startTime);
	            stopTime = JulianDate.addDays(startTime, 1.0, new JulianDate());
	        } else if (currentTimeUndefined) {
	            currentTime = JulianDate.clone(startTime);
	        } else if (stopTimeUndefined) {
	            stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
	        } else if (startTimeUndefined) {
	            startTime = JulianDate.clone(currentTime);
	        }

	        //>>includeStart('debug', pragmas.debug);
	        if (JulianDate.greaterThan(startTime, stopTime)) {
	            throw new DeveloperError('startTime must come before stopTime.');
	        }
	        //>>includeEnd('debug');

	        /**
	         * The start time of the clock.
	         * @type {JulianDate}
	         */
	        this.startTime = startTime;

	        /**
	         * The stop time of the clock.
	         * @type {JulianDate}
	         */
	        this.stopTime = stopTime;

	        /**
	         * The current time.
	         * @type {JulianDate}
	         */
	        this.currentTime = currentTime;

	        /**
	         * Determines how much time advances when tick is called, negative values allow for advancing backwards.
	         * If <code>clockStep</code> is set to ClockStep.TICK_DEPENDENT this is the number of seconds to advance.
	         * If <code>clockStep</code> is set to ClockStep.SYSTEM_CLOCK_MULTIPLIER this value is multiplied by the
	         * elapsed system time since the last call to tick.
	         * @type {Number}
	         * @default 1.0
	         */
	        this.multiplier = defaultValue(options.multiplier, 1.0);

	        /**
	         * Determines if calls to <code>tick</code> are frame dependent or system clock dependent.
	         * @type ClockStep
	         * @default {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}
	         */
	        this.clockStep = defaultValue(options.clockStep, ClockStep.SYSTEM_CLOCK_MULTIPLIER);

	        /**
	         * Determines how the clock should behave when <code>startTime</code> or <code>stopTime</code> is reached.
	         * @type {ClockRange}
	         * @default {@link ClockRange.UNBOUNDED}
	         */
	        this.clockRange = defaultValue(options.clockRange, ClockRange.UNBOUNDED);

	        /**
	         * Indicates whether tick can advance time.  This could be false if data is being buffered,
	         * for example.  The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
	         * @type {Boolean}
	         * @default true
	         */
	        this.canAnimate = defaultValue(options.canAnimate, true);

	        /**
	         * Indicates whether tick should attempt to advance time.
	         * The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
	         * @type {Boolean}
	         * @default true
	         */
	        this.shouldAnimate = defaultValue(options.shouldAnimate, true);

	        /**
	         * An {@link Event} that is fired whenever <code>tick</code>.
	         */
	        this.onTick = new Event();

	        this._lastSystemTime = getTimestamp();
	    };

	    /**
	     * Advances the clock from the currentTime based on the current configuration options.
	     * tick should be called every frame, regardless of whether animation is taking place
	     * or not.  To control animation, use the <code>shouldAnimate</code> property.
	     *
	     * @returns {JulianDate} The new value of the <code>currentTime</code> property.
	     */
	    Clock.prototype.tick = function() {
	        var currentSystemTime = getTimestamp();
	        var currentTime = JulianDate.clone(this.currentTime);
	        var startTime = this.startTime;
	        var stopTime = this.stopTime;
	        var multiplier = this.multiplier;

	        if (this.canAnimate && this.shouldAnimate) {
	            if (this.clockStep === ClockStep.SYSTEM_CLOCK) {
	                currentTime = JulianDate.now(currentTime);
	            } else {
	                if (this.clockStep === ClockStep.TICK_DEPENDENT) {
	                    currentTime = JulianDate.addSeconds(currentTime, multiplier, currentTime);
	                } else {
	                    var milliseconds = currentSystemTime - this._lastSystemTime;
	                    currentTime = JulianDate.addSeconds(currentTime, multiplier * (milliseconds / 1000.0), currentTime);
	                }

	                if (this.clockRange === ClockRange.CLAMPED) {
	                    if (JulianDate.lessThan(currentTime, startTime)) {
	                        currentTime = JulianDate.clone(startTime, currentTime);
	                    } else if (JulianDate.greaterThan(currentTime, stopTime)) {
	                        currentTime = JulianDate.clone(stopTime, currentTime);
	                    }
	                } else if (this.clockRange === ClockRange.LOOP_STOP) {
	                    if (JulianDate.lessThan(currentTime, startTime)) {
	                        currentTime = JulianDate.clone(startTime, currentTime);
	                    }
	                    while (JulianDate.greaterThan(currentTime, stopTime)) {
	                        currentTime = JulianDate.addSeconds(startTime, JulianDate.secondsDifference(currentTime, stopTime), currentTime);
	                    }
	                }
	            }
	        }

	        this.currentTime = currentTime;
	        this._lastSystemTime = currentSystemTime;
	        this.onTick.raiseEvent(this);
	        return currentTime;
	    };

	    return Clock;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Constants used by {@link Clock#tick} to determine behavior
	     * when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
	     *
	     * @namespace
	     * @alias ClockRange
	     *
	     * @see Clock
	     * @see ClockStep
	     */
	    var ClockRange = {
	        /**
	         * {@link Clock#tick} will always advances the clock in its current direction.
	         *
	         * @type {Number}
	         * @constant
	         */
	        UNBOUNDED : 0,

	        /**
	         * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
	         * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.
	         *
	         * @type {Number}
	         * @constant
	         */
	        CLAMPED : 1,

	        /**
	         * When {@link Clock#stopTime} is reached, {@link Clock#tick} will advance
	         * {@link Clock#currentTime} to the opposite end of the interval.  When
	         * time is moving backwards, {@link Clock#tick} will not advance past
	         * {@link Clock#startTime}
	         *
	         * @type {Number}
	         * @constant
	         */
	        LOOP_STOP : 2
	    };

	    return freezeObject(ClockRange);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    /**
	     * A set of Earth Orientation Parameters (EOP) sampled at a time.
	     *
	     * @alias EarthOrientationParametersSample
	     * @constructor
	     *
	     * @param {Number} xPoleWander The pole wander about the X axis, in radians.
	     * @param {Number} yPoleWander The pole wander about the Y axis, in radians.
	     * @param {Number} xPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.
	     * @param {Number} yPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.
	     * @param {Number} ut1MinusUtc The difference in time standards, UT1 - UTC, in seconds.
	     *
	     * @private
	     */
	    var EarthOrientationParametersSample = function EarthOrientationParametersSample(xPoleWander, yPoleWander, xPoleOffset, yPoleOffset, ut1MinusUtc) {
	        /**
	         * The pole wander about the X axis, in radians.
	         * @type {Number}
	         */
	        this.xPoleWander = xPoleWander;

	        /**
	         * The pole wander about the Y axis, in radians.
	         * @type {Number}
	         */
	        this.yPoleWander = yPoleWander;

	        /**
	         * The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.
	         * @type {Number}
	         */
	        this.xPoleOffset = xPoleOffset;

	        /**
	         * The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.
	         * @type {Number}
	         */
	        this.yPoleOffset = yPoleOffset;

	        /**
	         * The difference in time standards, UT1 - UTC, in seconds.
	         * @type {Number}
	         */
	        this.ut1MinusUtc = ut1MinusUtc;
	    };

	    return EarthOrientationParametersSample;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        DeveloperError) {
	    "use strict";

	    /**
	     * A convenience object that simplifies the common pattern of attaching event listeners
	     * to several events, then removing all those listeners at once later, for example, in
	     * a destroy method.
	     *
	     * @alias EventHelper
	     * @constructor
	     *
	     * @see Event
	     *
	     * @example
	     * var helper = new Cesium.EventHelper();
	     *
	     * helper.add(someObject.event, listener1, this);
	     * helper.add(otherObject.event, listener2, this);
	     *
	     * // later...
	     * helper.removeAll();
	     */
	    var EventHelper = function() {
	        this._removalFunctions = [];
	    };

	    /**
	     * Adds a listener to an event, and records the registration to be cleaned up later.
	     *
	     * @param {Event} event The event to attach to.
	     * @param {Function} listener The function to be executed when the event is raised.
	     * @param {Object} [scope] An optional object scope to serve as the <code>this</code>
	     *        pointer in which the listener function will execute.
	     * @returns {EventHelper~RemoveCallback} A function that will remove this event listener when invoked.
	     *
	     * @see Event#addEventListener
	     */
	    EventHelper.prototype.add = function(event, listener, scope) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(event)) {
	            throw new DeveloperError('event is required');
	        }
	        //>>includeEnd('debug');

	        var removalFunction = event.addEventListener(listener, scope);
	        this._removalFunctions.push(removalFunction);

	        var that = this;
	        return function() {
	            removalFunction();
	            var removalFunctions = that._removalFunctions;
	            removalFunctions.splice(removalFunctions.indexOf(removalFunction), 1);
	        };
	    };

	    /**
	     * Unregisters all previously added listeners.
	     *
	     * @see Event#removeEventListener
	     */
	    EventHelper.prototype.removeAll = function() {
	        var removalFunctions = this._removalFunctions;
	        for (var i = 0, len = removalFunctions.length; i < len; ++i) {
	            removalFunctions[i]();
	        }
	        removalFunctions.length = 0;
	    };

	    /**
	     * A function that removes a listener.
	     * @callback EventHelper~RemoveCallback
	     */

	    return EventHelper;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(163)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        Fullscreen) {
	    "use strict";

	    function extractVersion(versionString) {
	        var parts = versionString.split('.');
	        for (var i = 0, len = parts.length; i < len; ++i) {
	            parts[i] = parseInt(parts[i], 10);
	        }
	        return parts;
	    }

	    var isChromeResult;
	    var chromeVersionResult;
	    function isChrome() {
	        if (!defined(isChromeResult)) {
	            isChromeResult = false;

	            var fields = (/ Chrome\/([\.0-9]+)/).exec(navigator.userAgent);
	            if (fields !== null) {
	                isChromeResult = true;
	                chromeVersionResult = extractVersion(fields[1]);
	            }
	        }

	        return isChromeResult;
	    }

	    function chromeVersion() {
	        return isChrome() && chromeVersionResult;
	    }

	    var isSafariResult;
	    var safariVersionResult;
	    function isSafari() {
	        if (!defined(isSafariResult)) {
	            isSafariResult = false;

	            // Chrome contains Safari in the user agent too
	            if (!isChrome() && (/ Safari\/[\.0-9]+/).test(navigator.userAgent)) {
	                var fields = (/ Version\/([\.0-9]+)/).exec(navigator.userAgent);
	                if (fields !== null) {
	                    isSafariResult = true;
	                    safariVersionResult = extractVersion(fields[1]);
	                }
	            }
	        }

	        return isSafariResult;
	    }

	    function safariVersion() {
	        return isSafari() && safariVersionResult;
	    }

	    var isWebkitResult;
	    var webkitVersionResult;
	    function isWebkit() {
	        if (!defined(isWebkitResult)) {
	            isWebkitResult = false;

	            var fields = (/ AppleWebKit\/([\.0-9]+)(\+?)/).exec(navigator.userAgent);
	            if (fields !== null) {
	                isWebkitResult = true;
	                webkitVersionResult = extractVersion(fields[1]);
	                webkitVersionResult.isNightly = !!fields[2];
	            }
	        }

	        return isWebkitResult;
	    }

	    function webkitVersion() {
	        return isWebkit() && webkitVersionResult;
	    }

	    var isInternetExplorerResult;
	    var internetExplorerVersionResult;
	    function isInternetExplorer() {
	        if (!defined(isInternetExplorerResult)) {
	            isInternetExplorerResult = false;

	            var fields;
	            if (navigator.appName === 'Microsoft Internet Explorer') {
	                fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent);
	                if (fields !== null) {
	                    isInternetExplorerResult = true;
	                    internetExplorerVersionResult = extractVersion(fields[1]);
	                }
	            } else if (navigator.appName === 'Netscape') {
	                fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent);
	                if (fields !== null) {
	                    isInternetExplorerResult = true;
	                    internetExplorerVersionResult = extractVersion(fields[1]);
	                }
	            }
	        }
	        return isInternetExplorerResult;
	    }

	    function internetExplorerVersion() {
	        return isInternetExplorer() && internetExplorerVersionResult;
	    }

	    var isFirefoxResult;
	    var firefoxVersionResult;
	    function isFirefox() {
	        if (!defined(isFirefoxResult)) {
	            isFirefoxResult = false;

	            var fields = /Firefox\/([\.0-9]+)/.exec(navigator.userAgent);
	            if (fields !== null) {
	                isFirefoxResult = true;
	                firefoxVersionResult = extractVersion(fields[1]);
	            }
	        }
	        return isFirefoxResult;
	    }

	    var isWindowsResult;
	    function isWindows() {
	        if (!defined(isWindowsResult)) {
	            isWindowsResult = /Windows/i.test(navigator.appVersion);
	        }
	        return isWindowsResult;
	    }


	    function firefoxVersion() {
	        return isFirefox() && firefoxVersionResult;
	    }

	    var hasPointerEvents;
	    function supportsPointerEvents() {
	        if (!defined(hasPointerEvents)) {
	            //While window.navigator.pointerEnabled is deprecated in the W3C specification
	            //we still need to use it if it exists in order to support browsers
	            //that rely on it, such as the Windows WebBrowser control which defines
	            //window.PointerEvent but sets window.navigator.pointerEnabled to false.
	            hasPointerEvents = defined(window.PointerEvent) && (!defined(window.navigator.pointerEnabled) || window.navigator.pointerEnabled);
	        }
	        return hasPointerEvents;
	    }

	    /**
	     * A set of functions to detect whether the current browser supports
	     * various features.
	     *
	     * @namespace
	     * @alias FeatureDetection
	     */
	    var FeatureDetection = {
	        isChrome : isChrome,
	        chromeVersion : chromeVersion,
	        isSafari : isSafari,
	        safariVersion : safariVersion,
	        isWebkit : isWebkit,
	        webkitVersion : webkitVersion,
	        isInternetExplorer : isInternetExplorer,
	        internetExplorerVersion : internetExplorerVersion,
	        isFirefox : isFirefox,
	        firefoxVersion : firefoxVersion,
	        isWindows : isWindows,
	        hardwareConcurrency : defaultValue(navigator.hardwareConcurrency, 3),
	        supportsPointerEvents : supportsPointerEvents
	    };

	    /**
	     * Detects whether the current browser supports the full screen standard.
	     *
	     * @returns true if the browser supports the full screen standard, false if not.
	     *
	     * @see Fullscreen
	     * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
	     */
	    FeatureDetection.supportsFullscreen = function() {
	        return Fullscreen.supportsFullscreen();
	    };

	    /**
	     * Detects whether the current browser supports typed arrays.
	     *
	     * @returns true if the browser supports typed arrays, false if not.
	     *
	     * @see {@link http://www.khronos.org/registry/typedarray/specs/latest/|Typed Array Specification}
	     */
	    FeatureDetection.supportsTypedArrays = function() {
	        return typeof ArrayBuffer !== 'undefined';
	    };

	    /**
	     * Detects whether the current browser supports Web Workers.
	     *
	     * @returns true if the browsers supports Web Workers, false if not.
	     *
	     * @see {@link http://www.w3.org/TR/workers/}
	     */
	    FeatureDetection.supportsWebWorkers = function() {
	        return typeof Worker !== 'undefined';
	    };

	    return FeatureDetection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError,
	        CesiumMath) {
	    "use strict";

	    var factorial = CesiumMath.factorial;

	    function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
	        var result = 0;
	        var reserved;
	        var i;
	        var j;

	        if (derivOrder > 0) {
	            for (i = 0; i < termOrder; i++) {
	                reserved = false;
	                for (j = 0; j < reservedIndices.length && !reserved; j++) {
	                    if (i === reservedIndices[j]) {
	                        reserved = true;
	                    }
	                }

	                if (!reserved) {
	                    reservedIndices.push(i);
	                    result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
	                    reservedIndices.splice(reservedIndices.length - 1, 1);
	                }
	            }

	            return result;
	        }

	        result = 1;
	        for (i = 0; i < termOrder; i++) {
	            reserved = false;
	            for (j = 0; j < reservedIndices.length && !reserved; j++) {
	                if (i === reservedIndices[j]) {
	                    reserved = true;
	                }
	            }

	            if (!reserved) {
	                result *= x - xTable[zIndices[i]];
	            }
	        }

	        return result;
	    }

	    /**
	     * An {@link InterpolationAlgorithm} for performing Hermite interpolation.
	     *
	     * @namespace
	     * @alias HermitePolynomialApproximation
	     */
	    var HermitePolynomialApproximation = {
	        type : 'Hermite'
	    };

	    /**
	     * Given the desired degree, returns the number of data points required for interpolation.
	     *
	     * @param {Number} degree The desired degree of interpolation.
	     * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).
	     * @returns The number of required data points needed for the desired degree of interpolation.
	     * @exception {DeveloperError} degree must be 0 or greater.
	     * @exception {DeveloperError} inputOrder must be 0 or greater.
	     */
	    HermitePolynomialApproximation.getRequiredDataPoints = function(degree, inputOrder) {
	        inputOrder = defaultValue(inputOrder, 0);

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(degree)) {
	            throw new DeveloperError('degree is required.');
	        }
	        if (degree < 0) {
	            throw new DeveloperError('degree must be 0 or greater.');
	        }
	        if (inputOrder < 0) {
	            throw new DeveloperError('inputOrder must be 0 or greater.');
	        }
	        //>>includeEnd('debug');

	        return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);
	    };

	    /**
	     * Interpolates values using Hermite Polynomial Approximation.
	     *
	     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
	     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
	     * in this array must be in increasing order and the same value must not occur twice in the array.
	     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
	     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
	     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
	     * each independent variable value in xTable.
	     * @param {Number[]} [result] An existing array into which to store the result.
	     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
	     */
	    HermitePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
	        if (!defined(result)) {
	            result = new Array(yStride);
	        }

	        var i;
	        var j;
	        var d;
	        var s;
	        var len;
	        var index;
	        var length = xTable.length;
	        var coefficients = new Array(yStride);

	        for (i = 0; i < yStride; i++) {
	            result[i] = 0;

	            var l = new Array(length);
	            coefficients[i] = l;
	            for (j = 0; j < length; j++) {
	                l[j] = [];
	            }
	        }

	        var zIndicesLength = length, zIndices = new Array(zIndicesLength);

	        for (i = 0; i < zIndicesLength; i++) {
	            zIndices[i] = i;
	        }

	        var highestNonZeroCoef = length - 1;
	        for (s = 0; s < yStride; s++) {
	            for (j = 0; j < zIndicesLength; j++) {
	                index = zIndices[j] * yStride + s;
	                coefficients[s][0].push(yTable[index]);
	            }

	            for (i = 1; i < zIndicesLength; i++) {
	                var nonZeroCoefficients = false;
	                for (j = 0; j < zIndicesLength - i; j++) {
	                    var zj = xTable[zIndices[j]];
	                    var zn = xTable[zIndices[j + i]];

	                    var numerator;
	                    if (zn - zj <= 0) {
	                        index = zIndices[j] * yStride + yStride * i + s;
	                        numerator = yTable[index];
	                        coefficients[s][i].push(numerator / factorial(i));
	                    } else {
	                        numerator = (coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j]);
	                        coefficients[s][i].push(numerator / (zn - zj));
	                    }
	                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0);
	                }

	                if (!nonZeroCoefficients) {
	                    highestNonZeroCoef = i - 1;
	                }
	            }
	        }

	        for (d = 0, len = 0; d <= len; d++) {
	            for (i = d; i <= highestNonZeroCoef; i++) {
	                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
	                for (s = 0; s < yStride; s++) {
	                    var coeff = coefficients[s][i][0];
	                    result[s + d * yStride] += coeff * tempTerm;
	                }
	            }
	        }

	        return result;
	    };

	    var arrayScratch = [];

	    /**
	     * Interpolates values using Hermite Polynomial Approximation.
	     *
	     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
	     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
	     * in this array must be in increasing order and the same value must not occur twice in the array.
	     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
	     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
	     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
	     * each independent variable value in xTable.
	     * @param {Number} inputOrder The number of derivatives supplied for input.
	     * @param {Number} outputOrder The number of derivatives desired for output.
	     * @param {Number[]} [result] An existing array into which to store the result.
	     *
	     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
	     */
	    HermitePolynomialApproximation.interpolate = function(x, xTable, yTable, yStride, inputOrder, outputOrder, result) {
	        var resultLength = yStride * (outputOrder + 1);
	        if (!defined(result)) {
	            result = new Array(resultLength);
	        }
	        for (var r = 0; r < resultLength; r++) {
	            result[r] = 0;
	        }

	        var length = xTable.length;
	        // The zIndices array holds copies of the addresses of the xTable values
	        // in the range we're looking at. Even though this just holds information already
	        // available in xTable this is a much more convenient format.
	        var zIndices = new Array(length * (inputOrder + 1));
	        for (var i = 0; i < length; i++) {
	            for (var j = 0; j < (inputOrder + 1); j++) {
	                zIndices[i * (inputOrder + 1) + j] = i;
	            }
	        }

	        var zIndiceslength = zIndices.length;
	        var coefficients = arrayScratch;
	        var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);
	        var reservedIndices = [];

	        var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
	        var loopStop = Math.min(highestNonZeroCoef, outputOrder);
	        for (var d = 0; d <= loopStop; d++) {
	            for (i = d; i <= highestNonZeroCoef; i++) {
	                reservedIndices.length = 0;
	                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);
	                var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);

	                for (var s = 0; s < yStride; s++) {
	                    var dimOne = Math.floor(s * tmp);
	                    var coef = coefficients[dimOne + dimTwo];
	                    result[s + d * yStride] += coef * tempTerm;
	                }
	            }
	        }

	        return result;
	    };

	    function fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {
	        var j;
	        var index;
	        var highestNonZero = -1;
	        var zIndiceslength = zIndices.length;
	        var tmp = zIndiceslength * (zIndiceslength + 1) / 2;

	        for (var s = 0; s < yStride; s++) {
	            var dimOne = Math.floor(s * tmp);

	            for (j = 0; j < zIndiceslength; j++) {
	                index = zIndices[j] * yStride * (inputOrder + 1) + s;
	                coefficients[dimOne + j] = yTable[index];
	            }

	            for (var i = 1; i < zIndiceslength; i++) {
	                var coefIndex = 0;
	                var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);
	                var nonZeroCoefficients = false;

	                for (j = 0; j < zIndiceslength - i; j++) {
	                    var zj = xTable[zIndices[j]];
	                    var zn = xTable[zIndices[j + i]];

	                    var numerator;
	                    var coefficient;
	                    if (zn - zj <= 0) {
	                        index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;
	                        numerator = yTable[index];
	                        coefficient = (numerator / CesiumMath.factorial(i));
	                        coefficients[dimOne + dimTwo + coefIndex] = coefficient;
	                        coefIndex++;
	                    } else {
	                        var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + (zIndiceslength * (i - 1));
	                        numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];
	                        coefficient = (numerator / (zn - zj));
	                        coefficients[dimOne + dimTwo + coefIndex] = coefficient;
	                        coefIndex++;
	                    }
	                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0.0);
	                }

	                if (nonZeroCoefficients) {
	                    highestNonZero = Math.max(highestNonZero, i);
	                }
	            }
	        }

	        return highestNonZero;
	    }

	    return HermitePolynomialApproximation;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    /**
	     * An IAU 2006 XYS value sampled at a particular time.
	     *
	     * @alias Iau2006XysSample
	     * @constructor
	     *
	     * @param {Number} x The X value.
	     * @param {Number} y The Y value.
	     * @param {Number} s The S value.
	     *
	     * @private
	     */
	    var Iau2006XysSample = function Iau2006XysSample(x, y, s) {
	        /**
	         * The X value.
	         * @type {Number}
	         */
	        this.x = x;

	        /**
	         * The Y value.
	         * @type {Number}
	         */
	        this.y = y;

	        /**
	         * The S value.
	         * @type {Number}
	         */
	        this.s = s;
	    };

	    return Iau2006XysSample;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    /**
	     * Describes a single leap second, which is constructed from a {@link JulianDate} and a
	     * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
	     * @alias LeapSecond
	     * @constructor
	     *
	     * @param {JulianDate} [date] A Julian date representing the time of the leap second.
	     * @param {Number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.
	     */
	    var LeapSecond = function(date, offset) {
	        /**
	         * Gets or sets the date at which this leap second occurs.
	         * @type {JulianDate}
	         */
	        this.julianDate = date;

	        /**
	         * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time
	         * of this leap second.
	         * @type {Number}
	         */
	        this.offset = offset;
	    };

	    return LeapSecond;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        DeveloperError) {
	    "use strict";

	    /**
	     * An {@link InterpolationAlgorithm} for performing linear interpolation.
	     *
	     * @namespace
	     * @alias LinearApproximation
	     */
	    var LinearApproximation = {
	        type : 'Linear'
	    };

	    /**
	     * Given the desired degree, returns the number of data points required for interpolation.
	     * Since linear interpolation can only generate a first degree polynomial, this function
	     * always returns 2.
	     * @param {Number} degree The desired degree of interpolation.
	     * @returns {Number} This function always returns 2.
	     *
	     */
	    LinearApproximation.getRequiredDataPoints = function(degree) {
	        return 2;
	    };

	    /**
	     * Interpolates values using linear approximation.
	     *
	     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
	     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
	     * in this array must be in increasing order and the same value must not occur twice in the array.
	     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
	     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
	     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
	     * each independent variable value in xTable.
	     * @param {Number[]} [result] An existing array into which to store the result.
	     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
	     */
	    LinearApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (xTable.length !== 2) {
	            throw new DeveloperError('The xTable provided to the linear interpolator must have exactly two elements.');
	        } else if (yStride <= 0) {
	            throw new DeveloperError('There must be at least 1 dependent variable for each independent variable.');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            result = new Array(yStride);
	        }

	        var i;
	        var y0;
	        var y1;
	        var x0 = xTable[0];
	        var x1 = xTable[1];

	        //>>includeStart('debug', pragmas.debug);
	        if (x0 === x1) {
	            throw new DeveloperError('Divide by zero error: xTable[0] and xTable[1] are equal');
	        }
	        //>>includeEnd('debug');

	        for (i = 0; i < yStride; i++) {
	            y0 = yTable[i];
	            y1 = yTable[i + yStride];
	            result[i] = (((y1 - y0) * x) + (x1 * y0) - (x0 * y1)) / (x1 - x0);
	        }

	        return result;
	    };

	    return LinearApproximation;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a two dimensional icon located at the position of the containing {@link Entity}.
	     * <p>
	     * <div align='center'>
	     * <img src='images/Billboard.png' width='400' height='300' /><br />
	     * Example billboards
	     * </div>
	     * </p>
	     *
	     * @alias BillboardGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.image] A Property specifying the Image, URI, or Canvas to use for the billboard.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the billboard.
	     * @param {Property} [options.scale=1.0] A numeric Property specifying the scale to apply to the image size.
	     * @param {Property} [options.horizontalOrigin=HorizontalOrigin.CENTER] A Property specifying the {@link HorizontalOrigin}.
	     * @param {Property} [options.verticalOrigin=VerticalOrigin.CENTER] A Property specifying the {@link VerticalOrigin}.
	     * @param {Property} [options.eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the eye offset.
	     * @param {Property} [options.pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} Property specifying the pixel offset.
	     * @param {Property} [options.rotation=0] A numeric Property specifying the rotation about the alignedAxis.
	     * @param {Property} [options.alignedAxis=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the axis of rotation.
	     * @param {Property} [options.width] A numeric Property specifying the width of the billboard in pixels, overriding the native size.
	     * @param {Property} [options.height] A numeric Property specifying the height of the billboard in pixels, overriding the native size.
	     * @param {Property} [options.color=Color.WHITE] A Property specifying the tint {@link Color} of the image.
	     * @param {Property} [options.scaleByDistance] A {@link NearFarScalar} Property used to scale the point based on distance from the camera.
	     * @param {Property} [options.translucencyByDistance] A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
	     * @param {Property} [options.pixelOffsetScaleByDistance] A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
	     * @param {Property} [options.imageSubRegion] A Property specifying a {@link BoundingRectangle} that defines a sub-region of the image to use for the billboard, rather than the entire image.
	     *
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}
	     */
	    var BillboardGraphics = function(options) {
	        this._image = undefined;
	        this._imageSubscription = undefined;
	        this._imageSubRegion = undefined;
	        this._imageSubRegionSubscription = undefined;
	        this._width = undefined;
	        this._widthSubscription = undefined;
	        this._height = undefined;
	        this._heightSubscription = undefined;
	        this._scale = undefined;
	        this._scaleSubscription = undefined;
	        this._rotation = undefined;
	        this._rotationSubscription = undefined;
	        this._alignedAxis = undefined;
	        this._alignedAxisSubscription = undefined;
	        this._horizontalOrigin = undefined;
	        this._horizontalOriginSubscription = undefined;
	        this._verticalOrigin = undefined;
	        this._verticalOriginSubscription = undefined;
	        this._color = undefined;
	        this._colorSubscription = undefined;
	        this._eyeOffset = undefined;
	        this._eyeOffsetSubscription = undefined;
	        this._pixelOffset = undefined;
	        this._pixelOffsetSubscription = undefined;
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._scaleByDistance = undefined;
	        this._scaleByDistanceSubscription = undefined;
	        this._translucencyByDistance = undefined;
	        this._translucencyByDistanceSubscription = undefined;
	        this._pixelOffsetScaleByDistance = undefined;
	        this._pixelOffsetScaleByDistanceSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(BillboardGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof BillboardGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the Property specifying the Image, URI, or Canvas to use for the billboard.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         */
	        image : createPropertyDescriptor('image'),

	        /**
	         * Gets or sets the Property specifying a {@link BoundingRectangle} that defines a
	         * sub-region of the <code>image</code> to use for the billboard, rather than the entire image.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         */
	        imageSubRegion : createPropertyDescriptor('imageSubRegion'),

	        /**
	         * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
	         * A scale greater than <code>1.0</code> enlarges the billboard while a scale less than <code>1.0</code> shrinks it.
	         * <p>
	         * <div align='center'>
	         * <img src='images/Billboard.setScale.png' width='400' height='300' /><br/>
	         * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>, and <code>2.0</code>.
	         * </div>
	         * </p>
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        scale : createPropertyDescriptor('scale'),

	        /**
	         * Gets or sets the numeric Property specifying the rotation of the image
	         * counter clockwise from the <code>alignedAxis</code>.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default 0
	         */
	        rotation : createPropertyDescriptor('rotation'),

	        /**
	         * Gets or sets the {@link Cartesian3} Property specifying the axis of rotation
	         * in the fixed frame. When set to Cartesian3.ZERO the rotation is from the top of the screen.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default Cartesian3.ZERO
	         */
	        alignedAxis : createPropertyDescriptor('alignedAxis'),

	        /**
	         * Gets or sets the Property specifying the {@link HorizontalOrigin}.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default HorizontalOrigin.CENTER
	         */
	        horizontalOrigin : createPropertyDescriptor('horizontalOrigin'),

	        /**
	         * Gets or sets the Property specifying the {@link VerticalOrigin}.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default VerticalOrigin.CENTER
	         */
	        verticalOrigin : createPropertyDescriptor('verticalOrigin'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} that is multiplied with the <code>image</code>.
	         * This has two common use cases.  First, the same white texture may be used by many different billboards,
	         * each with a different color, to create colored billboards. Second, the color's alpha component can be
	         * used to make the billboard translucent as shown below. An alpha of <code>0.0</code> makes the billboard
	         * transparent, and <code>1.0</code> makes the billboard opaque.
	         * <p>
	         * <div align='center'>
	         * <table border='0' cellpadding='5'><tr>
	         * <td align='center'><code>default</code><br/><img src='images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
	         * <td align='center'><code>alpha : 0.5</code><br/><img src='images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
	         * </tr></table>
	         * </div>
	         * </p>
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default Color.WHITE
	         */
	        color : createPropertyDescriptor('color'),

	        /**
	         * Gets or sets the {@link Cartesian3} Property specifying the billboard's offset in eye coordinates.
	         * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
	         * right, <code>y</code> points up, and <code>z</code> points into the screen.
	         * <p>
	         * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
	         * arrange a billboard above its corresponding 3D model.
	         * </p>
	         * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
	         * appear on top of the Earth regardless of the viewer's or Earth's orientation.
	         * <p>
	         * <div align='center'>
	         * <table border='0' cellpadding='5'><tr>
	         * <td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
	         * <td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
	         * </tr></table>
	         * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code>
	         * </div>
	         * </p>
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default Cartesian3.ZERO
	         */
	        eyeOffset : createPropertyDescriptor('eyeOffset'),

	        /**
	         * Gets or sets the {@link Cartesian2} Property specifying the billboard's pixel offset in screen space
	         * from the origin of this billboard.  This is commonly used to align multiple billboards and labels at
	         * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
	         * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
	         * <p>
	         * <div align='center'>
	         * <table border='0' cellpadding='5'><tr>
	         * <td align='center'><code>default</code><br/><img src='images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
	         * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
	         * </tr></table>
	         * The billboard's origin is indicated by the yellow point.
	         * </div>
	         * </p>
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default Cartesian2.ZERO
	         */
	        pixelOffset : createPropertyDescriptor('pixelOffset'),

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the billboard.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the numeric Property specifying the billboard's width in pixels.
	         * When undefined, the native width is used.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         */
	        width : createPropertyDescriptor('width'),

	        /**
	         * Gets or sets the numeric Property specifying the height of the billboard in pixels.
	         * When undefined, the native height is used.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         */
	        height : createPropertyDescriptor('height'),

	        /**
	         * Gets or sets {@link NearFarScalar} Property specifying the scale of the billboard based on the distance from the camera.
	         * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
	         * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
	         * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
	         * Outside of these ranges the billboard's scale remains clamped to the nearest bound.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         */
	        scaleByDistance : createPropertyDescriptor('scaleByDistance'),

	        /**
	         * Gets or sets {@link NearFarScalar} Property specifying the translucency of the billboard based on the distance from the camera.
	         * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
	         * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
	         * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
	         * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         */
	        translucencyByDistance : createPropertyDescriptor('translucencyByDistance'),

	        /**
	         * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the billboard based on the distance from the camera.
	         * A billboard's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
	         * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
	         * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
	         * Outside of these ranges the billboard's pixel offset remains clamped to the nearest bound.
	         * @memberof BillboardGraphics.prototype
	         * @type {Property}
	         */
	        pixelOffsetScaleByDistance : createPropertyDescriptor('pixelOffsetScaleByDistance')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {BillboardGraphics} [result] The object onto which to store the result.
	     * @returns {BillboardGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    BillboardGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new BillboardGraphics(this);
	        }
	        result.color = this._color;
	        result.eyeOffset = this._eyeOffset;
	        result.horizontalOrigin = this._horizontalOrigin;
	        result.image = this._image;
	        result.imageSubRegion = this._imageSubRegion;
	        result.pixelOffset = this._pixelOffset;
	        result.scale = this._scale;
	        result.rotation = this._rotation;
	        result.alignedAxis = this._alignedAxis;
	        result.show = this._show;
	        result.verticalOrigin = this._verticalOrigin;
	        result.width = this._width;
	        result.height = this._height;
	        result.scaleByDistance = this._scaleByDistance;
	        result.translucencyByDistance = this._translucencyByDistance;
	        result.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {BillboardGraphics} source The object to be merged into this object.
	     */
	    BillboardGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.color = defaultValue(this._color, source.color);
	        this.eyeOffset = defaultValue(this._eyeOffset, source.eyeOffset);
	        this.horizontalOrigin = defaultValue(this._horizontalOrigin, source.horizontalOrigin);
	        this.image = defaultValue(this._image, source.image);
	        this.imageSubRegion = defaultValue(this._imageSubRegion, source.imageSubRegion);
	        this.pixelOffset = defaultValue(this._pixelOffset, source.pixelOffset);
	        this.scale = defaultValue(this._scale, source.scale);
	        this.rotation = defaultValue(this._rotation, source.rotation);
	        this.alignedAxis = defaultValue(this._alignedAxis, source.alignedAxis);
	        this.show = defaultValue(this._show, source.show);
	        this.verticalOrigin = defaultValue(this._verticalOrigin, source.verticalOrigin);
	        this.width = defaultValue(this._width, source.width);
	        this.height = defaultValue(this._height, source.height);
	        this.scaleByDistance = defaultValue(this._scaleByDistance, source.scaleByDistance);
	        this.translucencyByDistance = defaultValue(this._translucencyByDistance, source.translucencyByDistance);
	        this.pixelOffsetScaleByDistance = defaultValue(this._pixelOffsetScaleByDistance, source.pixelOffsetScaleByDistance);
	    };

	    return BillboardGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(37),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(56),
	        __webpack_require__(8),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Color,
	        defined,
	        defineProperties,
	        deprecationWarning,
	        DeveloperError,
	        Event,
	        ConstantProperty,
	        createPropertyDescriptor,
	        Property) {
	    "use strict";

	    /**
	     * A {@link MaterialProperty} that maps to solid color {@link Material} uniforms.
	     *
	     * @param {Property} [color=Color.WHITE] The {@link Color} Property to be used.
	     *
	     * @alias ColorMaterialProperty
	     * @constructor
	     */
	    var ColorMaterialProperty = function(color) {
	        this._definitionChanged = new Event();
	        this._color = undefined;
	        this._colorSubscription = undefined;
	        this.color = color;
	    };

	    /**
	     * Creates a new instance that represents a constant color.
	     *
	     * @param {Color} color The color.
	     * @returns {ColorMaterialProperty} A new instance configured to represent the provided color.
	     * @deprecated
	     */
	    ColorMaterialProperty.fromColor = function(color) {
	        deprecationWarning('ColorMaterialProperty.fromColor', 'ColorMaterialProperty.fromColor was deprecated in Cesium 1.6.  It will be removed in 1.9.  Use "new ColorMaterialProperty(color)" instead.');

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(color)) {
	            throw new DeveloperError('color is required');
	        }
	        //>>includeEnd('debug');
	        return new ColorMaterialProperty(color);
	    };

	    defineProperties(ColorMaterialProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof ColorMaterialProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return Property.isConstant(this._color);
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof ColorMaterialProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets or sets the {@link Color} {@link Property}.
	         * @memberof ColorMaterialProperty.prototype
	         * @type {Property}
	         * @default Color.WHITE
	         */
	        color : createPropertyDescriptor('color')
	    });

	    /**
	     * Gets the {@link Material} type at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    ColorMaterialProperty.prototype.getType = function(time) {
	        return 'Color';
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    ColorMaterialProperty.prototype.getValue = function(time, result) {
	        if (!defined(result)) {
	            result = {};
	        }
	        result.color = Property.getValueOrClonedDefault(this._color, time, Color.WHITE, result.color);
	        return result;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    ColorMaterialProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof ColorMaterialProperty && //
	                Property.equals(this._color, other._color));
	    };

	    return ColorMaterialProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes an ellipse defined by a center point and semi-major and semi-minor axes.
	     * The ellipse conforms to the curvature of the globe and can be placed on the surface or
	     * at altitude and can optionally be extruded into a volume.
	     * The center point is determined by the containing {@link Entity}.
	     *
	     * @alias EllipseGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.semiMajorAxis] The numeric Property specifying the semi-major axis.
	     * @param {Property} [options.semiMinorAxis] The numeric Property specifying the semi-minor axis.
	     * @param {Property} [options.height=0] A numeric Property specifying the altitude of the ellipse.
	     * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the ellipse extrusion.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the ellipse.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the ellipse is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the ellipse.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the ellipse is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.numberOfVerticalLines=16] A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
	     * @param {Property} [options.rotation=0.0] A numeric property specifying the rotation of the ellipse counter-clockwise from north.
	     * @param {Property} [options.stRotation=0.0] A numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
	     * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between points on the ellipse.
	     *
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Circles and Ellipses.html|Cesium Sandcastle Circles and Ellipses Demo}
	     */
	    var EllipseGraphics = function(options) {
	        this._semiMajorAxis = undefined;
	        this._semiMajorAxisSubscription = undefined;
	        this._semiMinorAxis = undefined;
	        this._semiMinorAxisSubscription = undefined;
	        this._rotation = undefined;
	        this._rotationSubscription = undefined;
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._height = undefined;
	        this._heightSubscription = undefined;
	        this._extrudedHeight = undefined;
	        this._extrudedHeightSubscription = undefined;
	        this._granularity = undefined;
	        this._granularitySubscription = undefined;
	        this._stRotation = undefined;
	        this._stRotationSubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._numberOfVerticalLines = undefined;
	        this._numberOfVerticalLinesSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(EllipseGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof EllipseGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the numeric Property specifying the semi-major axis.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         */
	        semiMajorAxis : createPropertyDescriptor('semiMajorAxis'),

	        /**
	         * Gets or sets the numeric Property specifying the semi-minor axis.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         */
	        semiMinorAxis : createPropertyDescriptor('semiMinorAxis'),

	        /**
	         * Gets or sets the numeric property specifying the rotation of the ellipse clockwise from north.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default 0
	         */
	        rotation : createPropertyDescriptor('rotation'),

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the ellipse.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the ellipse.
	         * @memberof EllipseGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the numeric Property specifying the altitude of the ellipse.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default 0.0
	         */
	        height : createPropertyDescriptor('height'),

	        /**
	         * Gets or sets the numeric Property specifying the altitude of the ellipse extrusion.
	         * Setting this property creates volume starting at height and ending at this altitude.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         */
	        extrudedHeight : createPropertyDescriptor('extrudedHeight'),

	        /**
	         * Gets or sets the numeric Property specifying the angular distance between points on the ellipse.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default {CesiumMath.RADIANS_PER_DEGREE}
	         */
	        granularity : createPropertyDescriptor('granularity'),

	        /**
	         * Gets or sets the numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default 0
	         */
	        stRotation : createPropertyDescriptor('stRotation'),

	        /**
	         * Gets or sets the boolean Property specifying whether the ellipse is filled with the provided material.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the ellipse is outlined.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
	         * @memberof EllipseGraphics.prototype
	         * @type {Property}
	         * @default 16
	         */
	        numberOfVerticalLines : createPropertyDescriptor('numberOfVerticalLines')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {EllipseGraphics} [result] The object onto which to store the result.
	     * @returns {EllipseGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    EllipseGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new EllipseGraphics(this);
	        }
	        result.rotation = this.rotation;
	        result.semiMajorAxis = this.semiMajorAxis;
	        result.semiMinorAxis = this.semiMinorAxis;
	        result.show = this.show;
	        result.material = this.material;
	        result.height = this.height;
	        result.extrudedHeight = this.extrudedHeight;
	        result.granularity = this.granularity;
	        result.stRotation = this.stRotation;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.numberOfVerticalLines = this.numberOfVerticalLines;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {EllipseGraphics} source The object to be merged into this object.
	     */
	    EllipseGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.rotation = defaultValue(this.rotation, source.rotation);
	        this.semiMajorAxis = defaultValue(this.semiMajorAxis, source.semiMajorAxis);
	        this.semiMinorAxis = defaultValue(this.semiMinorAxis, source.semiMinorAxis);
	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.height = defaultValue(this.height, source.height);
	        this.extrudedHeight = defaultValue(this.extrudedHeight, source.extrudedHeight);
	        this.granularity = defaultValue(this.granularity, source.granularity);
	        this.stRotation = defaultValue(this.stRotation, source.stRotation);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.numberOfVerticalLines = defaultValue(this.numberOfVerticalLines, source.numberOfVerticalLines);
	    };

	    return EllipseGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describe an ellipsoid or sphere.  The center position and orientation are determined by the containing {@link Entity}.
	     *
	     * @alias EllipsoidGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.radii] A {@link Cartesian3} Property specifying the radii of the ellipsoid.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the ellipsoid.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the ellipsoid is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the ellipsoid.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the ellipsoid is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.subdivisions=128] A Property specifying the number of samples per outline ring, determining the granularity of the curvature.
	     * @param {Property} [options.stackPartitions=64] A Property specifying the number of stacks.
	     * @param {Property} [options.slicePartitions=64] A Property specifying the number of radial slices.
	     *
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Spheres%20and%20Ellipsoids.html|Cesium Sandcastle Spheres and Ellipsoids Demo}
	     */
	    var EllipsoidGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._radii = undefined;
	        this._radiiSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._stackPartitions = undefined;
	        this._stackPartitionsSubscription = undefined;
	        this._slicePartitions = undefined;
	        this._slicePartitionsSubscription = undefined;
	        this._subdivisions = undefined;
	        this._subdivisionsSubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(EllipsoidGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof EllipsoidGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the ellipsoid.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the {@link Cartesian3} {@link Property} specifying the radii of the ellipsoid.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         */
	        radii : createPropertyDescriptor('radii'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the ellipsoid.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the boolean Property specifying whether the ellipsoid is filled with the provided material.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the ellipsoid is outlined.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the Property specifying the number of stacks.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default 64
	         */
	        stackPartitions : createPropertyDescriptor('stackPartitions'),

	        /**
	         * Gets or sets the Property specifying the number of radial slices.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default 64
	         */
	        slicePartitions : createPropertyDescriptor('slicePartitions'),

	        /**
	         * Gets or sets the Property specifying the number of samples per outline ring, determining the granularity of the curvature.
	         * @memberof EllipsoidGraphics.prototype
	         * @type {Property}
	         * @default 128
	         */
	        subdivisions : createPropertyDescriptor('subdivisions')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {EllipsoidGraphics} [result] The object onto which to store the result.
	     * @returns {EllipsoidGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    EllipsoidGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new EllipsoidGraphics(this);
	        }
	        result.show = this.show;
	        result.radii = this.radii;
	        result.material = this.material;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.stackPartitions = this.stackPartitions;
	        result.slicePartitions = this.slicePartitions;
	        result.subdivisions = this.subdivisions;

	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {EllipsoidGraphics} source The object to be merged into this object.
	     */
	    EllipsoidGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.radii = defaultValue(this.radii, source.radii);
	        this.material = defaultValue(this.material, source.material);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.stackPartitions = defaultValue(this.stackPartitions, source.stackPartitions);
	        this.slicePartitions = defaultValue(this.slicePartitions, source.slicePartitions);
	        this.subdivisions = defaultValue(this.subdivisions, source.subdivisions);
	    };

	    return EllipsoidGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(34),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(6),
	        __webpack_require__(8),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian2,
	        defaultValue,
	        defined,
	        defineProperties,
	        Event,
	        createPropertyDescriptor,
	        Property) {
	    "use strict";

	    var defaultRepeat = new Cartesian2(1, 1);

	    /**
	     * A {@link MaterialProperty} that maps to image {@link Material} uniforms.
	     * @alias ImageMaterialProperty
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.image] A Property specifying the Image, URL, or Canvas.
	     * @param {Property} [options.repeat=new Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
	     */
	    var ImageMaterialProperty = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        this._definitionChanged = new Event();
	        this._image = undefined;
	        this._imageSubscription = undefined;
	        this._repeat = undefined;
	        this._repeatSubscription = undefined;

	        this.image = options.image;
	        this.repeat = options.repeat;
	    };

	    defineProperties(ImageMaterialProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof ImageMaterialProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return Property.isConstant(this._image) && Property.isConstant(this._repeat);
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof ImageMaterialProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets or sets the Property specifying Image, URL, or Canvas.
	         * @memberof ImageMaterialProperty.prototype
	         * @type {Property}
	         */
	        image : createPropertyDescriptor('image'),
	        /**
	         * Gets or sets the {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
	         * @memberof ImageMaterialProperty.prototype
	         * @type {Property}
	         * @default new Cartesian2(1, 1)
	         */
	        repeat : createPropertyDescriptor('repeat')
	    });

	    /**
	     * Gets the {@link Material} type at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    ImageMaterialProperty.prototype.getType = function(time) {
	        return 'Image';
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    ImageMaterialProperty.prototype.getValue = function(time, result) {
	        if (!defined(result)) {
	            result = {};
	        }

	        result.image = Property.getValueOrUndefined(this._image, time);
	        result.repeat = Property.getValueOrClonedDefault(this._repeat, time, defaultRepeat, result.repeat);
	        return result;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    ImageMaterialProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof ImageMaterialProperty && //
	                Property.equals(this._image, other._image) && //
	                Property.equals(this._repeat, other._repeat));
	    };

	    return ImageMaterialProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a two dimensional label located at the position of the containing {@link Entity}.
	     * <p>
	     * <div align='center'>
	     * <img src='images/Label.png' width='400' height='300' /><br />
	     * Example labels
	     * </div>
	     * </p>
	     *
	     * @alias LabelGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.text] A Property specifying the text.
	     * @param {Property} [options.font='10px sans-serif'] A Property specifying the CSS font.
	     * @param {Property} [options.style=LabelStyle.FILL] A Property specifying the {@link LabelStyle}.
	     * @param {Property} [options.fillColor=Color.WHITE] A Property specifying the fill {@link Color}.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the outline {@link Color}.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the outline width.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the label.
	     * @param {Property} [options.scale=1.0] A numeric Property specifying the scale to apply to the text.
	     * @param {Property} [options.horizontalOrigin=HorizontalOrigin.CENTER] A Property specifying the {@link HorizontalOrigin}.
	     * @param {Property} [options.verticalOrigin=VerticalOrigin.CENTER] A Property specifying the {@link VerticalOrigin}.
	     * @param {Property} [options.eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the eye offset.
	     * @param {Property} [options.pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} Property specifying the pixel offset.
	     * @param {Property} [options.translucencyByDistance] A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
	     * @param {Property} [options.pixelOffsetScaleByDistance] A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
	     *
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}
	     */
	    var LabelGraphics = function(options) {
	        this._text = undefined;
	        this._textSubscription = undefined;
	        this._font = undefined;
	        this._fontSubscription = undefined;
	        this._style = undefined;
	        this._styleSubscription = undefined;
	        this._fillColor = undefined;
	        this._fillColorSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._horizontalOrigin = undefined;
	        this._horizontalOriginSubscription = undefined;
	        this._verticalOrigin = undefined;
	        this._verticalOriginSubscription = undefined;
	        this._eyeOffset = undefined;
	        this._eyeOffsetSubscription = undefined;
	        this._pixelOffset = undefined;
	        this._pixelOffsetSubscription = undefined;
	        this._scale = undefined;
	        this._scaleSubscription = undefined;
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._translucencyByDistance = undefined;
	        this._translucencyByDistanceSubscription = undefined;
	        this._pixelOffsetScaleByDistance = undefined;
	        this._pixelOffsetScaleByDistanceSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(LabelGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof LabelGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the string Property specifying the text of the label.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        text : createPropertyDescriptor('text'),

	        /**
	         * Gets or sets the string Property specifying the font in CSS syntax.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font|CSS font on MDN}
	         */
	        font : createPropertyDescriptor('font'),

	        /**
	         * Gets or sets the Property specifying the {@link LabelStyle}.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        style : createPropertyDescriptor('style'),

	        /**
	         * Gets or sets the Property specifying the fill {@link Color}.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        fillColor : createPropertyDescriptor('fillColor'),

	        /**
	         * Gets or sets the Property specifying the outline {@link Color}.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the outline width.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the Property specifying the {@link HorizontalOrigin}.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        horizontalOrigin : createPropertyDescriptor('horizontalOrigin'),

	        /**
	         * Gets or sets the Property specifying the {@link VerticalOrigin}.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        verticalOrigin : createPropertyDescriptor('verticalOrigin'),

	        /**
	         * Gets or sets the {@link Cartesian3} Property specifying the label's offset in eye coordinates.
	         * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
	         * right, <code>y</code> points up, and <code>z</code> points into the screen.
	         * <p>
	         * An eye offset is commonly used to arrange multiple labels or objects at the same position, e.g., to
	         * arrange a label above its corresponding 3D model.
	         * </p>
	         * Below, the label is positioned at the center of the Earth but an eye offset makes it always
	         * appear on top of the Earth regardless of the viewer's or Earth's orientation.
	         * <p>
	         * <div align='center'>
	         * <table border='0' cellpadding='5'><tr>
	         * <td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
	         * <td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
	         * </tr></table>
	         * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
	         * </div>
	         * </p>
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         * @default Cartesian3.ZERO
	         */
	        eyeOffset : createPropertyDescriptor('eyeOffset'),

	        /**
	         * Gets or sets the {@link Cartesian2} Property specifying the label's pixel offset in screen space
	         * from the origin of this label.  This is commonly used to align multiple labels and labels at
	         * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
	         * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
	         * <p>
	         * <div align='center'>
	         * <table border='0' cellpadding='5'><tr>
	         * <td align='center'><code>default</code><br/><img src='images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
	         * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
	         * </tr></table>
	         * The label's origin is indicated by the yellow point.
	         * </div>
	         * </p>
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         * @default Cartesian2.ZERO
	         */
	        pixelOffset : createPropertyDescriptor('pixelOffset'),

	        /**
	         * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
	         * A scale greater than <code>1.0</code> enlarges the label while a scale less than <code>1.0</code> shrinks it.
	         * <p>
	         * <div align='center'>
	         * <img src='images/Label.setScale.png' width='400' height='300' /><br/>
	         * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
	         * and <code>2.0</code>.
	         * </div>
	         * </p>
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        scale : createPropertyDescriptor('scale'),

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the label.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets {@link NearFarScalar} Property specifying the translucency of the label based on the distance from the camera.
	         * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
	         * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
	         * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
	         * Outside of these ranges the label's translucency remains clamped to the nearest bound.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        translucencyByDistance : createPropertyDescriptor('translucencyByDistance'),

	        /**
	         * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the label based on the distance from the camera.
	         * A label's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
	         * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
	         * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
	         * Outside of these ranges the label's pixel offset remains clamped to the nearest bound.
	         * @memberof LabelGraphics.prototype
	         * @type {Property}
	         */
	        pixelOffsetScaleByDistance : createPropertyDescriptor('pixelOffsetScaleByDistance')

	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {LabelGraphics} [result] The object onto which to store the result.
	     * @returns {LabelGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    LabelGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new LabelGraphics(this);
	        }
	        result.text = this.text;
	        result.font = this.font;
	        result.show = this.show;
	        result.style = this.style;
	        result.fillColor = this.fillColor;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.scale = this.scale;
	        result.horizontalOrigin = this.horizontalOrigin;
	        result.verticalOrigin = this.verticalOrigin;
	        result.eyeOffset = this.eyeOffset;
	        result.pixelOffset = this.pixelOffset;
	        result.translucencyByDistance = this.translucencyByDistance;
	        result.pixelOffsetScaleByDistance = this.pixelOffsetScaleByDistance;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {LabelGraphics} source The object to be merged into this object.
	     */
	    LabelGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.text = defaultValue(this.text, source.text);
	        this.font = defaultValue(this.font, source.font);
	        this.show = defaultValue(this.show, source.show);
	        this.style = defaultValue(this.style, source.style);
	        this.fillColor = defaultValue(this.fillColor, source.fillColor);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.scale = defaultValue(this.scale, source.scale);
	        this.horizontalOrigin = defaultValue(this.horizontalOrigin, source.horizontalOrigin);
	        this.verticalOrigin = defaultValue(this.verticalOrigin, source.verticalOrigin);
	        this.eyeOffset = defaultValue(this.eyeOffset, source.eyeOffset);
	        this.pixelOffset = defaultValue(this.pixelOffset, source.pixelOffset);
	        this.translucencyByDistance = defaultValue(this._translucencyByDistance, source.translucencyByDistance);
	        this.pixelOffsetScaleByDistance = defaultValue(this._pixelOffsetScaleByDistance, source.pixelOffsetScaleByDistance);
	    };

	    return LabelGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * A 3D model based on {@link https://github.com/KhronosGroup/glTF|glTF}, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
	     * The position and orientation of the model is determined by the containing {@link Entity}.
	     * <p>
	     * Cesium includes support for glTF geometry, materials, animations, and skinning.
	     * Cameras and lights are not currently supported.
	     * </p>
	     *
	     * @alias ModelGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.uri] A string Property specifying the URI of the glTF asset.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the model.
	     * @param {Property} [options.scale=1.0] A numeric Property specifying a uniform linear scale.
	     * @param {Property} [options.minimumPixelSize=0.0] A numeric Property specifying the approximate minimum pixel size of the model regardless of zoom.
	     *
	     * @see {@link http://cesiumjs.org/2014/03/03/Cesium-3D-Models-Tutorial/|3D Models Tutorial}
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=3D%20Models.html|Cesium Sandcastle 3D Models Demo}
	     */
	    var ModelGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._scale = undefined;
	        this._scaleSubscription = undefined;
	        this._minimumPixelSize = undefined;
	        this._minimumPixelSizeSubscription = undefined;
	        this._uri = undefined;
	        this._uriSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(ModelGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof ModelGraphics.prototype
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the model.
	         * @memberof ModelGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the numeric Property specifying a uniform linear scale
	         * for this model. Values greater than 1.0 increase the size of the model while
	         * values less than 1.0 decrease it.
	         * @memberof ModelGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        scale : createPropertyDescriptor('scale'),

	        /**
	         * Gets or sets the numeric Property specifying the approximate minimum
	         * pixel size of the model regardless of zoom. This can be used to ensure that
	         * a model is visible even when the viewer zooms out.  When <code>0.0</code>,
	         * no minimum size is enforced.
	         * @memberof ModelGraphics.prototype
	         * @type {Property}
	         * @default 0.0
	         */
	        minimumPixelSize : createPropertyDescriptor('minimumPixelSize'),

	        /**
	         * Gets or sets the string Property specifying the URI of the glTF asset.
	         * @memberof ModelGraphics.prototype
	         * @type {Property}
	         */
	        uri : createPropertyDescriptor('uri')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {ModelGraphics} [result] The object onto which to store the result.
	     * @returns {ModelGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    ModelGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new ModelGraphics(this);
	        }
	        result.show = this.show;
	        result.scale = this.scale;
	        result.minimumPixelSize = this.minimumPixelSize;
	        result.uri = this.uri;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {ModelGraphics} source The object to be merged into this object.
	     */
	    ModelGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.scale = defaultValue(this.scale, source.scale);
	        this.minimumPixelSize = defaultValue(this.minimumPixelSize, source.minimumPixelSize);
	        this.uri = defaultValue(this.uri, source.uri);
	    };

	    return ModelGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a polyline defined as the path made by an {@link Entity} as it moves over time.
	     *
	     * @alias PathGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.leadTime] A Property specifying the number of seconds behind the object to show.
	     * @param {Property} [options.trailTime] A Property specifying the number of seconds in front of the object to show.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the path.
	     * @param {Property} [options.width=1.0] A numeric Property specifying the width in pixels.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to draw the path.
	     * @param {Property} [options.resolution=60] A numeric Property specifying the width in pixels.
	     */
	    var PathGraphics = function(options) {
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._width = undefined;
	        this._widthSubscription = undefined;
	        this._resolution = undefined;
	        this._resolutionSubscription = undefined;
	        this._leadTime = undefined;
	        this._leadTimeSubscription = undefined;
	        this._trailTime = undefined;
	        this._trailTimeSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(PathGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof PathGraphics.prototype
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the path.
	         * @memberof PathGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to draw the path.
	         * @memberof PathGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the numeric Property specifying the width in pixels.
	         * @memberof PathGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        width : createPropertyDescriptor('width'),

	        /**
	         * Gets or sets the Property specifying the maximum number of seconds to step when sampling the position.
	         * @memberof PathGraphics.prototype
	         * @type {Property}
	         * @default 60
	         */
	        resolution : createPropertyDescriptor('resolution'),

	        /**
	         * Gets or sets the Property specifying the number of seconds in front of the object to show.
	         * @memberof PathGraphics.prototype
	         * @type {Property}
	         */
	        leadTime : createPropertyDescriptor('leadTime'),

	        /**
	         * Gets or sets the Property specifying the number of seconds behind the object to show.
	         * @memberof PathGraphics.prototype
	         * @type {Property}
	         */
	        trailTime : createPropertyDescriptor('trailTime')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {PathGraphics} [result] The object onto which to store the result.
	     * @returns {PathGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    PathGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new PathGraphics(this);
	        }
	        result.material = this.material;
	        result.width = this.width;
	        result.resolution = this.resolution;
	        result.show = this.show;
	        result.leadTime = this.leadTime;
	        result.trailTime = this.trailTime;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {PathGraphics} source The object to be merged into this object.
	     */
	    PathGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.material = defaultValue(this.material, source.material);
	        this.width = defaultValue(this.width, source.width);
	        this.resolution = defaultValue(this.resolution, source.resolution);
	        this.show = defaultValue(this.show, source.show);
	        this.leadTime = defaultValue(this.leadTime, source.leadTime);
	        this.trailTime = defaultValue(this.trailTime, source.trailTime);
	    };

	    return PathGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a graphical point located at the position of the containing {@link Entity}.
	     *
	     * @alias PointGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the point.
	     * @param {Property} [options.pixelSize=1] A numeric Property specifying the size in pixels.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=0] A numeric Property specifying the the outline width in pixels.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the point.
	     * @param {Property} [options.scaleByDistance] A {@link NearFarScalar} Property used to scale the point based on distance.
	     */
	    var PointGraphics = function(options) {
	        this._color = undefined;
	        this._colorSubscription = undefined;
	        this._pixelSize = undefined;
	        this._pixelSizeSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._scaleByDistance = undefined;
	        this._scaleByDistanceSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(PointGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof PointGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the point.
	         * @memberof PointGraphics.prototype
	         * @type {Property}
	         * @default Color.WHITE
	         */
	        color : createPropertyDescriptor('color'),

	        /**
	         * Gets or sets the numeric Property specifying the size in pixels.
	         * @memberof PointGraphics.prototype
	         * @type {Property}
	         * @default 1
	         */
	        pixelSize : createPropertyDescriptor('pixelSize'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof PointGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the the outline width in pixels.
	         * @memberof PointGraphics.prototype
	         * @type {Property}
	         * @default 0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the point.
	         * @memberof PointGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the {@link NearFarScalar} Property used to scale the point based on distance.
	         * If undefined, a constant size is used.
	         * @memberof PointGraphics.prototype
	         * @type {Property}
	         */
	        scaleByDistance : createPropertyDescriptor('scaleByDistance')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {PointGraphics} [result] The object onto which to store the result.
	     * @returns {PointGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    PointGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new PointGraphics(this);
	        }
	        result.color = this.color;
	        result.pixelSize = this.pixelSize;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.show = this.show;
	        result.scaleByDistance = this.scaleByDistance;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {PointGraphics} source The object to be merged into this object.
	     */
	    PointGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.color = defaultValue(this.color, source.color);
	        this.pixelSize = defaultValue(this.pixelSize, source.pixelSize);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.show = defaultValue(this.show, source.show);
	        this.scaleByDistance = defaultValue(this.scaleByDistance, source.scaleByDistance);
	    };

	    return PointGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(37),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        deprecationWarning,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a polygon defined by an hierarchy of linear rings which make up the outer shape and any nested holes.
	     * The polygon conforms to the curvature of the globe and can be placed on the surface or
	     * at altitude and can optionally be extruded into a volume.
	     *
	     * @alias PolygonGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.hierarchy] A Property specifying the {@link PolygonHierarchy}.
	     * @param {Property} [options.height=0] A numeric Property specifying the altitude of the polygon.
	     * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the polygon extrusion.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the polygon.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the polygon is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the polygon.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the polygon is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.stRotation=0.0] A numeric property specifying the rotation of the polygon texture counter-clockwise from north.
	     * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude point.
	     * @param {Property} [options.perPositionHeight=false] A boolean specifying whether or not the the height of each position is used.
	     *
	     * @see Entity
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}
	     */
	    var PolygonGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._hierarchy = undefined;
	        this._hierarchySubscription = undefined;
	        this._height = undefined;
	        this._heightSubscription = undefined;
	        this._extrudedHeight = undefined;
	        this._extrudedHeightSubscription = undefined;
	        this._granularity = undefined;
	        this._granularitySubscription = undefined;
	        this._stRotation = undefined;
	        this._stRotationSubscription = undefined;
	        this._perPositionHeight = undefined;
	        this._perPositionHeightSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();
	        this._fill = undefined;
	        this._fillSubscription = undefined;

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(PolygonGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof PolygonGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the polygon.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the polygon.
	         * @memberof PolygonGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the positions that define the polygon.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @deprecated
	         */
	        positions : {
	            get : function() {
	                deprecationWarning('PolygonGraphics.positions', 'PolygonGraphics.positions was deprecated in Cesium 1.6, use PolygonGraphics.hierarchy instead. This property will be removed in Cesium 1.9.');
	                return this.hierarchy;
	            },
	            set : function(value) {
	                deprecationWarning('PolygonGraphics.positions', 'PolygonGraphics.positions was deprecated in Cesium 1.6, use PolygonGraphics.hierarchy instead. This property will be removed in Cesium 1.9.');
	                this.hierarchy = value;
	            }
	        },

	        /**
	         * Gets or sets the Property specifying the {@link PolygonHierarchy}.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         */
	        hierarchy : createPropertyDescriptor('hierarchy'),

	        /**
	         * Gets or sets the numeric Property specifying the constant altitude of the polygon.
	         * This property is ignored when {@link PolygonGraphics#perPositionHeight} is true.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default 0.0
	         */
	        height : createPropertyDescriptor('height'),

	        /**
	         * Gets or sets the numeric Property specifying the altitude of the polygon extrusion.
	         * If {@link PolygonGraphics#perPositionHeight} is false, the volume starts at {@link PolygonGraphics#height} and ends at this altitude.
	         * If {@link PolygonGraphics#perPositionHeight} is true, the volume starts at the height of each {@link PolygonGraphics#hierarchy} position and ends at this altitude.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         */
	        extrudedHeight : createPropertyDescriptor('extrudedHeight'),

	        /**
	         * Gets or sets the numeric Property specifying the angular distance between points on the polygon.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default {CesiumMath.RADIANS_PER_DEGREE}
	         */
	        granularity : createPropertyDescriptor('granularity'),

	        /**
	         * Gets or sets the numeric property specifying the rotation of the polygon texture counter-clockwise from north.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default 0
	         */
	        stRotation : createPropertyDescriptor('stRotation'),

	        /**
	         * Gets or sets the boolean Property specifying whether the polygon is filled with the provided material.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the polygon is outlined.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the boolean specifying whether or not the the height of each position is used.
	         * If true, the shape will have non-uniform altitude defined by the height of each {@link PolygonGraphics#hierarchy} position.
	         * If false, the shape will have a constant altitude as specified by {@link PolygonGraphics#height}.
	         * @memberof PolygonGraphics.prototype
	         * @type {Property}
	         */
	        perPositionHeight : createPropertyDescriptor('perPositionHeight')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {PolygonGraphics} [result] The object onto which to store the result.
	     * @returns {PolygonGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    PolygonGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new PolygonGraphics(this);
	        }
	        result.show = this.show;
	        result.material = this.material;
	        result.hierarchy = this.hierarchy;
	        result.height = this.height;
	        result.extrudedHeight = this.extrudedHeight;
	        result.granularity = this.granularity;
	        result.stRotation = this.stRotation;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.perPositionHeight = this.perPositionHeight;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {PolygonGraphics} source The object to be merged into this object.
	     */
	    PolygonGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.hierarchy = defaultValue(this.hierarchy, source.hierarchy);
	        this.height = defaultValue(this.height, source.height);
	        this.extrudedHeight = defaultValue(this.extrudedHeight, source.extrudedHeight);
	        this.granularity = defaultValue(this.granularity, source.granularity);
	        this.stRotation = defaultValue(this.stRotation, source.stRotation);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.perPositionHeight = defaultValue(this.perPositionHeight, source.perPositionHeight);
	    };

	    return PolygonGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a polyline defined as a line strip. The first two positions define a line segment,
	     * and each additional position defines a line segment from the previous position. The segments
	     * can be linear connected points or great arcs.
	     *
	     * @alias PolylineGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions that define the line strip.
	     * @param {Property} [options.followSurface=true] A boolean Property specifying whether the line segments should be great arcs or linearly connected.
	     * @param {Property} [options.width=1.0] A numeric Property specifying the width in pixels.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the polyline.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to draw the polyline.
	     * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude if followSurface is true.
	     *
	     * @see Entity
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}
	     */
	    var PolylineGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._positions = undefined;
	        this._positionsSubscription = undefined;
	        this._followSurface = undefined;
	        this._followSurfaceSubscription = undefined;
	        this._granularity = undefined;
	        this._granularitySubscription = undefined;
	        this._widthSubscription = undefined;
	        this._width = undefined;
	        this._widthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(PolylineGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof PolylineGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the polyline.
	         * @memberof PolylineGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to draw the polyline.
	         * @memberof PolylineGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the Property specifying the array of {@link Cartesian3}
	         * positions that define the line strip.
	         * @memberof PolylineGraphics.prototype
	         * @type {Property}
	         */
	        positions : createPropertyDescriptor('positions'),

	        /**
	         * Gets or sets the numeric Property specifying the width in pixels.
	         * @memberof PolylineGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        width : createPropertyDescriptor('width'),

	        /**
	         * Gets or sets the boolean Property specifying whether the line segments
	         * should be great arcs or linearly connected.
	         * @memberof PolylineGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        followSurface : createPropertyDescriptor('followSurface'),

	        /**
	         * Gets or sets the numeric Property specifying the angular distance between each latitude and longitude if followSurface is true.
	         * @memberof PolylineGraphics.prototype
	         * @type {Property}
	         * @default Cesium.Math.RADIANS_PER_DEGREE
	         */
	        granularity : createPropertyDescriptor('granularity')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {PolylineGraphics} [result] The object onto which to store the result.
	     * @returns {PolylineGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    PolylineGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new PolylineGraphics(this);
	        }
	        result.show = this.show;
	        result.material = this.material;
	        result.positions = this.positions;
	        result.width = this.width;
	        result.followSurface = this.followSurface;
	        result.granularity = this.granularity;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {PolylineGraphics} source The object to be merged into this object.
	     */
	    PolylineGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.positions = defaultValue(this.positions, source.positions);
	        this.width = defaultValue(this.width, source.width);
	        this.followSurface = defaultValue(this.followSurface, source.followSurface);
	        this.granularity = defaultValue(this.granularity, source.granularity);
	    };

	    return PolylineGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes graphics for a {@link Rectangle}.
	     * The rectangle conforms to the curvature of the globe and can be placed on the surface or
	     * at altitude and can optionally be extruded into a volume.
	     *
	     * @alias RectangleGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.coordinates] The Property specifying the {@link Rectangle}.
	     * @param {Property} [options.height=0] A numeric Property specifying the altitude of the rectangle.
	     * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the rectangle extrusion.
	     * @param {Property} [options.closeTop=true] A boolean Property specifying whether the rectangle has a top cover when extruded
	     * @param {Property} [options.closeBottom=true] A boolean Property specifying whether the rectangle has a bottom cover when extruded.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the rectangle.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the rectangle is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the rectangle.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the rectangle is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.rotation=0.0] A numeric property specifying the rotation of the rectangle clockwise from north.
	     * @param {Property} [options.stRotation=0.0] A numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
	     * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between points on the rectangle.
	     *
	     * @see Entity
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}
	     */
	    var RectangleGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._coordinates = undefined;
	        this._coordinatesSubscription = undefined;
	        this._height = undefined;
	        this._heightSubscription = undefined;
	        this._extrudedHeight = undefined;
	        this._extrudedHeightSubscription = undefined;
	        this._granularity = undefined;
	        this._granularitySubscription = undefined;
	        this._stRotation = undefined;
	        this._stRotationSubscription = undefined;
	        this._rotation = undefined;
	        this._rotationSubscription = undefined;
	        this._closeTop = undefined;
	        this._closeTopSubscription = undefined;
	        this._closeBottom = undefined;
	        this._closeBottomSubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(RectangleGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof RectangleGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the rectangle.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the {@link Rectangle}.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         */
	        coordinates : createPropertyDescriptor('coordinates'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the rectangle.
	         * @memberof RectangleGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the numeric Property specifying the altitude of the rectangle.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default 0.0
	         */
	        height : createPropertyDescriptor('height'),

	        /**
	         * Gets or sets the numeric Property specifying the altitude of the rectangle extrusion.
	         * Setting this property creates volume starting at height and ending at this altitude.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         */
	        extrudedHeight : createPropertyDescriptor('extrudedHeight'),

	        /**
	         * Gets or sets the numeric Property specifying the angular distance between points on the rectangle.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default {CesiumMath.RADIANS_PER_DEGREE}
	         */
	        granularity : createPropertyDescriptor('granularity'),

	        /**
	         * Gets or sets the numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default 0
	         */
	        stRotation : createPropertyDescriptor('stRotation'),

	        /**
	         * Gets or sets the numeric property specifying the rotation of the rectangle clockwise from north.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default 0
	         */
	        rotation : createPropertyDescriptor('rotation'),

	        /**
	         * Gets or sets the boolean Property specifying whether the rectangle is filled with the provided material.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the rectangle is outlined.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the boolean Property specifying whether the rectangle has a top cover when extruded.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        closeTop : createPropertyDescriptor('closeTop'),

	        /**
	         * Gets or sets the boolean Property specifying whether the rectangle has a bottom cover when extruded.
	         * @memberof RectangleGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        closeBottom : createPropertyDescriptor('closeBottom')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {RectangleGraphics} [result] The object onto which to store the result.
	     * @returns {RectangleGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    RectangleGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new RectangleGraphics(this);
	        }
	        result.show = this.show;
	        result.coordinates = this.coordinates;
	        result.material = this.material;
	        result.height = this.height;
	        result.extrudedHeight = this.extrudedHeight;
	        result.granularity = this.granularity;
	        result.stRotation = this.stRotation;
	        result.rotation = this.rotation;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.closeTop = this.closeTop;
	        result.closeBottom = this.closeBottom;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {RectangleGraphics} source The object to be merged into this object.
	     */
	    RectangleGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.coordinates = defaultValue(this.coordinates, source.coordinates);
	        this.material = defaultValue(this.material, source.material);
	        this.height = defaultValue(this.height, source.height);
	        this.extrudedHeight = defaultValue(this.extrudedHeight, source.extrudedHeight);
	        this.granularity = defaultValue(this.granularity, source.granularity);
	        this.stRotation = defaultValue(this.stRotation, source.stRotation);
	        this.rotation = defaultValue(this.rotation, source.rotation);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.closeTop = defaultValue(this.closeTop, source.closeTop);
	        this.closeBottom = defaultValue(this.closeBottom, source.closeBottom);
	    };

	    return RectangleGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        Property) {
	    "use strict";

	    function resolve(that) {
	        var targetEntity = that._targetEntity;

	        if (that._resolveEntity) {
	            targetEntity = that._targetCollection.getById(that._targetId);

	            if (defined(targetEntity)) {
	                that._targetEntity = targetEntity;
	                that._resolveEntity = false;
	            } else {
	                entityIsResolved = false;
	            }
	        }
	        return targetEntity;
	    }

	    /**
	     * References an {@link Entity} in an {@link EntityCollection}.
	     *
	     * @alias ReferenceEntity
	     * @constructor
	     *
	     * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.
	     * @param {String} targetId The id of the entity which is being referenced.
	     *
	     */
	    var ReferenceEntity = function(targetCollection, targetId) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(targetCollection)) {
	            throw new DeveloperError('targetCollection is required.');
	        }
	        if (!defined(targetId) || targetId === '') {
	            throw new DeveloperError('targetId is required.');
	        }
	        //>>includeEnd('debug');

	        this._targetCollection = targetCollection;
	        this._targetId = targetId;
	        this._targetEntity = undefined;
	        this._definitionChanged = new Event();
	        this._resolveEntity = true;

	        targetCollection.collectionChanged.addEventListener(ReferenceEntity.prototype._onCollectionChanged, this);
	    };

	    defineProperties(ReferenceEntity.prototype, {
	        /**
	         * Gets the event that is raised whenever the definition of this entity changes.
	         * The definition is changed whenever the referenced property's definition is changed.
	         * @memberof ReferenceEntity.prototype
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the id of the entity being referenced.
	         * @memberof ReferenceEntity.prototype
	         * @type {String}
	         * @readonly
	         */
	        id : {
	            get : function() {
	                return this._targetId;
	            }
	        },
	        /**
	         * Gets the position property of the entity being referenced.
	         * @memberof ReferenceProperty.prototype
	         * @type {ReferenceFrame}
	         * @readonly
	         */
	        position : {
	            get : function() {
	                var entity = resolve(this);
	                return defined(entity) ? entity.position : undefined;
	            }
	        },
	        /**
	         * Gets the orientation property of the entity being referenced.
	         * @memberof ReferenceProperty.prototype
	         * @type {ReferenceFrame}
	         * @readonly
	         */
	        orientation : {
	            get : function() {
	                var entity = resolve(this);
	                return defined(entity) ? entity.orientation : undefined;
	            }
	        },
	        /**
	         * Gets the id of the entity being referenced.
	         * @memberof ReferenceEntity.prototype
	         * @type {String}
	         * @readonly
	         */
	        targetId : {
	            get : function() {
	                return this._targetId;
	            }
	        },
	        /**
	         * Gets the collection containing the entity being referenced.
	         * @memberof ReferenceEntity.prototype
	         * @type {EntityCollection}
	         * @readonly
	         */
	        targetCollection : {
	            get : function() {
	                return this._targetCollection;
	            }
	        },
	        /**
	         * Gets the resolved instance of the underlying referenced entity.
	         * @memberof ReferenceEntity.prototype
	         * @type {Property}
	         * @readonly
	         */
	         resolvedEntity : {
	            get : function() {
	               return resolve(this);
	            }
	         }
	    });

	    ReferenceEntity.prototype._onCollectionChanged = function(collection, added, removed) {
	        var targetEntity = this._targetEntity;
	        if (defined(targetEntity)) {
	            if (removed.indexOf(targetEntity) !== -1) {
	                this._resolveEntity = true;
	            } else if (this._resolveEntity) {
	                //If targetEntity is defined but resolveEntity is true, then the entity is detached
	                //and any change to the collection needs to incur an attempt to resolve in order to re-attach.
	                //without this if block, a reference that becomes re-attached will not signal definitionChanged
	                resolve(this);
	                if (!this._resolveEntity) {
	                    this._definitionChanged.raiseEvent(this);
	                }
	            }
	        }
	    };

	    return ReferenceEntity;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(36),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        RuntimeError,
	        Property) {
	    "use strict";

	    function resolveEntity(that) {
	        var entityIsResolved = true;
	        if (that._resolveEntity) {
	            var targetEntity = that._targetCollection.getById(that._targetId);

	            if (defined(targetEntity)) {
	                targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);
	                that._targetEntity = targetEntity;
	                that._resolveEntity = false;
	            } else {
	                //The property has become detached.  It has a valid value but is not currently resolved to an entity in the collection
	                targetEntity = that._targetEntity;
	                entityIsResolved = false;
	            }

	            if (!defined(targetEntity)) {
	                throw new RuntimeError('target entity "' + that._targetId + '" could not be resolved.');
	            }
	        }
	        return entityIsResolved;
	    }

	    function resolve(that) {
	        var targetProperty = that._targetProperty;

	        if (that._resolveProperty) {
	            var entityIsResolved = resolveEntity(that);

	            var names = that._targetPropertyNames;
	            targetProperty = that._targetEntity;
	            var length = names.length;
	            for (var i = 0; i < length && defined(targetProperty); i++) {
	                targetProperty = targetProperty[names[i]];
	            }

	            if (defined(targetProperty)) {
	                that._targetProperty = targetProperty;
	                that._resolveProperty = !entityIsResolved;
	            } else if (!defined(that._targetProperty)) {
	                throw new RuntimeError('targetProperty "' + that._targetId + '.' + names.join('.') + '" could not be resolved.');
	            }
	        }

	        return targetProperty;
	    }

	    /**
	     * A {@link Property} which transparently links to another property on a provided object.
	     *
	     * @alias ReferenceProperty
	     * @constructor
	     *
	     * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.
	     * @param {String} targetId The id of the entity which is being referenced.
	     * @param {String} targetPropertyNames The name of the property on the target entity which we will use.
	     *
	     * @example
	     * var collection = new Cesium.EntityCollection();
	     *
	     * //Create a new entity and assign a billboard scale.
	     * var object1 = new Cesium.Entity({id:'object1'});
	     * object1.billboard = new Cesium.BillboardGraphics();
	     * object1.billboard.scale = new Cesium.ConstantProperty(2.0);
	     * collection.add(object1);
	     *
	     * //Create a second entity and reference the scale from the first one.
	     * var object2 = new Cesium.Entity({id:'object2'});
	     * object2.model = new Cesium.ModelGraphics();
	     * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);
	     * collection.add(object2);
	     *
	     * //Create a third object, but use the fromString helper function.
	     * var object3 = new Cesium.Entity({id:'object3'});
	     * object3.billboard = new Cesium.BillboardGraphics();
	     * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');
	     * collection.add(object3);
	     *
	     * //You can refer to an entity with a # or . in id and property names by escaping them.
	     * var object4 = new Cesium.Entity({id:'#object.4'});
	     * object4.billboard = new Cesium.BillboardGraphics();
	     * object4.billboard.scale = new Cesium.ConstantProperty(2.0);
	     * collection.add(object4);
	     *
	     * var object5 = new Cesium.Entity({id:'object5'});
	     * object5.billboard = new Cesium.BillboardGraphics();
	     * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\#object\\.4#billboard.scale');
	     * collection.add(object5);
	     */
	    var ReferenceProperty = function(targetCollection, targetId, targetPropertyNames) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(targetCollection)) {
	            throw new DeveloperError('targetCollection is required.');
	        }
	        if (!defined(targetId) || targetId === '') {
	            throw new DeveloperError('targetId is required.');
	        }
	        if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {
	            throw new DeveloperError('targetPropertyNames is required.');
	        }
	        for (var i = 0; i < targetPropertyNames.length; i++) {
	            var item = targetPropertyNames[i];
	            if (!defined(item) || item === '') {
	                throw new DeveloperError('reference contains invalid properties.');
	            }
	        }
	        //>>includeEnd('debug');

	        this._targetCollection = targetCollection;
	        this._targetId = targetId;
	        this._targetPropertyNames = targetPropertyNames;
	        this._targetProperty = undefined;
	        this._targetEntity = undefined;
	        this._definitionChanged = new Event();
	        this._resolveEntity = true;
	        this._resolveProperty = true;

	        targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);
	    };

	    defineProperties(ReferenceProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.
	         * @memberof ReferenceProperty.prototype
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return Property.isConstant(resolve(this));
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever the referenced property's definition is changed.
	         * @memberof ReferenceProperty.prototype
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the reference frame that the position is defined in.
	         * This property is only valid if the referenced property is a {@link PositionProperty}.
	         * @memberof ReferenceProperty.prototype
	         * @type {ReferenceFrame}
	         * @readonly
	         */
	        referenceFrame : {
	            get : function() {
	                return resolve(this).referenceFrame;
	            }
	        },
	        /**
	         * Gets the id of the entity being referenced.
	         * @memberof ReferenceProperty.prototype
	         * @type {String}
	         * @readonly
	         */
	        targetId : {
	            get : function() {
	                return this._targetId;
	            }
	        },
	        /**
	         * Gets the collection containing the entity being referenced.
	         * @memberof ReferenceProperty.prototype
	         * @type {EntityCollection}
	         * @readonly
	         */
	        targetCollection : {
	            get : function() {
	                return this._targetCollection;
	            }
	        },
	        /**
	         * Gets the array of property names used to retrieve the referenced property.
	         * @memberof ReferenceProperty.prototype
	         * @type {String[]}
	         * @readonly
	         */
	        targetPropertyNames : {
	            get : function() {
	                return this._targetPropertyNames;
	            }
	        },
	        /**
	         * Gets the resolved instance of the underlying referenced property.
	         * @memberof ReferenceProperty.prototype
	         * @type {Property}
	         * @readonly
	         */
	        resolvedProperty : {
	            get : function() {
	                return resolve(this);
	            }
	        }
	    });

	    /**
	     * Creates a new instance given the entity collection that will
	     * be used to resolve it and a string indicating the target entity id and property.
	     * The format of the string is "objectId#foo.bar", where # separates the id from
	     * property path and . separates sub-properties.  If the reference identifier or
	     * or any sub-properties contains a # . or \ they must be escaped.
	     *
	     * @param {Entity} targetCollection
	     * @param {String} referenceString
	     * @returns A new instance of ReferenceProperty.
	     *
	     * @exception {DeveloperError} invalid referenceString.
	     */
	    ReferenceProperty.fromString = function(targetCollection, referenceString) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(targetCollection)) {
	            throw new DeveloperError('targetCollection is required.');
	        }
	        if (!defined(referenceString)) {
	            throw new DeveloperError('referenceString is required.');
	        }
	        //>>includeEnd('debug');

	        var identifier;
	        var values = [];

	        var inIdentifier = true;
	        var isEscaped = false;
	        var token = '';
	        for (var i = 0; i < referenceString.length; ++i) {
	            var c = referenceString.charAt(i);

	            if (isEscaped) {
	                token += c;
	                isEscaped = false;
	            } else if (c === '\\') {
	                isEscaped = true;
	            } else if (inIdentifier && c === '#') {
	                identifier = token;
	                inIdentifier = false;
	                token = '';
	            } else if (!inIdentifier && c === '.') {
	                values.push(token);
	                token = '';
	            } else {
	                token += c;
	            }
	        }
	        values.push(token);

	        return new ReferenceProperty(targetCollection, identifier, values);
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    ReferenceProperty.prototype.getValue = function(time, result) {
	        return resolve(this).getValue(time, result);
	    };

	    /**
	     * Gets the value of the property at the provided time and in the provided reference frame.
	     * This method is only valid if the property being referenced is a {@link PositionProperty}.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	        return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);
	    };

	    /**
	     * Gets the {@link Material} type at the provided time.
	     * This method is only valid if the property being referenced is a {@link MaterialProperty}.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    ReferenceProperty.prototype.getType = function(time) {
	        return resolve(this).getType(time);
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    ReferenceProperty.prototype.equals = function(other) {
	        if (this === other) {
	            return true;
	        }

	        var names = this._targetPropertyNames;
	        var otherNames = other._targetPropertyNames;

	        if (this._targetCollection !== other._targetCollection || //
	            this._targetId !== other._targetId || //
	            names.length !== otherNames.length) {
	            return false;
	        }

	        var length = this._targetPropertyNames.length;
	        for (var i = 0; i < length; i++) {
	            if (names[i] !== otherNames[i]) {
	                return false;
	            }
	        }

	        return true;
	    };

	    ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {
	        if (this._targetPropertyNames[0] === name) {
	            this._resolveProperty = true;
	            this._definitionChanged.raiseEvent(this);
	        }
	    };

	    ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {
	        var targetEntity = this._targetEntity;
	        if (defined(targetEntity)) {
	            if (removed.indexOf(targetEntity) !== -1) {
	                targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);
	                this._resolveEntity = true;
	                this._resolveProperty = true;
	            } else if (this._resolveEntity) {
	                //If targetEntity is defined but resolveEntity is true, then the entity is detached
	                //and any change to the collection needs to incur an attempt to resolve in order to re-attach.
	                //without this if block, a reference that becomes re-attached will not signal definitionChanged
	                resolve(this);
	                if (!this._resolveEntity) {
	                    this._definitionChanged.raiseEvent(this);
	                }
	            }
	        }
	    };

	    return ReferenceProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(21),
	        __webpack_require__(57),
	        __webpack_require__(10),
	        __webpack_require__(84)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        ReferenceFrame,
	        PositionProperty,
	        Property,
	        SampledProperty) {
	    "use strict";

	    /**
	     * A {@link SampledProperty} which is also a {@link PositionProperty}.
	     *
	     * @alias SampledPositionProperty
	     * @constructor
	     *
	     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	     * @param {Number} [numberOfDerivatives=0] The number of derivatives that accompany each position; i.e. velocity, acceleration, etc...
	     */
	    var SampledPositionProperty = function(referenceFrame, numberOfDerivatives) {
	        numberOfDerivatives = defaultValue(numberOfDerivatives, 0);

	        var derivativeTypes;
	        if (numberOfDerivatives > 0) {
	            derivativeTypes = new Array(numberOfDerivatives);
	            for (var i = 0; i < numberOfDerivatives; i++) {
	                derivativeTypes[i] = Cartesian3;
	            }
	        }

	        this._numberOfDerivatives = numberOfDerivatives;
	        this._property = new SampledProperty(Cartesian3, derivativeTypes);
	        this._definitionChanged = new Event();
	        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);

	        this._property._definitionChanged.addEventListener(function() {
	            this._definitionChanged.raiseEvent(this);
	        }, this);
	    };

	    defineProperties(SampledPositionProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof SampledPositionProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._property.isConstant;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof SampledPositionProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the reference frame in which the position is defined.
	         * @memberof SampledPositionProperty.prototype
	         * @type {ReferenceFrame}
	         * @default ReferenceFrame.FIXED;
	         */
	        referenceFrame : {
	            get : function() {
	                return this._referenceFrame;
	            }
	        },
	        /**
	         * Gets the degree of interpolation to perform when retrieving a value.
	         * @memberof SampledPositionProperty.prototype
	         *
	         * @type {Number}
	         * @default 1
	         */
	        interpolationDegree : {
	            get : function() {
	                return this._property.interpolationDegree;
	            }
	        },
	        /**
	         * Gets the interpolation algorithm to use when retrieving a value.
	         * @memberof SampledPositionProperty.prototype
	         *
	         * @type {InterpolationAlgorithm}
	         * @default LinearApproximation
	         */
	        interpolationAlgorithm : {
	            get : function() {
	                return this._property.interpolationAlgorithm;
	            }
	        },
	        /**
	         * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.
	         * @memberof SampledPositionProperty.prototype
	         *
	         * @type {Boolean}
	         * @default false
	         */
	        numberOfDerivatives : {
	            get : function() {
	                return this._numberOfDerivatives;
	            }
	        },
	        /**
	         * Gets or sets the type of extrapolation to perform when a value
	         * is requested at a time after any available samples.
	         * @memberof SampledPositionProperty.prototype
	         * @type {ExtrapolationType}
	         * @default ExtrapolationType.NONE
	         */
	        forwardExtrapolationType : {
	            get : function() {
	                return this._property.forwardExtrapolationType;
	            },
	            set : function(value) {
	                this._property.forwardExtrapolationType = value;
	            }
	        },
	        /**
	         * Gets or sets the amount of time to extrapolate forward before
	         * the property becomes undefined.  A value of 0 will extrapolate forever.
	         * @memberof SampledPositionProperty.prototype
	         * @type {Number}
	         * @default 0
	         */
	        forwardExtrapolationDuration : {
	            get : function() {
	                return this._property.forwardExtrapolationDuration;
	            },
	            set : function(value) {
	                this._property.forwardExtrapolationDuration = value;
	            }
	        },
	        /**
	         * Gets or sets the type of extrapolation to perform when a value
	         * is requested at a time before any available samples.
	         * @memberof SampledPositionProperty.prototype
	         * @type {ExtrapolationType}
	         * @default ExtrapolationType.NONE
	         */
	        backwardExtrapolationType : {
	            get : function() {
	                return this._property.backwardExtrapolationType;
	            },
	            set : function(value) {
	                this._property.backwardExtrapolationType = value;
	            }
	        },
	        /**
	         * Gets or sets the amount of time to extrapolate backward
	         * before the property becomes undefined.  A value of 0 will extrapolate forever.
	         * @memberof SampledPositionProperty.prototype
	         * @type {Number}
	         * @default 0
	         */
	        backwardExtrapolationDuration : {
	            get : function() {
	                return this._property.backwardExtrapolationDuration;
	            },
	            set : function(value) {
	                this._property.backwardExtrapolationDuration = value;
	            }
	        }
	    });

	    /**
	     * Gets the position at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    SampledPositionProperty.prototype.getValue = function(time, result) {
	        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
	    };

	    /**
	     * Gets the position at the provided time and in the provided reference frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    SampledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        if (!defined(referenceFrame)) {
	            throw new DeveloperError('referenceFrame is required.');
	        }
	        //>>includeEnd('debug');

	        result = this._property.getValue(time, result);
	        if (defined(result)) {
	            return PositionProperty.convertToReferenceFrame(time, result, this._referenceFrame, referenceFrame, result);
	        }
	        return undefined;
	    };

	    /**
	     * Sets the algorithm and degree to use when interpolating a position.
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.
	     * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.
	     */
	    SampledPositionProperty.prototype.setInterpolationOptions = function(options) {
	        this._property.setInterpolationOptions(options);
	    };

	    /**
	     * Adds a new sample.
	     *
	     * @param {JulianDate} time The sample time.
	     * @param {Cartesian3} position The position at the provided time.
	     * @param {Cartesian3[]} [derivatives] The array of derivative values at the provided time.
	     */
	    SampledPositionProperty.prototype.addSample = function(time, position, derivatives) {
	        var numberOfDerivatives = this._numberOfDerivatives;
	        //>>includeStart('debug', pragmas.debug);
	        if (numberOfDerivatives > 0 && (!defined(derivatives) || derivatives.length !== numberOfDerivatives)) {
	            throw new DeveloperError('derivatives length must be equal to the number of derivatives.');
	        }
	        //>>includeEnd('debug');
	        this._property.addSample(time, position, derivatives);
	    };

	    /**
	     * Adds multiple samples via parallel arrays.
	     *
	     * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.
	     * @param {Cartesian3[]} positions An array of Cartesian3 position instances, where each value corresponds to the provided time index.
	     * @param {Array[]} [derivatives] An array where each value is another array containing derivatives for the corresponding time index.
	     *
	     * @exception {DeveloperError} All arrays must be the same length.
	     */
	    SampledPositionProperty.prototype.addSamples = function(times, positions, derivatives) {
	        this._property.addSamples(times, positions, derivatives);
	    };

	    /**
	     * Adds samples as a single packed array where each new sample is represented as a date,
	     * followed by the packed representation of the corresponding value and derivatives.
	     *
	     * @param {Number[]} packedSamples The array of packed samples.
	     * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
	     */
	    SampledPositionProperty.prototype.addSamplesPackedArray = function(data, epoch) {
	        this._property.addSamplesPackedArray(data, epoch);
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    SampledPositionProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof SampledPositionProperty &&
	                Property.equals(this._property, other._property) && //
	                this._referenceFrame === other._referenceFrame);
	    };

	    return SampledPositionProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Defined the orientation of stripes in {@link StripeMaterialProperty}.
	     *
	     * @namespace
	     * @alias StripeOrientation
	     */
	    var StripeOrientation = {
	        /**
	         * Horizontal orientation.
	         * @type {Number}
	         */
	        HORIZONTAL : 0,

	        /**
	         * Vertical orientation.
	         * @type {Number}
	         */
	        VERTICAL : 1
	    };

	    return freezeObject(StripeOrientation);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a two dimensional wall defined as a line strip and optional maximum and minimum heights.
	     * The wall conforms to the curvature of the globe and can be placed along the surface or at altitude.
	     *
	     * @alias WallGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
	     * @param {Property} [options.maximumHeights] A Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
	     * @param {Property} [options.minimumHeights] A Property specifying an array of heights to be used for the bottom of the wall instead of the globe surface.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the wall.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the wall is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the wall.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the wall is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude point.
	     *
	     * @see Entity
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}
	     */
	    var WallGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._positions = undefined;
	        this._positionsSubscription = undefined;
	        this._minimumHeights = undefined;
	        this._minimumHeightsSubscription = undefined;
	        this._maximumHeights = undefined;
	        this._maximumHeightsSubscription = undefined;
	        this._granularity = undefined;
	        this._granularitySubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(WallGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof WallGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the wall.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the wall.
	         * @memberof WallGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         */
	        positions : createPropertyDescriptor('positions'),

	        /**
	         * Gets or sets the Property specifying an array of heights to be used for the bottom of the wall instead of the surface of the globe.
	         * If defined, the array must be the same length as {@link Wall#positions}.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         */
	        minimumHeights : createPropertyDescriptor('minimumHeights'),

	        /**
	         * Gets or sets the Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
	         * If defined, the array must be the same length as {@link Wall#positions}.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         */
	        maximumHeights : createPropertyDescriptor('maximumHeights'),

	        /**
	         * Gets or sets the numeric Property specifying the angular distance between points on the wall.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         * @default {CesiumMath.RADIANS_PER_DEGREE}
	         */
	        granularity : createPropertyDescriptor('granularity'),

	        /**
	         * Gets or sets the boolean Property specifying whether the wall is filled with the provided material.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the wall is outlined.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof WallGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {WallGraphics} [result] The object onto which to store the result.
	     * @returns {WallGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    WallGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new WallGraphics(this);
	        }
	        result.show = this.show;
	        result.material = this.material;
	        result.positions = this.positions;
	        result.minimumHeights = this.minimumHeights;
	        result.maximumHeights = this.maximumHeights;
	        result.granularity = this.granularity;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {WallGraphics} source The object to be merged into this object.
	     */
	    WallGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.positions = defaultValue(this.positions, source.positions);
	        this.minimumHeights = defaultValue(this.minimumHeights, source.minimumHeights);
	        this.maximumHeights = defaultValue(this.maximumHeights, source.maximumHeights);
	        this.granularity = defaultValue(this.granularity, source.granularity);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	    };

	    return WallGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        createPropertyDescriptor) {
	    "use strict";

	    function createRawProperty(value) {
	        return value;
	    }

	    /**
	     * @private
	     */
	    function createRawPropertyDescriptor(name, configurable) {
	        return createPropertyDescriptor(name, configurable, createRawProperty);
	    }

	    return createRawPropertyDescriptor;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2015
	 */
	function EventEmitter() {
	    this.listeners = {};
	    this._owner = this;
	}
	EventEmitter.prototype.emit = function emit(type, event) {
	    var handlers = this.listeners[type];
	    if (handlers) {
	        for (var i = 0; i < handlers.length; i++) {
	            handlers[i].call(this._owner, event);
	        }
	    }
	    return this;
	};
	EventEmitter.prototype.on = function on(type, handler) {
	    if (!(type in this.listeners))
	        this.listeners[type] = [];
	    var index = this.listeners[type].indexOf(handler);
	    if (index < 0)
	        this.listeners[type].push(handler);
	    return this;
	};
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	EventEmitter.prototype.removeListener = function removeListener(type, handler) {
	    var listener = this.listeners[type];
	    if (listener !== undefined) {
	        var index = listener.indexOf(handler);
	        if (index >= 0)
	            listener.splice(index, 1);
	    }
	    return this;
	};
	EventEmitter.prototype.bindThis = function bindThis(owner) {
	    this._owner = owner;
	};
	module.exports = EventEmitter;

/***/ },
/* 143 */,
/* 144 */,
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	// Array.prototype.find - MIT License (c) 2013 Paul Miller <http://paulmillr.com>
	// For all details and docs: https://github.com/paulmillr/array.prototype.find
	// Fixes and tests supplied by Duncan Hall <http://duncanhall.net> 
	(function(globals){
	  if (Array.prototype.find) return;

	  var find = function(predicate) {
	    var list = Object(this);
	    var length = list.length < 0 ? 0 : list.length >>> 0; // ES.ToUint32;
	    if (length === 0) return undefined;
	    if (typeof predicate !== 'function' || Object.prototype.toString.call(predicate) !== '[object Function]') {
	      throw new TypeError('Array#find: predicate must be a function');
	    }
	    var thisArg = arguments[1];
	    for (var i = 0, value; i < length; i++) {
	      value = list[i];
	      if (predicate.call(thisArg, value, i, list)) return value;
	    }
	    return undefined;
	  };

	  if (Object.defineProperty) {
	    try {
	      Object.defineProperty(Array.prototype, 'find', {
	        value: find, configurable: true, enumerable: false, writable: true
	      });
	    } catch(e) {}
	  }

	  if (!Array.prototype.find) {
	    Array.prototype.find = find;
	  }
	})(this);


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _Object$defineProperty = __webpack_require__(59)['default'];

	var _Object$getOwnPropertyNames = __webpack_require__(153)['default'];

	if (!Error.prototype.toJSON) {
	    _Object$defineProperty(Error.prototype, 'toJSON', {
	        value: function value() {
	            var json = {};

	            _Object$getOwnPropertyNames(this).forEach(function (key) {
	                json[key] = this[key];
	            }, this);

	            return json;
	        },
	        configurable: true
	    });
	}

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	// Transforms incoming & outgoing messages for backwards compatability

	"use strict";

	module.exports = {

	  toChannel: function toChannel(type, event, version) {
	    var message = { type: type, event: event };

	    // if (type === )

	    return message;
	  },

	  fromChannel: function fromChannel(type, event, version) {
	    var message = { type: type, event: event };

	    return message;
	  }

	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	/**
	 * Extends Cesium Entity and several property types to output CZML
	 */

	'use strict';

	var _WeakMap = __webpack_require__(50)['default'];

	var _Set = __webpack_require__(97)['default'];

	var _getIterator = __webpack_require__(67)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _CesiumImports = __webpack_require__(15);

	var _CesiumImports2 = _interopRequireDefault(_CesiumImports);

	// TODO: support TimeIntervalProperty
	// XXX: custom properties don't send emit a definitionChanged event
	// TODO: support derivative values in SampledProperty

	/* Map from cesium entities to related objects. */
	var observerMap = new _WeakMap();
	var czmlMap = new _WeakMap();
	var propertyDeltaIntervalsMap = new _WeakMap();

	var CzmlWriter = {};
	exports['default'] = CzmlWriter;

	/* Returns a czml object which tracks the provided entity */
	CzmlWriter.getCzmlFromEntity = function getCzmlFromEntity(entity) {
	  var czml = czmlMap.get(entity);

	  if (!czml) {
	    czml = { id: entity.id };
	    czmlMap.set(entity, czml);

	    entity.definitionChanged.addEventListener(onEntityDefinitionChanged);

	    for (var i = 0; i < entity.propertyNames.length; i++) {
	      var _name = entity.propertyNames[i];
	      var property = entity[_name];
	      if (property) {
	        czml[_name] = createCzmlFromProperty(property);
	      }
	    }
	  }

	  return czml;
	};

	/* Subscribes the observer to any changes in the entity.
	 * Changes will be sent in the form of CZML packets.
	 * The first packet sent to an observer will contain the entire state.
	 */
	CzmlWriter.observeEntity = function observeEntity(entity, observer) {
	  // Add the observer to the entity's list of observers
	  var observers = observerMap.get(entity);
	  if (!observers) {
	    observers = new _Set();
	    observerMap.set(entity, observers);
	  }
	  observers.add(observer);

	  observer(CzmlWriter.getCzmlFromEntity(entity));

	  return function unobserve() {
	    observers['delete'](observer);
	  };
	};

	/* Stop sending entity updates to observer. See `observeEntity`. */
	CzmlWriter.unobserveEntity = function unobserveEntity(entity, observer) {
	  var observers = observerMap.get(entity);
	  if (observers) observers['delete'](observer);
	};

	function onEntityDefinitionChanged(entity, propertyName, newValue, oldValue) {
	  var czml = czmlMap.get(entity);
	  var propertyCzml = undefined;
	  if (newValue !== oldValue || newValue.constructor === _CesiumImports2['default'].ConstantProperty || newValue.constructor === _CesiumImports2['default'].ConstantPositionProperty) {
	    propertyCzml = createCzmlFromProperty(newValue);
	    czml[propertyName] = propertyCzml;
	  } else {
	    propertyCzml = getDeltaIntervalsFromProperty(newValue);
	    if (!propertyCzml) {
	      // TODO: if we have no delta intervals at this point, then something in
	      // the property changed, but we are not keeping track of it...
	      throw new Error();
	    }
	  }

	  var observers = observerMap.get(entity);
	  if (propertyCzml && observers.size > 0) {
	    var _czmlPacket;

	    var czmlPacket = (_czmlPacket = {}, _czmlPacket.id = entity.id, _czmlPacket[propertyName] = propertyCzml, _czmlPacket);
	    for (var _iterator = observers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
	      var _ref;

	      if (_isArray) {
	        if (_i >= _iterator.length) break;
	        _ref = _iterator[_i++];
	      } else {
	        _i = _iterator.next();
	        if (_i.done) break;
	        _ref = _i.value;
	      }

	      var observer = _ref;
	      observer(czmlPacket);
	    }
	  }
	}

	/*=== Property To CZML =======================================================*/

	function createCzmlFromProperty(property) {
	  switch (property.constructor) {
	    case _CesiumImports2['default'].ConstantProperty:
	    case _CesiumImports2['default'].ConstantPositionProperty:
	      return constantPropertyToCzml(property);

	    case _CesiumImports2['default'].SampledProperty:
	    case _CesiumImports2['default'].SampledPositionProperty:
	      return sampledPropertyToCzml(property);

	    case _CesiumImports2['default'].ReferenceProperty:
	      return referencePropertyToCzml(property);

	    default:
	      return undefined;
	  }
	}

	function getDeltaIntervalsFromProperty(property) {
	  var deltaIntervals = propertyDeltaIntervalsMap.get(property);
	  propertyDeltaIntervalsMap.set(property, []);
	  return deltaIntervals && deltaIntervals.length > 0 ? deltaIntervals : null;
	}

	function constantPropertyToCzml(property) {
	  var value = property._value;

	  if (value && typeof value.constructor.pack === 'function') {
	    var _propertyCzml;

	    var typeName = czmlNameForType(value.constructor);
	    var packed = [];
	    value.constructor.pack(value, packed);

	    var propertyCzml = (_propertyCzml = {}, _propertyCzml[typeName] = packed, _propertyCzml);

	    if (property.referenceFrame !== undefined) {
	      propertyCzml.referenceFrame = czmlValueForReferenceFrame(property._referenceFrame);
	    }

	    return propertyCzml;
	  }

	  return value // should be a primitive value
	  ;
	}

	function sampledPropertyToCzml(property) {
	  var _czmlInterval;

	  property.addSample = addSampleSpy;
	  property.addSamples = addSamplesSpy;
	  property.addSamplesPackedArray = addSamplesPackedArraySpy;
	  propertyDeltaIntervalsMap.set(property, []);

	  var sampledProperty = property._property || property;
	  var innerDerivativeTypes = sampledProperty._innerDerivativeTypes;
	  var hasDerivatives = innerDerivativeTypes !== undefined;
	  var innerType = sampledProperty._innerType;
	  var derivativesLength = hasDerivatives ? innerDerivativeTypes.length : 0;

	  var czmlSampledData = [];
	  var timesLength = sampledProperty._times.length;
	  var packedLength = sampledProperty._packedLength;

	  for (var i = 0; i < timesLength; i++) {
	    var index = i * (packedLength + 1);
	    czmlSampledData[index] = _CesiumImports2['default'].JulianDate.toIso8601(sampledProperty._times[i], 6);
	    copyIntoArray(czmlSampledData, index + 1, sampledProperty._values, i * packedLength, packedLength);
	  }

	  var czmlName = czmlNameForSampledType(innerType, derivativesLength);
	  var czmlInterval = (_czmlInterval = {}, _czmlInterval[czmlName] = czmlSampledData, _czmlInterval.interpolationAlgorithm = sampledProperty._interpolationAlgorithm.type.toUpperCase(), _czmlInterval.interpolationDegree = sampledProperty._interpolationDegree, _czmlInterval.forwardExtrapolationType = czmlNameForExtrapolationType(sampledProperty._forwardExtrapolationType), _czmlInterval.forwardExtrapolationDuration = sampledProperty._forwardExtrapolationDuration, _czmlInterval.backwardExtrapolationType = czmlNameForExtrapolationType(sampledProperty._backwardExtrapolationType), _czmlInterval.backwardExtrapolationDuration = sampledProperty._backwardExtrapolationDuration, _czmlInterval);

	  if (property.referenceFrame !== undefined) {
	    czmlInterval.referenceFrame = czmlValueForReferenceFrame(property.referenceFrame);
	  }

	  return czmlInterval;
	}

	function referencePropertyToCZML(property) {
	  propertyDeltaIntervalsMap.set(property, []);

	  var czml = {
	    reference: property.targetId + '#' + property.targetPropertyNames.join('.')
	  };

	  property.definitionChanged.addEventListener(function () {
	    czml.reference = property.targetId + '#' + property.targetPropertyNames.join('.');
	    propertyDeltaIntervalsMap.get(property).push({
	      reference: czml.reference
	    });
	  });

	  return czml;
	}

	/*=== SampledProperty Helpers =====================================================*/

	function czmlNameForSampledType(type, derivativesLength) {
	  if (type === _CesiumImports2['default'].Cartesian3) {
	    if (derivativesLength === 0) return 'cartesian';
	    if (derivativesLength === 1) return 'cartesianVelocity';
	    throw new Error('Unhandled CZML Type: ' + type.constructor.name + ' derivatives: ' + derivativesLength);
	  }
	  return czmlNameForType(type);
	}

	function addSampleSpy(time, value, derivatives) {
	  var property = this._property || this;

	  var innerDerivativeTypes = property._innerDerivativeTypes;
	  var hasDerivatives = innerDerivativeTypes !== undefined;
	  var innerType = property._innerType;
	  var derivativesLength = hasDerivatives ? innerDerivativeTypes.length : 0;
	  var data = [];
	  data.push(_CesiumImports2['default'].JulianDate.toIso8601(time, 6));
	  innerType.pack(value, data, data.length);
	  if (hasDerivatives) {
	    for (var x = 0; x < derivativesLength; x++) {
	      innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
	    }
	  }

	  var czmlName = czmlNameForSampledType(innerType, derivativesLength);
	  var czmlInterval = {};
	  czmlInterval[czmlName] = data;
	  if (this.referenceFrame !== undefined) czmlInterval.referenceFrame = czmlValueForReferenceFrame(this.referenceFrame);
	  propertyDeltaIntervalsMap.get(this).push(czmlInterval);

	  this.constructor.prototype.addSample.call(this, time, value, derivatives);
	}

	function addSamplesSpy(times, values, derivativeValues) {
	  var property = this._property || this;

	  var innerDerivativeTypes = property._innerDerivativeTypes;
	  var hasDerivatives = defined(innerDerivativeTypes);
	  var innerType = property._innerType;
	  var derivativesLength = hasDerivatives ? innerDerivativeTypes.length : 0;
	  var length = times.length;
	  var data = [];
	  for (var i = 0; i < length; i++) {
	    data.push(_CesiumImports2['default'].JulianDate.toIso8601(times[i], 6));
	    innerType.pack(values[i], data, data.length);
	    if (hasDerivatives) {
	      var derivatives = derivativeValues[i];
	      for (var x = 0; x < derivativesLength; x++) {
	        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
	      }
	    }
	  }

	  var czmlName = czmlNameForSampledType(innerType, derivativesLength);
	  var czmlInterval = {};
	  czmlInterval[czmlName] = data;
	  if (this.referenceFrame !== undefined) czmlInterval.referenceFrame = czmlValueForReferenceFrame(this.referenceFrame);
	  propertyDeltaIntervalsMap.get(this).push(czmlInterval);

	  this.constructor.prototype.addSamples.call(this, times, values, derivativeValues);
	}

	function addSamplesPackedArraySpy(packedSamples, epoch) {
	  var property = this._property || this;

	  var innerDerivativeTypes = property._innerDerivativeTypes;
	  var numDerivatives = innerDerivativeTypes ? innerDerivativeTypes.length : 0;

	  var czmlName = czmlNameForSampledType(property._innerType, numDerivatives);
	  var czmlInterval = {};
	  czmlInterval[czmlName] = packedSamples;
	  if (epoch) czmlInterval.epoch = _CesiumImports2['default'].JulianDate.toIso8601(epoch);
	  if (this.referenceFrame !== undefined) czmlInterval.referenceFrame = czmlValueForReferenceFrame(this.referenceFrame);
	  propertyDeltaIntervalsMap.get(this).push(czmlInterval);

	  this.constructor.prototype.addSamplesPackedArray.call(this, packedSamples, epoch);
	}

	/*=== Util ===================================================================*/

	function copyIntoArray(array, arrayIndex, items, itemsIndex, ammount) {
	  itemsIndex = itemsIndex || 0;
	  ammount = ammount || items.length;
	  for (var i = 0; i < ammount; i++) {
	    array[arrayIndex++] = items[itemsIndex++];
	  }
	}

	function czmlNameForType(type) {
	  switch (type) {
	    case Number:
	      return 'number';
	    case _CesiumImports2['default'].Cartesian2:
	      return 'cartesian2';
	    case _CesiumImports2['default'].Cartesian3:
	      return 'cartesian';
	    case _CesiumImports2['default'].Cartesian4:
	      return 'cartesian4';
	    case _CesiumImports2['default'].Color:
	      return 'rgba';
	    case _CesiumImports2['default'].Quaternion:
	      return 'unitQuaternion';
	    default:
	      throw new _CesiumImports2['default'].DeveloperError('Unhandled CZML Type: ' + type.constructor.name);
	  }
	}

	function czmlNameForExtrapolationType(type) {
	  switch (type) {
	    case _CesiumImports2['default'].ExtrapolationType.NONE:
	      return 'NONE';
	    case _CesiumImports2['default'].ExtrapolationType.HOLD:
	      return 'HOLD';
	    case _CesiumImports2['default'].ExtrapolationType.EXTRAPOLATE:
	      return 'EXTRAPOLATE';
	    default:
	      throw new _CesiumImports2['default'].DeveloperError('Unhandled ExtrapolationType: ' + type);
	  }
	}

	function czmlValueForReferenceFrame(referenceFrame) {
	  switch (referenceFrame) {
	    case null:
	      return null;
	    case _CesiumImports2['default'].ReferenceFrame.FIXED:
	      return 'FIXED';
	    case _CesiumImports2['default'].ReferenceFrame.INERTIAL:
	      return 'INERTIAL';
	    default:
	      return '#' + referenceFrame.id;
	  }
	}
	module.exports = exports['default'];

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	// Add functionality for keeping a moving window of samples per SampledProperty,
	// so that the data doesn't accumulate indefinitely
	'use strict';

	var _interopRequireDefault = __webpack_require__(9)['default'];

	var _CesiumImports = __webpack_require__(15);

	var _CesiumImports2 = _interopRequireDefault(_CesiumImports);

	var SampledProperty = _CesiumImports2['default'].SampledProperty;
	var SampledPositionProperty = _CesiumImports2['default'].SampledPositionProperty;
	var binarySearch = _CesiumImports2['default'].binarySearch;
	var JulianDate = _CesiumImports2['default'].JulianDate;

	var __slice = Array.prototype.slice;

	var after = function after(fn, _after) {
	  return function () {
	    var result = fn.apply(this, arguments);
	    _after.call(this, result);
	    return result;
	  };
	};

	function removeBeforeDate(property, time) {
	  var times = property._times;
	  var index = ~binarySearch(times, time, JulianDate.compare);
	  if (index > 0) {
	    times.splice(0, index);
	    property._values.splice(0, index * property._innerType.packedLength);
	    property._updateTableLength = true;
	    property._definitionChanged.raiseEvent(property);
	  }
	}

	SampledProperty.prototype.removeSamplesBeforeDate = function (time) {
	  removeBeforeDate(this, time);
	};

	SampledPositionProperty.prototype.removeSamplesBeforeDate = function (time) {
	  removeBeforeDate(this._property, time);
	};

	function removeOldSamples(property, maxNumSamples) {
	  if (maxNumSamples === undefined) maxNumSamples = 10;
	  var removeCount = property._times.length - maxNumSamples;
	  if (removeCount > 0) {
	    property._times.splice(0, removeCount);
	    property._values.splice(0, removeCount * property._innerType.packedLength);
	    property._updateTableLength = true;
	  }
	}

	SampledProperty.prototype.addSample = after(SampledProperty.prototype.addSample, function () {
	  removeOldSamples(this, this.maxNumSamples);
	});

	SampledProperty.prototype.addSamples = after(SampledProperty.prototype.addSamples, function () {
	  removeOldSamples(this, this.maxNumSamples);
	});

	SampledProperty.prototype.addSamplesPackedArray = after(SampledProperty.prototype.addSamplesPackedArray, function () {
	  removeOldSamples(this, this.maxNumSamples);
	});

	SampledPositionProperty.prototype.addSample = after(SampledPositionProperty.prototype.addSample, function () {
	  removeOldSamples(this._property, this.maxNumSamples);
	});

	SampledPositionProperty.prototype.addSamples = after(SampledPositionProperty.prototype.addSamples, function () {
	  removeOldSamples(this._property, this.maxNumSamples);
	});

	SampledPositionProperty.prototype.addSamplesPackedArray = after(SampledPositionProperty.prototype.addSamplesPackedArray, function () {
	  removeOldSamples(this._property, this.maxNumSamples);
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _interopRequireDefault = __webpack_require__(9)['default'];

	exports.__esModule = true;

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _dataSource = __webpack_require__(23);

	var _dataSource2 = _interopRequireDefault(_dataSource);

	var _Platform = __webpack_require__(18);

	var _device = __webpack_require__(90);

	var _device2 = _interopRequireDefault(_device);

	var eyeEntity = _dataSource2['default'].entities.add({
	  id: 'EYE',
	  name: 'EYE'
	});

	// should be changed (in the manager) to use to the appropriate
	// reference frame based on hardware configuration
	eyeEntity.position = new _cesiumCesiumImports2['default'].ConstantPositionProperty(_cesiumCesiumImports2['default'].Cartesian3.ZERO, _device2['default']);
	eyeEntity.orientation = new _cesiumCesiumImports2['default'].ConstantProperty(_cesiumCesiumImports2['default'].Quaternion.IDENTITY);

	if (_Platform.isChannel) {
	  _dataSource2['default'].subscribeToEntityById('EYE');
	}

	exports['default'] = eyeEntity;
	module.exports = exports['default'];

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _inherits = __webpack_require__(70)['default'];

	var _classCallCheck = __webpack_require__(26)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	var _Reality2 = __webpack_require__(25);

	var _Reality3 = _interopRequireDefault(_Reality2);

	var _Util = __webpack_require__(22);

	var _Util2 = _interopRequireDefault(_Util);

	var _cesiumCesiumImports = __webpack_require__(15);

	var _cesiumCesiumImports2 = _interopRequireDefault(_cesiumCesiumImports);

	var _dataSource = __webpack_require__(23);

	var _dataSource2 = _interopRequireDefault(_dataSource);

	// Use:
	// var pano = {
	//   type: 'skybox'
	//   source: {up: down: north: east: south: west:},
	//   headingOffset: 0,
	//   cartographicDegrees: [lat, long, alt]
	// }
	// var reality = new Argon.Reality.Panorama
	// reality.setPanoramaEntity(panoEntity)

	// TODO: support transitioning between panoramas

	/**
	 * [PanoramaReality description]
	 * @type {[type]}
	 */
	_Reality3['default'].Panorama = (function (_Reality) {
	  function PanoramaReality() {
	    _classCallCheck(this, PanoramaReality);

	    _Reality.call(this, {
	      type: 'Panorama',
	      autoTick: true,
	      jsDeps: ['https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js', 'https://cdn.rawgit.com/unconed/threestrap/0.0.10/build/threestrap.min.js'],
	      renderScript: function renderScript(port) {

	        var three = THREE.Bootstrap({
	          element: this.element
	        });

	        var blankCanvas = document.createElement('canvas');
	        blankCanvas.width = 256;
	        blankCanvas.height = 256;

	        var texture = new THREE.Texture(blankCanvas);
	        texture.needsUpdate = true;

	        var sphereGeometry = new THREE.SphereGeometry(50, 60, 40);
	        sphereGeometry.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
	        var sphereMaterial = new THREE.MeshBasicMaterial({ map: texture });

	        var sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
	        three.scene.add(sphereMesh);

	        var materials = [];
	        for (var i = 0; i < 6; i++) {
	          materials.push(new THREE.MeshBasicMaterial({ map: texture }));
	        }
	        directions = ['west', 'east', 'up', 'down', 'south', 'north'];

	        var boxMesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100), new THREE.MeshFaceMaterial(materials));
	        three.scene.add(boxMesh);
	        boxMesh.scale.set(-1, 1, 1);

	        sphereMesh.visible = false;
	        boxMesh.visible = false;
	        //
	        // port.on('resize', () => {
	        //   three.plugins.size.queue(null, three)
	        // })

	        window.addEventListener('resize', function () {
	          three.plugins.size.queue(null, three);
	        });

	        three.camera.matrixAutoUpdate = false;

	        var x90 = new THREE.Quaternion();
	        x90.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
	        port.on('update', function (state) {
	          three.camera.fov = state.frustum.fovy * 180 / Math.PI;
	          three.camera.aspect = state.frustum.aspectRatio;
	          three.camera.updateProjectionMatrix();
	          three.camera.quaternion.copy(state.orientation.unitQuaternionRelative || state.orientation.unitQuaternion);
	          three.camera.quaternion.multiplyQuaternions(x90, three.camera.quaternion);
	          three.camera.updateMatrix();
	        });

	        var options;
	        port.on('options', function (o) {
	          options = o;
	          if (options.panorama) _loadPanorama(options.panorama);
	        });

	        var currentPanorama;
	        var _loadPanorama = function _loadPanorama(panorama) {
	          if (!currentPanorama || currentPanorama.id !== panorama.id) {
	            currentPanorama = panorama;
	            switch (panorama.type) {
	              case 'skybox':
	                _loadSkybox(panorama);break;
	              case 'equirectangular':
	                _loadEquirectangular(panorama);break;
	            }
	          }
	        };

	        THREE.ImageUtils.crossOrigin = 'anonymous';

	        var _loadSkybox = function _loadSkybox(panorama) {
	          var source = panorama.source;

	          for (var i = 0; i < 6; i++) {
	            var url = source[directions[i]];
	            var texture = THREE.ImageUtils.loadTexture(url);
	            materials[i] = new THREE.MeshBasicMaterial({ map: texture });
	          }
	          boxMesh.visible = true;
	          sphereMesh.visible = false;
	        };

	        var _loadEquirectangular = function _loadEquirectangular(panorama) {
	          var url = panorama.source;
	          sphereMaterial.map = THREE.ImageUtils.loadTexture(url, undefined, function () {
	            sphereMaterial.needsUpdate = true;
	          });
	          boxMesh.visible = false;
	          sphereMesh.visible = true;
	        };
	      }
	    });
	  }

	  _inherits(PanoramaReality, _Reality);

	  /**
	   *
	   */

	  PanoramaReality.prototype.setPanorama = function setPanorama(panorama) {
	    if (!panorama) throw new Error('Expected a panorama property');

	    if (!panorama.id) {
	      panorama.id = _Util2['default'].cuid();
	      var type = panorama.type;

	      // debugger
	      if (type === 'equirectangular') {
	        panorama.source = _Util2['default'].resolveURL(panorama.source);
	      }

	      if (type === 'skybox') {
	        var source = panorama.source;
	        source.up = _Util2['default'].resolveURL(source.up);
	        source.down = _Util2['default'].resolveURL(source.down);
	        source.north = _Util2['default'].resolveURL(source.north);
	        source.south = _Util2['default'].resolveURL(source.south);
	        source.east = _Util2['default'].resolveURL(source.east);
	        source.west = _Util2['default'].resolveURL(source.west);
	      }
	    }

	    this.set('panorama', panorama);

	    var lla = panorama.cartographicDegrees;
	    if (lla) {
	      var position = _cesiumCesiumImports2['default'].Cartesian3.fromDegrees(lla[0], lla[1], lla[2]);
	      this.eye.position.setValue(position, Argon.Cesium.FIXED);
	      this.eye.orientation.setValue(_cesiumCesiumImports2['default'].Quaternion.IDENTITY);
	    } else {
	      var deviceEntity = _dataSource2['default'].entities.getById('DEVICE');
	      this.eye.position.setValue(_cesiumCesiumImports2['default'].Cartesian3.ZERO, deviceEntity);
	      this.eye.orientation.setValue(_cesiumCesiumImports2['default'].Quaternion.IDENTITY);
	    }
	  };

	  return PanoramaReality;
	})(_Reality3['default']);

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var Argon = module.exports = __webpack_require__(65);

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(156), __esModule: true };

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(159), __esModule: true };

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(5);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(5);
	__webpack_require__(73);
	module.exports = function getOwnPropertyNames(it){
	  return $.getNames(it);
	};

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(73);
	module.exports = __webpack_require__(5).core.Object.keys;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(73);
	module.exports = __webpack_require__(5).core.Object.seal;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(160);
	module.exports = __webpack_require__(5).core.Object.values;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// http://goo.gl/XkBrjD
	var $    = __webpack_require__(5)
	  , $def = __webpack_require__(27);
	function createObjectToArray(isEntries){
	  return function(object){
	    var O      = $.toObject(object)
	      , keys   = $.getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = Array(length)
	      , key;
	    if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
	    else while(length > i)result[i] = O[keys[i++]];
	    return result;
	  };
	}
	$def($def.S, 'Object', {
	  values:  createObjectToArray(false),
	  entries: createObjectToArray(true)
	});

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError) {
	    "use strict";

	    /**
	     * A collection of key-value pairs that is stored as a hash for easy
	     * lookup but also provides an array for fast iteration.
	     * @alias AssociativeArray
	     * @constructor
	     */
	    var AssociativeArray = function() {
	        this._array = [];
	        this._hash = {};
	    };

	    defineProperties(AssociativeArray.prototype, {
	        /**
	         * Gets the number of items in the collection.
	         * @memberof AssociativeArray.prototype
	         *
	         * @type {Number}
	         */
	        length : {
	            get : function() {
	                return this._array.length;
	            }
	        },
	        /**
	         * Gets an unordered array of all values in the collection.
	         * This is a live array that will automatically reflect the values in the collection,
	         * it should not be modified directly.
	         * @memberof AssociativeArray.prototype
	         *
	         * @type {Array}
	         */
	        values : {
	            get : function() {
	                return this._array;
	            }
	        }
	    });

	    /**
	     * Determines if the provided key is in the array.
	     *
	     * @param {String|Number} key The key to check.
	     * @returns {Boolean} <code>true</code> if the key is in the array, <code>false</code> otherwise.
	     */
	    AssociativeArray.prototype.contains = function(key) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof key !== 'string' && typeof key !== 'number') {
	            throw new DeveloperError('key is required to be a string or number.');
	        }
	        //>>includeEnd('debug');
	        return defined(this._hash[key]);
	    };

	    /**
	     * Associates the provided key with the provided value.  If the key already
	     * exists, it is overwritten with the new value.
	     *
	     * @param {String|Number} key A unique identifier.
	     * @param {Object} value The value to associate with the provided key.
	     */
	    AssociativeArray.prototype.set = function(key, value) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof key !== 'string' && typeof key !== 'number') {
	            throw new DeveloperError('key is required to be a string or number.');
	        }
	        //>>includeEnd('debug');

	        var oldValue = this._hash[key];
	        if (value !== oldValue) {
	            this.remove(key);
	            this._hash[key] = value;
	            this._array.push(value);
	        }
	    };

	    /**
	     * Retrieves the value associated with the provided key.
	     *
	     * @param {String|Number} key The key whose value is to be retrieved.
	     * @returns {Object} The associated value, or undefined if the key does not exist in the collection.
	     */
	    AssociativeArray.prototype.get = function(key) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof key !== 'string' && typeof key !== 'number') {
	            throw new DeveloperError('key is required to be a string or number.');
	        }
	        //>>includeEnd('debug');
	        return this._hash[key];
	    };

	    /**
	     * Removes a key-value pair from the collection.
	     *
	     * @param {String|Number} key The key to be removed.
	     * @returns {Boolean} True if it was removed, false if the key was not in the collection.
	     */
	    AssociativeArray.prototype.remove = function(key) {
	        //>>includeStart('debug', pragmas.debug);
	        if (defined(key) && typeof key !== 'string' && typeof key !== 'number') {
	            throw new DeveloperError('key is required to be a string or number.');
	        }
	        //>>includeEnd('debug');

	        var value = this._hash[key];
	        var hasValue = defined(value);
	        if (hasValue) {
	            var array = this._array;
	            array.splice(array.indexOf(value), 1);
	            this._hash[key] = undefined;
	        }
	        return hasValue;
	    };

	    /**
	     * Clears the collection.
	     */
	    AssociativeArray.prototype.removeAll = function() {
	        var array = this._array;
	        if (array.length > 0) {
	            this._hash = {};
	            array.length = 0;
	        }
	    };

	    return AssociativeArray;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(47),
	        __webpack_require__(45),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(117),
	        __webpack_require__(7),
	        __webpack_require__(16),
	        __webpack_require__(122),
	        __webpack_require__(79),
	        __webpack_require__(36),
	        __webpack_require__(77),
	        __webpack_require__(78)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        when,
	        binarySearch,
	        defaultValue,
	        defined,
	        EarthOrientationParametersSample,
	        freezeObject,
	        JulianDate,
	        LeapSecond,
	        loadJson,
	        RuntimeError,
	        TimeConstants,
	        TimeStandard) {
	    "use strict";

	    /**
	     * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.
	     * These Earth Orientation Parameters (EOP) are primarily used in the transformation from
	     * the International Celestial Reference Frame (ICRF) to the International Terrestrial
	     * Reference Frame (ITRF).
	     *
	     * @alias EarthOrientationParameters
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {String} [options.url] The URL from which to obtain EOP data.  If neither this
	     *                 parameter nor options.data is specified, all EOP values are assumed
	     *                 to be 0.0.  If options.data is specified, this parameter is
	     *                 ignored.
	     * @param {Object} [options.data] The actual EOP data.  If neither this
	     *                 parameter nor options.data is specified, all EOP values are assumed
	     *                 to be 0.0.
	     * @param {Boolean} [options.addNewLeapSeconds=true] True if leap seconds that
	     *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}
	     *                  should be added to {@link JulianDate.leapSeconds}.  False if
	     *                  new leap seconds should be handled correctly in the context
	     *                  of the EOP data but otherwise ignored.
	     *
	     * @example
	     * // An example EOP data file, EOP.json:
	     * {
	     *   "columnNames" : ["dateIso8601","xPoleWanderRadians","yPoleWanderRadians","ut1MinusUtcSeconds","lengthOfDayCorrectionSeconds","xCelestialPoleOffsetRadians","yCelestialPoleOffsetRadians","taiMinusUtcSeconds"],
	     *   "samples" : [
	     *      "2011-07-01T00:00:00Z",2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,
	     *      "2011-07-02T00:00:00Z",2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,
	     *      "2011-07-03T00:00:00Z",2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0
	     *   ]
	     * }
	     *
	     * @example
	     * // Loading the EOP data
	     * var eop = new Cesium.EarthOrientationParameters({ url : 'Data/EOP.json' });
	     * Cesium.Transforms.earthOrientationParameters = eop;
	     *
	     * @private
	     */
	    var EarthOrientationParameters = function EarthOrientationParameters(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        this._dates = undefined;
	        this._samples = undefined;

	        this._dateColumn = -1;
	        this._xPoleWanderRadiansColumn = -1;
	        this._yPoleWanderRadiansColumn = -1;
	        this._ut1MinusUtcSecondsColumn = -1;
	        this._xCelestialPoleOffsetRadiansColumn = -1;
	        this._yCelestialPoleOffsetRadiansColumn = -1;
	        this._taiMinusUtcSecondsColumn = -1;

	        this._columnCount = 0;
	        this._lastIndex = -1;

	        this._downloadPromise = undefined;
	        this._dataError = undefined;

	        this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);

	        if (defined(options.data)) {
	            // Use supplied EOP data.
	            onDataReady(this, options.data);
	        } else if (defined(options.url)) {
	            // Download EOP data.
	            var that = this;
	            this._downloadPromise = when(loadJson(options.url), function(eopData) {
	                onDataReady(that, eopData);
	            }, function() {
	                that._dataError = 'An error occurred while retrieving the EOP data from the URL ' + options.url + '.';
	            });
	        } else {
	            // Use all zeros for EOP data.
	            onDataReady(this, {
	                'columnNames' : ['dateIso8601', 'modifiedJulianDateUtc', 'xPoleWanderRadians', 'yPoleWanderRadians', 'ut1MinusUtcSeconds', 'lengthOfDayCorrectionSeconds', 'xCelestialPoleOffsetRadians', 'yCelestialPoleOffsetRadians', 'taiMinusUtcSeconds'],
	                'samples' : []
	            });
	        }
	    };

	    /**
	     * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.
	     */
	    EarthOrientationParameters.NONE = freezeObject({
	            getPromiseToLoad : function() {
	                return when();
	            },
	            compute : function(date, result) {
	                if (!defined(result)) {
	                    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
	                } else {
	                    result.xPoleWander = 0.0;
	                    result.yPoleWander = 0.0;
	                    result.xPoleOffset = 0.0;
	                    result.yPoleOffset = 0.0;
	                    result.ut1MinusUtc = 0.0;
	                }
	                return result;
	            }
	    });

	    /**
	     * Gets a promise that, when resolved, indicates that the EOP data has been loaded and is
	     * ready to use.
	     *
	     * @returns {Promise} The promise.
	     *
	     * @see when
	     */
	    EarthOrientationParameters.prototype.getPromiseToLoad = function() {
	        return when(this._downloadPromise);
	    };

	    /**
	     * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.
	     * If the EOP data has not yet been download, this method returns undefined.
	     *
	     * @param {JulianDate} date The date for each to evaluate the EOP.
	     * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.
	     *        If this parameter is undefined, a new instance is created and returned.
	     * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or
	     *          undefined if the data necessary to evaluate EOP at the date has not yet been
	     *          downloaded.
	     *
	     * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.
	     *
	     * @see EarthOrientationParameters#getPromiseToLoad
	     */
	    EarthOrientationParameters.prototype.compute = function(date, result) {
	        // We cannot compute until the samples are available.
	        if (!defined(this._samples)) {
	            if (defined(this._dataError)) {
	                throw new RuntimeError(this._dataError);
	            }

	            return undefined;
	        }

	        if (!defined(result)) {
	            result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
	        }

	        if (this._samples.length === 0) {
	            result.xPoleWander = 0.0;
	            result.yPoleWander = 0.0;
	            result.xPoleOffset = 0.0;
	            result.yPoleOffset = 0.0;
	            result.ut1MinusUtc = 0.0;
	            return result;
	        }

	        var dates = this._dates;
	        var lastIndex = this._lastIndex;

	        var before = 0;
	        var after = 0;
	        if (defined(lastIndex)) {
	            var previousIndexDate = dates[lastIndex];
	            var nextIndexDate = dates[lastIndex + 1];
	            var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);
	            var isAfterLastSample = !defined(nextIndexDate);
	            var isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);

	            if (isAfterPrevious && isBeforeNext) {
	                before = lastIndex;

	                if (!isAfterLastSample && nextIndexDate.equals(date)) {
	                    ++before;
	                }
	                after = before + 1;

	                interpolate(this, dates, this._samples, date, before, after, result);
	                return result;
	            }
	        }

	        var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);
	        if (index >= 0) {
	            // If the next entry is the same date, use the later entry.  This way, if two entries
	            // describe the same moment, one before a leap second and the other after, then we will use
	            // the post-leap second data.
	            if (index < dates.length - 1 && dates[index + 1].equals(date)) {
	                ++index;
	            }
	            before = index;
	            after = index;
	        } else {
	            after = ~index;
	            before = after - 1;

	            // Use the first entry if the date requested is before the beginning of the data.
	            if (before < 0) {
	                before = 0;
	            }
	        }

	        this._lastIndex = before;

	        interpolate(this, dates, this._samples, date, before, after, result);
	        return result;
	    };

	    function compareLeapSecondDates(leapSecond, dateToFind) {
	        return JulianDate.compare(leapSecond.julianDate, dateToFind);
	    }

	    function onDataReady(eop, eopData) {
	        if (!defined(eopData.columnNames)) {
	            eop._dataError = 'Error in loaded EOP data: The columnNames property is required.';
	            return;
	        }

	        if (!defined(eopData.samples)) {
	            eop._dataError = 'Error in loaded EOP data: The samples property is required.';
	            return;
	        }

	        var dateColumn = eopData.columnNames.indexOf('modifiedJulianDateUtc');
	        var xPoleWanderRadiansColumn = eopData.columnNames.indexOf('xPoleWanderRadians');
	        var yPoleWanderRadiansColumn = eopData.columnNames.indexOf('yPoleWanderRadians');
	        var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf('ut1MinusUtcSeconds');
	        var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('xCelestialPoleOffsetRadians');
	        var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('yCelestialPoleOffsetRadians');
	        var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf('taiMinusUtcSeconds');

	        if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {
	            eop._dataError = 'Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns';
	            return;
	        }

	        var samples = eop._samples = eopData.samples;
	        var dates = eop._dates = [];

	        eop._dateColumn = dateColumn;
	        eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;
	        eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;
	        eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;
	        eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;
	        eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;
	        eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;

	        eop._columnCount = eopData.columnNames.length;
	        eop._lastIndex = undefined;

	        var lastTaiMinusUtc;

	        var addNewLeapSeconds = eop._addNewLeapSeconds;

	        // Convert the ISO8601 dates to JulianDates.
	        for (var i = 0, len = samples.length; i < len; i += eop._columnCount) {
	            var mjd = samples[i + dateColumn];
	            var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];
	            var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;
	            var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);
	            dates.push(date);

	            if (addNewLeapSeconds) {
	                if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {
	                    // We crossed a leap second boundary, so add the leap second
	                    // if it does not already exist.
	                    var leapSeconds = JulianDate.leapSeconds;
	                    var leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);
	                    if (leapSecondIndex < 0) {
	                        var leapSecond = new LeapSecond(date, taiMinusUtc);
	                        leapSeconds.splice(~leapSecondIndex, 0, leapSecond);
	                    }
	                }
	                lastTaiMinusUtc = taiMinusUtc;
	            }
	        }
	    }

	    function fillResultFromIndex(eop, samples, index, columnCount, result) {
	        var start = index * columnCount;
	        result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];
	        result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];
	        result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];
	        result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];
	        result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];
	    }

	    function linearInterp(dx, y1, y2) {
	        return y1 + dx * (y2 - y1);
	    }

	    function interpolate(eop, dates, samples, date, before, after, result) {
	        var columnCount = eop._columnCount;

	        // First check the bounds on the EOP data
	        // If we are after the bounds of the data, return zeros.
	        // The 'before' index should never be less than zero.
	        if (after > dates.length - 1) {
	            result.xPoleWander = 0;
	            result.yPoleWander = 0;
	            result.xPoleOffset = 0;
	            result.yPoleOffset = 0;
	            result.ut1MinusUtc = 0;
	            return result;
	        }

	        var beforeDate = dates[before];
	        var afterDate = dates[after];
	        if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {
	            fillResultFromIndex(eop, samples, before, columnCount, result);
	            return result;
	        } else if (date.equals(afterDate)) {
	            fillResultFromIndex(eop, samples, after, columnCount, result);
	            return result;
	        }

	        var factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);

	        var startBefore = before * columnCount;
	        var startAfter = after * columnCount;

	        // Handle UT1 leap second edge case
	        var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];
	        var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];

	        var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;
	        if (offsetDifference > 0.5 || offsetDifference < -0.5) {
	            // The absolute difference between the values is more than 0.5, so we may have
	            // crossed a leap second.  Check if this is the case and, if so, adjust the
	            // afterValue to account for the leap second.  This way, our interpolation will
	            // produce reasonable results.
	            var beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];
	            var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];
	            if (beforeTaiMinusUtc !== afterTaiMinusUtc) {
	                if (afterDate.equals(date)) {
	                    // If we are at the end of the leap second interval, take the second value
	                    // Otherwise, the interpolation below will yield the wrong side of the
	                    // discontinuity
	                    // At the end of the leap second, we need to start accounting for the jump
	                    beforeUt1MinusUtc = afterUt1MinusUtc;
	                } else {
	                    // Otherwise, remove the leap second so that the interpolation is correct
	                    afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;
	                }
	            }
	        }

	        result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);
	        result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);
	        result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);
	        result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);
	        result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);
	        return result;
	    }

	    return EarthOrientationParameters;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties) {
	    "use strict";

	    var _supportsFullscreen;
	    var _names = {
	        requestFullscreen : undefined,
	        exitFullscreen : undefined,
	        fullscreenEnabled : undefined,
	        fullscreenElement : undefined,
	        fullscreenchange : undefined,
	        fullscreenerror : undefined
	    };

	    /**
	     * Browser-independent functions for working with the standard fullscreen API.
	     *
	     * @namespace
	     * @alias Fullscreen
	     *
	     * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
	     */
	    var Fullscreen = {};

	    defineProperties(Fullscreen, {
	        /**
	         * The element that is currently fullscreen, if any.  To simply check if the
	         * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.
	         * @memberof Fullscreen
	         * @type {Object}
	         */
	        element : {
	            get : function() {
	                if (!Fullscreen.supportsFullscreen()) {
	                    return undefined;
	                }

	                return document[_names.fullscreenElement];
	            }
	        },

	        /**
	         * The name of the event on the document that is fired when fullscreen is
	         * entered or exited.  This event name is intended for use with addEventListener.
	         * In your event handler, to determine if the browser is in fullscreen mode or not,
	         * use {@link Fullscreen#fullscreen}.
	         * @memberof Fullscreen
	         * @type {String}
	         */
	        changeEventName : {
	            get : function() {
	                if (!Fullscreen.supportsFullscreen()) {
	                    return undefined;
	                }

	                return _names.fullscreenchange;
	            }
	        },

	        /**
	         * The name of the event that is fired when a fullscreen error
	         * occurs.  This event name is intended for use with addEventListener.
	         * @memberof Fullscreen
	         * @type {String}
	         */
	        errorEventName : {
	            get : function() {
	                if (!Fullscreen.supportsFullscreen()) {
	                    return undefined;
	                }

	                return _names.fullscreenerror;
	            }
	        },

	        /**
	         * Determine whether the browser will allow an element to be made fullscreen, or not.
	         * For example, by default, iframes cannot go fullscreen unless the containing page
	         * adds an "allowfullscreen" attribute (or prefixed equivalent).
	         * @memberof Fullscreen
	         * @type {Boolean}
	         */
	        enabled : {
	            get : function() {
	                if (!Fullscreen.supportsFullscreen()) {
	                    return undefined;
	                }

	                return document[_names.fullscreenEnabled];
	            }
	        },

	        /**
	         * Determines if the browser is currently in fullscreen mode.
	         * @memberof Fullscreen
	         * @type {Boolean}
	         */
	        fullscreen : {
	            get : function() {
	                if (!Fullscreen.supportsFullscreen()) {
	                    return undefined;
	                }

	                return Fullscreen.element !== null;
	            }
	        }
	    });

	    /**
	     * Detects whether the browser supports the standard fullscreen API.
	     *
	     * @returns <code>true</code> if the browser supports the standard fullscreen API,
	     * <code>false</code> otherwise.
	     */
	    Fullscreen.supportsFullscreen = function() {
	        if (defined(_supportsFullscreen)) {
	            return _supportsFullscreen;
	        }

	        _supportsFullscreen = false;

	        var body = document.body;
	        if (typeof body.requestFullscreen === 'function') {
	            // go with the unprefixed, standard set of names
	            _names.requestFullscreen = 'requestFullscreen';
	            _names.exitFullscreen = 'exitFullscreen';
	            _names.fullscreenEnabled = 'fullscreenEnabled';
	            _names.fullscreenElement = 'fullscreenElement';
	            _names.fullscreenchange = 'fullscreenchange';
	            _names.fullscreenerror = 'fullscreenerror';
	            _supportsFullscreen = true;
	            return _supportsFullscreen;
	        }

	        //check for the correct combination of prefix plus the various names that browsers use
	        var prefixes = ['webkit', 'moz', 'o', 'ms', 'khtml'];
	        var name;
	        for (var i = 0, len = prefixes.length; i < len; ++i) {
	            var prefix = prefixes[i];

	            // casing of Fullscreen differs across browsers
	            name = prefix + 'RequestFullscreen';
	            if (typeof body[name] === 'function') {
	                _names.requestFullscreen = name;
	                _supportsFullscreen = true;
	            } else {
	                name = prefix + 'RequestFullScreen';
	                if (typeof body[name] === 'function') {
	                    _names.requestFullscreen = name;
	                    _supportsFullscreen = true;
	                }
	            }

	            // disagreement about whether it's "exit" as per spec, or "cancel"
	            name = prefix + 'ExitFullscreen';
	            if (typeof document[name] === 'function') {
	                _names.exitFullscreen = name;
	            } else {
	                name = prefix + 'CancelFullScreen';
	                if (typeof document[name] === 'function') {
	                    _names.exitFullscreen = name;
	                }
	            }

	            // casing of Fullscreen differs across browsers
	            name = prefix + 'FullscreenEnabled';
	            if (defined(document[name])) {
	                _names.fullscreenEnabled = name;
	            } else {
	                name = prefix + 'FullScreenEnabled';
	                if (defined(document[name])) {
	                    _names.fullscreenEnabled = name;
	                }
	            }

	            // casing of Fullscreen differs across browsers
	            name = prefix + 'FullscreenElement';
	            if (defined(document[name])) {
	                _names.fullscreenElement = name;
	            } else {
	                name = prefix + 'FullScreenElement';
	                if (defined(document[name])) {
	                    _names.fullscreenElement = name;
	                }
	            }

	            // thankfully, event names are all lowercase per spec
	            name = prefix + 'fullscreenchange';
	            // event names do not have 'on' in the front, but the property on the document does
	            if (defined(document['on' + name])) {
	                //except on IE
	                if (prefix === 'ms') {
	                    name = 'MSFullscreenChange';
	                }
	                _names.fullscreenchange = name;
	            }

	            name = prefix + 'fullscreenerror';
	            if (defined(document['on' + name])) {
	                //except on IE
	                if (prefix === 'ms') {
	                    name = 'MSFullscreenError';
	                }
	                _names.fullscreenerror = name;
	            }
	        }

	        return _supportsFullscreen;
	    };

	    /**
	     * Asynchronously requests the browser to enter fullscreen mode on the given element.
	     * If fullscreen mode is not supported by the browser, does nothing.
	     *
	     * @param {Object} element The HTML element which will be placed into fullscreen mode.
	     *
	     * @example
	     * // Put the entire page into fullscreen.
	     * Cesium.Fullscreen.requestFullscreen(document.body)
	     *
	     * // Place only the Cesium canvas into fullscreen.
	     * Cesium.Fullscreen.requestFullscreen(scene.canvas)
	     */
	    Fullscreen.requestFullscreen = function(element) {
	        if (!Fullscreen.supportsFullscreen()) {
	            return;
	        }

	        element[_names.requestFullscreen]();
	    };

	    /**
	     * Asynchronously exits fullscreen mode.  If the browser is not currently
	     * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
	     */
	    Fullscreen.exitFullscreen = function() {
	        if (!Fullscreen.supportsFullscreen()) {
	            return;
	        }

	        document[_names.exitFullscreen]();
	    };

	    return Fullscreen;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(12),
	        __webpack_require__(52),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(43)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian3,
	        Cartographic,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Ellipsoid) {
	    "use strict";

	    /**
	     * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
	     * them by the {@link Ellipsoid#maximumRadius}.  This projection
	     * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carre.  It
	     * is also known as EPSG:4326.
	     *
	     * @alias GeographicProjection
	     * @constructor
	     *
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.
	     *
	     * @see WebMercatorProjection
	     */
	    var GeographicProjection = function(ellipsoid) {
	        this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	        this._semimajorAxis = this._ellipsoid.maximumRadius;
	        this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
	    };

	    defineProperties(GeographicProjection.prototype, {
	        /**
	         * Gets the {@link Ellipsoid}.
	         *
	         * @memberof GeographicProjection.prototype
	         *
	         * @type {Ellipsoid}
	         * @readonly
	         */
	        ellipsoid : {
	            get : function() {
	                return this._ellipsoid;
	            }
	        }
	    });

	    /**
	     * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
	     * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
	     * ellipsoid.  Z is the unmodified height.
	     *
	     * @param {Cartographic} cartographic The coordinates to project.
	     * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is
	     *        undefined, a new instance is created and returned.
	     * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the
	     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
	     *          created and returned.
	     */
	    GeographicProjection.prototype.project = function(cartographic, result) {
	        // Actually this is the special case of equidistant cylindrical called the plate carree
	        var semimajorAxis = this._semimajorAxis;
	        var x = cartographic.longitude * semimajorAxis;
	        var y = cartographic.latitude * semimajorAxis;
	        var z = cartographic.height;

	        if (!defined(result)) {
	            return new Cartesian3(x, y, z);
	        }

	        result.x = x;
	        result.y = y;
	        result.z = z;
	        return result;
	    };

	    /**
	     * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
	     * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
	     * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
	     *
	     * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.
	     * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is
	     *        undefined, a new instance is created and returned.
	     * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the
	     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
	     *          created and returned.
	     */
	    GeographicProjection.prototype.unproject = function(cartesian, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian)) {
	            throw new DeveloperError('cartesian is required');
	        }
	        //>>includeEnd('debug');

	        var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
	        var longitude = cartesian.x * oneOverEarthSemimajorAxis;
	        var latitude = cartesian.y * oneOverEarthSemimajorAxis;
	        var height = cartesian.z;

	        if (!defined(result)) {
	            return new Cartographic(longitude, latitude, height);
	        }

	        result.longitude = longitude;
	        result.latitude = latitude;
	        result.height = height;
	        return result;
	    };

	    return GeographicProjection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    /**
	     * Represents a Gregorian date in a more precise format than the JavaScript Date object.
	     * In addition to submillisecond precision, this object can also represent leap seconds.
	     * @alias GregorianDate
	     * @constructor
	     *
	     * @see JulianDate#toGregorianDate
	     */
	    var GregorianDate = function(year, month, day, hour, minute, second, millisecond, isLeapSecond) {
	        /**
	         * Gets or sets the year as a whole number.
	         * @type {Number}
	         */
	        this.year = year;
	        /**
	         * Gets or sets the month as a whole number with range [1, 12].
	         * @type {Number}
	         */
	        this.month = month;
	        /**
	         * Gets or sets the day of the month as a whole number starting at 1.
	         * @type {Number}
	         */
	        this.day = day;
	        /**
	         * Gets or sets the hour as a whole number with range [0, 23].
	         * @type {Number}
	         */
	        this.hour = hour;
	        /**
	         * Gets or sets the minute of the hour as a whole number with range [0, 59].
	         * @type {Number}
	         */
	        this.minute = minute;
	        /**
	         * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
	         * @type {Number}
	         */
	        this.second = second;
	        /**
	         * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).
	         * @type {Number}
	         */
	        this.millisecond = millisecond;
	        /**
	         * Gets or sets whether this time is during a leap second.
	         * @type {Boolean}
	         */
	        this.isLeapSecond = isLeapSecond;
	    };

	    return GregorianDate;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(47),
	        __webpack_require__(172),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(121),
	        __webpack_require__(16),
	        __webpack_require__(79),
	        __webpack_require__(78)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        when,
	        buildModuleUrl,
	        defaultValue,
	        defined,
	        Iau2006XysSample,
	        JulianDate,
	        loadJson,
	        TimeStandard) {
	    "use strict";

	    /**
	     * A set of IAU2006 XYS data that is used to evaluate the transformation between the International
	     * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).
	     *
	     * @alias Iau2006XysData
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {String} [options.xysFileUrlTemplate='Assets/IAU2006_XYS/IAU2006_XYS_{0}.json'] A template URL for obtaining the XYS data.  In the template,
	     *                 `{0}` will be replaced with the file index.
	     * @param {Number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.
	     * @param {Number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the
	     *                 first XYS sample.
	     * @param {Number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.
	     * @param {Number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.
	     * @param {Number} [options.totalSamples=27426] The total number of samples in all XYS files.
	     *
	     * @private
	     */
	    var Iau2006XysData = function Iau2006XysData(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        this._xysFileUrlTemplate = options.xysFileUrlTemplate;
	        this._interpolationOrder = defaultValue(options.interpolationOrder, 9);
	        this._sampleZeroJulianEphemerisDate = defaultValue(options.sampleZeroJulianEphemerisDate, 2442396.5);
	        this._sampleZeroDateTT = new JulianDate(this._sampleZeroJulianEphemerisDate, 0.0, TimeStandard.TAI);
	        this._stepSizeDays = defaultValue(options.stepSizeDays, 1.0);
	        this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);
	        this._totalSamples = defaultValue(options.totalSamples, 27426);
	        this._samples = new Array(this._totalSamples * 3);
	        this._chunkDownloadsInProgress = [];

	        var order = this._interpolationOrder;

	        // Compute denominators and X values for interpolation.
	        var denom = this._denominators = new Array(order + 1);
	        var xTable = this._xTable = new Array(order + 1);

	        var stepN = Math.pow(this._stepSizeDays, order);

	        for ( var i = 0; i <= order; ++i) {
	            denom[i] = stepN;
	            xTable[i] = i * this._stepSizeDays;

	            for ( var j = 0; j <= order; ++j) {
	                if (j !== i) {
	                    denom[i] *= (i - j);
	                }
	            }

	            denom[i] = 1.0 / denom[i];
	        }

	        // Allocate scratch arrays for interpolation.
	        this._work = new Array(order + 1);
	        this._coef = new Array(order + 1);
	    };

	    var julianDateScratch = new JulianDate(0, 0.0, TimeStandard.TAI);

	    function getDaysSinceEpoch(xys, dayTT, secondTT) {
	        var dateTT = julianDateScratch;
	        dateTT.dayNumber = dayTT;
	        dateTT.secondsOfDay = secondTT;
	        return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);
	    }

	    /**
	     * Preloads XYS data for a specified date range.
	     *
	     * @param {Number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in
	     *                 the Terrestrial Time (TT) time standard.
	     * @param {Number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in
	     *                 the Terrestrial Time (TT) time standard.
	     * @param {Number} stopDayTT The Julian day number of the end of the interval to preload, expressed in
	     *                 the Terrestrial Time (TT) time standard.
	     * @param {Number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in
	     *                 the Terrestrial Time (TT) time standard.
	     * @returns {Promise} A promise that, when resolved, indicates that the requested interval has been
	     *                    preloaded.
	     */
	    Iau2006XysData.prototype.preload = function(startDayTT, startSecondTT, stopDayTT, stopSecondTT) {
	        var startDaysSinceEpoch = getDaysSinceEpoch(this, startDayTT, startSecondTT);
	        var stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);

	        var startIndex = (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0;
	        if (startIndex < 0) {
	            startIndex = 0;
	        }

	        var stopIndex = (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0 + this._interpolationOrder;
	        if (stopIndex >= this._totalSamples) {
	            stopIndex = this._totalSamples - 1;
	        }

	        var startChunk = (startIndex / this._samplesPerXysFile) | 0;
	        var stopChunk = (stopIndex / this._samplesPerXysFile) | 0;

	        var promises = [];
	        for ( var i = startChunk; i <= stopChunk; ++i) {
	            promises.push(requestXysChunk(this, i));
	        }

	        return when.all(promises);
	    };

	    /**
	     * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,
	     * this method will return undefined.
	     *
	     * @param {Number} dayTT The Julian day number for which to compute the XYS value, expressed in
	     *                 the Terrestrial Time (TT) time standard.
	     * @param {Number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in
	     *                 the Terrestrial Time (TT) time standard.
	     * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter
	     *                           is undefined, a new instance is allocated and returned.
	     * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this
	     *                             computation has not yet been downloaded.
	     *
	     * @see Iau2006XysData#preload
	     */
	    Iau2006XysData.prototype.computeXysRadians = function(dayTT, secondTT, result) {
	        var daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);
	        if (daysSinceEpoch < 0.0) {
	            // Can't evaluate prior to the epoch of the data.
	            return undefined;
	        }

	        var centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;
	        if (centerIndex >= this._totalSamples) {
	            // Can't evaluate after the last sample in the data.
	            return undefined;
	        }

	        var degree = this._interpolationOrder;

	        var firstIndex = centerIndex - ((degree / 2) | 0);
	        if (firstIndex < 0) {
	            firstIndex = 0;
	        }
	        var lastIndex = firstIndex + degree;
	        if (lastIndex >= this._totalSamples) {
	            lastIndex = this._totalSamples - 1;
	            firstIndex = lastIndex - degree;
	            if (firstIndex < 0) {
	                firstIndex = 0;
	            }
	        }

	        // Are all the samples we need present?
	        // We can assume so if the first and last are present
	        var isDataMissing = false;
	        var samples = this._samples;
	        if (!defined(samples[firstIndex * 3])) {
	            requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);
	            isDataMissing = true;
	        }

	        if (!defined(samples[lastIndex * 3])) {
	            requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);
	            isDataMissing = true;
	        }

	        if (isDataMissing) {
	            return undefined;
	        }

	        if (!defined(result)) {
	            result = new Iau2006XysSample(0.0, 0.0, 0.0);
	        } else {
	            result.x = 0.0;
	            result.y = 0.0;
	            result.s = 0.0;
	        }

	        var x = daysSinceEpoch - firstIndex * this._stepSizeDays;

	        var work = this._work;
	        var denom = this._denominators;
	        var coef = this._coef;
	        var xTable = this._xTable;

	        var i, j;
	        for (i = 0; i <= degree; ++i) {
	            work[i] = x - xTable[i];
	        }

	        for (i = 0; i <= degree; ++i) {
	            coef[i] = 1.0;

	            for (j = 0; j <= degree; ++j) {
	                if (j !== i) {
	                    coef[i] *= work[j];
	                }
	            }

	            coef[i] *= denom[i];

	            var sampleIndex = (firstIndex + i) * 3;
	            result.x += coef[i] * samples[sampleIndex++];
	            result.y += coef[i] * samples[sampleIndex++];
	            result.s += coef[i] * samples[sampleIndex];
	        }

	        return result;
	    };

	    function requestXysChunk(xysData, chunkIndex) {
	        if (xysData._chunkDownloadsInProgress[chunkIndex]) {
	            // Chunk has already been requested.
	            return xysData._chunkDownloadsInProgress[chunkIndex];
	        }

	        var deferred = when.defer();

	        xysData._chunkDownloadsInProgress[chunkIndex] = deferred;

	        var chunkUrl;
	        var xysFileUrlTemplate = xysData._xysFileUrlTemplate;
	        if (defined(xysFileUrlTemplate)) {
	            chunkUrl = xysFileUrlTemplate.replace('{0}', chunkIndex);
	        } else {
	            chunkUrl = buildModuleUrl('Assets/IAU2006_XYS/IAU2006_XYS_' + chunkIndex + '.json');
	        }

	        when(loadJson(chunkUrl), function(chunk) {
	            xysData._chunkDownloadsInProgress[chunkIndex] = false;

	            var samples = xysData._samples;
	            var newSamples = chunk.samples;
	            var startIndex = chunkIndex * xysData._samplesPerXysFile * 3;

	            for ( var i = 0, len = newSamples.length; i < len; ++i) {
	                samples[startIndex + i] = newSamples[i];
	            }

	            deferred.resolve();
	        });

	        return deferred.promise;
	    }

	    return Iau2006XysData;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * This enumerated type is used in determining where, relative to the frustum, an
	     * object is located. The object can either be fully contained within the frustum (INSIDE),
	     * partially inside the frustum and partially outside (INTERSECTING), or somwhere entirely
	     * outside of the frustum's 6 planes (OUTSIDE).
	     *
	     * @namespace
	     * @alias Intersect
	     */
	    var Intersect = {
	        /**
	         * Represents that an object is not contained within the frustum.
	         *
	         * @type {Number}
	         * @constant
	         */
	        OUTSIDE : -1,

	        /**
	         * Represents that an object intersects one of the frustum's planes.
	         *
	         * @type {Number}
	         * @constant
	         */
	        INTERSECTING : 0,

	        /**
	         * Represents that an object is fully within the frustum.
	         *
	         * @type {Number}
	         * @constant
	         */
	        INSIDE : 1
	    };

	    return freezeObject(Intersect);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined) {
	    "use strict";

	    /**
	     * An {@link InterpolationAlgorithm} for performing Lagrange interpolation.
	     *
	     * @namespace
	     * @alias LagrangePolynomialApproximation
	     */
	    var LagrangePolynomialApproximation = {
	        type : 'Lagrange'
	    };

	    /**
	     * Given the desired degree, returns the number of data points required for interpolation.
	     *
	     * @param {Number} degree The desired degree of interpolation.
	     * @returns The number of required data points needed for the desired degree of interpolation.
	     */
	    LagrangePolynomialApproximation.getRequiredDataPoints = function(degree) {
	        return Math.max(degree + 1.0, 2);
	    };

	    /**
	     * Interpolates values using Lagrange Polynomial Approximation.
	     *
	     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
	     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
	     * in this array must be in increasing order and the same value must not occur twice in the array.
	     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
	     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
	     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
	     * each independent variable value in xTable.
	     * @param {Number[]} [result] An existing array into which to store the result.
	     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
	     */
	    LagrangePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {
	        if (!defined(result)) {
	            result = new Array(yStride);
	        }

	        var i;
	        var j;
	        var length = xTable.length;

	        for (i = 0; i < yStride; i++) {
	            result[i] = 0;
	        }

	        for (i = 0; i < length; i++) {
	            var coefficient = 1;

	            for (j = 0; j < length; j++) {
	                if (j !== i) {
	                    var diffX = xTable[i] - xTable[j];
	                    coefficient *= (x - xTable[j]) / diffX;
	                }
	            }

	            for (j = 0; j < yStride; j++) {
	                result[j] += coefficient * yTable[i * yStride + j];
	            }
	        }

	        return result;
	    };

	    return LagrangePolynomialApproximation;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(52),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(43),
	        __webpack_require__(7),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartographic,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Ellipsoid,
	        freezeObject,
	        CesiumMath) {
	    "use strict";

	    /**
	     * A two dimensional region specified as longitude and latitude coordinates.
	     *
	     * @alias Rectangle
	     * @constructor
	     *
	     * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].
	     * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].
	     * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].
	     * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].
	     *
	     * @see Packable
	     */
	    var Rectangle = function(west, south, east, north) {
	        /**
	         * The westernmost longitude in radians in the range [-Pi, Pi].
	         *
	         * @type {Number}
	         * @default 0.0
	         */
	        this.west = defaultValue(west, 0.0);

	        /**
	         * The southernmost latitude in radians in the range [-Pi/2, Pi/2].
	         *
	         * @type {Number}
	         * @default 0.0
	         */
	        this.south = defaultValue(south, 0.0);

	        /**
	         * The easternmost longitude in radians in the range [-Pi, Pi].
	         *
	         * @type {Number}
	         * @default 0.0
	         */
	        this.east = defaultValue(east, 0.0);

	        /**
	         * The northernmost latitude in radians in the range [-Pi/2, Pi/2].
	         *
	         * @type {Number}
	         * @default 0.0
	         */
	        this.north = defaultValue(north, 0.0);
	    };

	    defineProperties(Rectangle.prototype, {
	        /**
	         * Gets the width of the rectangle in radians.
	         * @memberof Rectangle.prototype
	         * @type {Number}
	         */
	        width : {
	            get : function() {
	                return Rectangle.computeWidth(this);
	            }
	        },

	        /**
	         * Gets the height of the rectangle in radians.
	         * @memberof Rectangle.prototype
	         * @type {Number}
	         */
	        height : {
	            get : function() {
	                return Rectangle.computeHeight(this);
	            }
	        }
	    });

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Rectangle.packedLength = 4;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {BoundingSphere} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Rectangle.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }

	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value.west;
	        array[startingIndex++] = value.south;
	        array[startingIndex++] = value.east;
	        array[startingIndex] = value.north;
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Rectangle} [result] The object into which to store the result.
	     */
	    Rectangle.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Rectangle();
	        }

	        result.west = array[startingIndex++];
	        result.south = array[startingIndex++];
	        result.east = array[startingIndex++];
	        result.north = array[startingIndex];
	        return result;
	    };

	    /**
	     * Computes the width of a rectangle in radians.
	     * @param {Rectangle} rectangle The rectangle to compute the width of.
	     * @returns {Number} The width.
	     */
	    Rectangle.computeWidth = function(rectangle) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required.');
	        }
	        //>>includeEnd('debug');
	        var east = rectangle.east;
	        var west = rectangle.west;
	        if (east < west) {
	            east += CesiumMath.TWO_PI;
	        }
	        return east - west;
	    };

	    /**
	     * Computes the height of a rectangle in radians.
	     * @param {Rectangle} rectangle The rectangle to compute the height of.
	     * @returns {Number} The height.
	     */
	    Rectangle.computeHeight = function(rectangle) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required.');
	        }
	        //>>includeEnd('debug');
	        return rectangle.north - rectangle.south;
	    };

	    /**
	     * Creates an rectangle given the boundary longitude and latitude in degrees.
	     *
	     * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].
	     * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].
	     * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].
	     * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].
	     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	     *
	     * @example
	     * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);
	     */
	    Rectangle.fromDegrees = function(west, south, east, north, result) {
	        west = CesiumMath.toRadians(defaultValue(west, 0.0));
	        south = CesiumMath.toRadians(defaultValue(south, 0.0));
	        east = CesiumMath.toRadians(defaultValue(east, 0.0));
	        north = CesiumMath.toRadians(defaultValue(north, 0.0));

	        if (!defined(result)) {
	            return new Rectangle(west, south, east, north);
	        }

	        result.west = west;
	        result.south = south;
	        result.east = east;
	        result.north = north;

	        return result;
	    };

	    /**
	     * Creates the smallest possible Rectangle that encloses all positions in the provided array.
	     *
	     * @param {Cartographic[]} cartographics The list of Cartographic instances.
	     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	     */
	    Rectangle.fromCartographicArray = function(cartographics, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartographics)) {
	            throw new DeveloperError('cartographics is required.');
	        }
	        //>>includeEnd('debug');

	        var minLon = Number.MAX_VALUE;
	        var maxLon = -Number.MAX_VALUE;
	        var minLat = Number.MAX_VALUE;
	        var maxLat = -Number.MAX_VALUE;

	        for ( var i = 0, len = cartographics.length; i < len; i++) {
	            var position = cartographics[i];
	            minLon = Math.min(minLon, position.longitude);
	            maxLon = Math.max(maxLon, position.longitude);
	            minLat = Math.min(minLat, position.latitude);
	            maxLat = Math.max(maxLat, position.latitude);
	        }

	        if (!defined(result)) {
	            return new Rectangle(minLon, minLat, maxLon, maxLat);
	        }

	        result.west = minLon;
	        result.south = minLat;
	        result.east = maxLon;
	        result.north = maxLat;
	        return result;
	    };

	    /**
	     * The number of elements used to pack the object into an array.
	     * @type {Number}
	     */
	    Rectangle.packedLength = 4;

	    /**
	     * Stores the provided instance into the provided array.
	     *
	     * @param {Rectangle} value The value to pack.
	     * @param {Number[]} array The array to pack into.
	     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
	     */
	    Rectangle.pack = function(value, array, startingIndex) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(value)) {
	            throw new DeveloperError('value is required');
	        }

	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        array[startingIndex++] = value.west;
	        array[startingIndex++] = value.south;
	        array[startingIndex++] = value.east;
	        array[startingIndex] = value.north;
	    };

	    /**
	     * Retrieves an instance from a packed array.
	     *
	     * @param {Number[]} array The packed array.
	     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
	     * @param {Rectangle} [result] The object into which to store the result.
	     */
	    Rectangle.unpack = function(array, startingIndex, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(array)) {
	            throw new DeveloperError('array is required');
	        }
	        //>>includeEnd('debug');

	        startingIndex = defaultValue(startingIndex, 0);

	        if (!defined(result)) {
	            result = new Rectangle();
	        }
	        result.west = array[startingIndex++];
	        result.south = array[startingIndex++];
	        result.east = array[startingIndex++];
	        result.north = array[startingIndex];
	        return result;
	    };

	    /**
	     * Duplicates an Rectangle.
	     *
	     * @param {Rectangle} rectangle The rectangle to clone.
	     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
	     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)
	     */
	    Rectangle.clone = function(rectangle, result) {
	        if (!defined(rectangle)) {
	            return undefined;
	        }

	        if (!defined(result)) {
	            return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);
	        }

	        result.west = rectangle.west;
	        result.south = rectangle.south;
	        result.east = rectangle.east;
	        result.north = rectangle.north;
	        return result;
	    };

	    /**
	     * Duplicates this Rectangle.
	     *
	     * @param {Rectangle} [result] The object onto which to store the result.
	     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
	     */
	    Rectangle.prototype.clone = function(result) {
	        return Rectangle.clone(this, result);
	    };

	    /**
	     * Compares the provided Rectangle with this Rectangle componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Rectangle} [other] The Rectangle to compare.
	     * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.
	     */
	    Rectangle.prototype.equals = function(other) {
	        return Rectangle.equals(this, other);
	    };

	    /**
	     * Compares the provided rectangles and returns <code>true</code> if they are equal,
	     * <code>false</code> otherwise.
	     *
	     * @param {Rectangle} [left] The first Rectangle.
	     * @param {Rectangle} [right] The second Rectangle.
	     * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.
	     */
	    Rectangle.equals = function(left, right) {
	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (left.west === right.west) &&
	                (left.south === right.south) &&
	                (left.east === right.east) &&
	                (left.north === right.north));
	    };

	    /**
	     * Compares the provided Rectangle with this Rectangle componentwise and returns
	     * <code>true</code> if they are within the provided epsilon,
	     * <code>false</code> otherwise.
	     *
	     * @param {Rectangle} [other] The Rectangle to compare.
	     * @param {Number} epsilon The epsilon to use for equality testing.
	     * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.
	     */
	    Rectangle.prototype.equalsEpsilon = function(other, epsilon) {
	        //>>includeStart('debug', pragmas.debug);
	        if (typeof epsilon !== 'number') {
	            throw new DeveloperError('epsilon is required and must be a number.');
	        }
	        //>>includeEnd('debug');

	        return defined(other) &&
	               (Math.abs(this.west - other.west) <= epsilon) &&
	               (Math.abs(this.south - other.south) <= epsilon) &&
	               (Math.abs(this.east - other.east) <= epsilon) &&
	               (Math.abs(this.north - other.north) <= epsilon);
	    };

	    /**
	     * Checks an Rectangle's properties and throws if they are not in valid ranges.
	     *
	     * @param {Rectangle} rectangle The rectangle to validate
	     *
	     * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	     * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	     * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	     * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	     */
	    Rectangle.validate = function(rectangle) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }

	        var north = rectangle.north;
	        if (typeof north !== 'number') {
	            throw new DeveloperError('north is required to be a number.');
	        }

	        if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO) {
	            throw new DeveloperError('north must be in the interval [-Pi/2, Pi/2].');
	        }

	        var south = rectangle.south;
	        if (typeof south !== 'number') {
	            throw new DeveloperError('south is required to be a number.');
	        }

	        if (south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {
	            throw new DeveloperError('south must be in the interval [-Pi/2, Pi/2].');
	        }

	        var west = rectangle.west;
	        if (typeof west !== 'number') {
	            throw new DeveloperError('west is required to be a number.');
	        }

	        if (west < -Math.PI || west > Math.PI) {
	            throw new DeveloperError('west must be in the interval [-Pi, Pi].');
	        }

	        var east = rectangle.east;
	        if (typeof east !== 'number') {
	            throw new DeveloperError('east is required to be a number.');
	        }

	        if (east < -Math.PI || east > Math.PI) {
	            throw new DeveloperError('east must be in the interval [-Pi, Pi].');
	        }
	        //>>includeEnd('debug');
	    };

	    /**
	     * Computes the southwest corner of an rectangle.
	     *
	     * @param {Rectangle} rectangle The rectangle for which to find the corner
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	     */
	    Rectangle.southwest = function(rectangle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Cartographic(rectangle.west, rectangle.south);
	        }
	        result.longitude = rectangle.west;
	        result.latitude = rectangle.south;
	        result.height = 0.0;
	        return result;
	    };

	    /**
	     * Computes the northwest corner of an rectangle.
	     *
	     * @param {Rectangle} rectangle The rectangle for which to find the corner
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	     */
	    Rectangle.northwest = function(rectangle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Cartographic(rectangle.west, rectangle.north);
	        }
	        result.longitude = rectangle.west;
	        result.latitude = rectangle.north;
	        result.height = 0.0;
	        return result;
	    };

	    /**
	     * Computes the northeast corner of an rectangle.
	     *
	     * @param {Rectangle} rectangle The rectangle for which to find the corner
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	     */
	    Rectangle.northeast = function(rectangle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Cartographic(rectangle.east, rectangle.north);
	        }
	        result.longitude = rectangle.east;
	        result.latitude = rectangle.north;
	        result.height = 0.0;
	        return result;
	    };

	    /**
	     * Computes the southeast corner of an rectangle.
	     *
	     * @param {Rectangle} rectangle The rectangle for which to find the corner
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	     */
	    Rectangle.southeast = function(rectangle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Cartographic(rectangle.east, rectangle.south);
	        }
	        result.longitude = rectangle.east;
	        result.latitude = rectangle.south;
	        result.height = 0.0;
	        return result;
	    };

	    /**
	     * Computes the center of an rectangle.
	     *
	     * @param {Rectangle} rectangle The rectangle for which to find the center
	     * @param {Cartographic} [result] The object onto which to store the result.
	     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
	     */
	    Rectangle.center = function(rectangle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        //>>includeEnd('debug');

	        var east = rectangle.east;
	        var west = rectangle.west;

	        if (east < west) {
	            east += CesiumMath.TWO_PI;
	        }

	        var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);
	        var latitude = (rectangle.south + rectangle.north) * 0.5;

	        if (!defined(result)) {
	            return new Cartographic(longitude, latitude);
	        }

	        result.longitude = longitude;
	        result.latitude = latitude;
	        result.height = 0.0;
	        return result;
	    };

	    /**
	     * Computes the intersection of two rectangles
	     *
	     * @param {Rectangle} rectangle On rectangle to find an intersection
	     * @param {Rectangle} otherRectangle Another rectangle to find an intersection
	     * @param {Rectangle} [result] The object onto which to store the result.
	     * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
	     */
	    Rectangle.intersection = function(rectangle, otherRectangle, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        if (!defined(otherRectangle)) {
	            throw new DeveloperError('otherRectangle is required.');
	        }
	        //>>includeEnd('debug');

	        var rectangleEast = rectangle.east;
	        var rectangleWest = rectangle.west;

	        var otherRectangleEast = otherRectangle.east;
	        var otherRectangleWest = otherRectangle.west;

	        if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {
	            rectangleEast += CesiumMath.TWO_PI;
	        } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {
	            otherRectangleEast += CesiumMath.TWO_PI;
	        }

	        if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {
	            otherRectangleWest += CesiumMath.TWO_PI;
	        } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {
	            rectangleWest += CesiumMath.TWO_PI;
	        }

	        var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));
	        var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));

	        if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {
	            return undefined;
	        }

	        var south = Math.max(rectangle.south, otherRectangle.south);
	        var north = Math.min(rectangle.north, otherRectangle.north);

	        if (south >= north) {
	            return undefined;
	        }

	        if (!defined(result)) {
	            return new Rectangle(west, south, east, north);
	        }
	        result.west = west;
	        result.south = south;
	        result.east = east;
	        result.north = north;
	        return result;
	    };

	    /**
	     * Returns true if the cartographic is on or inside the rectangle, false otherwise.
	     *
	     * @param {Rectangle} rectangle The rectangle
	     * @param {Cartographic} cartographic The cartographic to test.
	     * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.
	     */
	    Rectangle.contains = function(rectangle, cartographic) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        if (!defined(cartographic)) {
	            throw new DeveloperError('cartographic is required.');
	        }
	        //>>includeEnd('debug');

	        var longitude = cartographic.longitude;
	        var latitude = cartographic.latitude;

	        var west = rectangle.west;
	        var east = rectangle.east;

	        if (east < west) {
	            east += CesiumMath.TWO_PI;
	            if (longitude < 0.0) {
	                longitude += CesiumMath.TWO_PI;
	            }
	        }
	        return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&
	               (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&
	               latitude >= rectangle.south &&
	               latitude <= rectangle.north;
	    };

	    var subsampleLlaScratch = new Cartographic();
	    /**
	     * Samples an rectangle so that it includes a list of Cartesian points suitable for passing to
	     * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account
	     * for rectangles that cover the poles or cross the equator.
	     *
	     * @param {Rectangle} rectangle The rectangle to subsample.
	     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.
	     * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.
	     * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.
	     * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.
	     */
	    Rectangle.subsample = function(rectangle, ellipsoid, surfaceHeight, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(rectangle)) {
	            throw new DeveloperError('rectangle is required');
	        }
	        //>>includeEnd('debug');

	        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
	        surfaceHeight = defaultValue(surfaceHeight, 0.0);

	        if (!defined(result)) {
	            result = [];
	        }
	        var length = 0;

	        var north = rectangle.north;
	        var south = rectangle.south;
	        var east = rectangle.east;
	        var west = rectangle.west;

	        var lla = subsampleLlaScratch;
	        lla.height = surfaceHeight;

	        lla.longitude = west;
	        lla.latitude = north;
	        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	        length++;

	        lla.longitude = east;
	        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	        length++;

	        lla.latitude = south;
	        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	        length++;

	        lla.longitude = west;
	        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	        length++;

	        if (north < 0.0) {
	            lla.latitude = north;
	        } else if (south > 0.0) {
	            lla.latitude = south;
	        } else {
	            lla.latitude = 0.0;
	        }

	        for ( var i = 1; i < 8; ++i) {
	            lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;
	            if (Rectangle.contains(rectangle, lla)) {
	                result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	                length++;
	            }
	        }

	        if (lla.latitude === 0.0) {
	            lla.longitude = west;
	            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	            length++;
	            lla.longitude = east;
	            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
	            length++;
	        }
	        result.length = length;
	        return result;
	    };

	    /**
	     * The largest possible rectangle.
	     *
	     * @type {Rectangle}
	     * @constant
	    */
	    Rectangle.MAX_VALUE = freezeObject(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));

	    return Rectangle;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(180)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        parseResponseHeaders) {
	    "use strict";

	    /**
	     * An event that is raised when a request encounters an error.
	     *
	     * @constructor
	     * @alias RequestErrorEvent
	     *
	     * @param {Number} [statusCode] The HTTP error status code, such as 404.
	     * @param {Object} [response] The response included along with the error.
	     * @param {String|Object} [responseHeaders] The response headers, represented either as an object literal or as a
	     *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.
	     */
	    var RequestErrorEvent = function RequestErrorEvent(statusCode, response, responseHeaders) {
	        /**
	         * The HTTP error status code, such as 404.  If the error does not have a particular
	         * HTTP code, this property will be undefined.
	         *
	         * @type {Number}
	         */
	        this.statusCode = statusCode;

	        /**
	         * The response included along with the error.  If the error does not include a response,
	         * this property will be undefined.
	         *
	         * @type {Object}
	         */
	        this.response = response;

	        /**
	         * The headers included in the response, represented as an object literal of key/value pairs.
	         * If the error does not include any headers, this property will be undefined.
	         *
	         * @type {Object}
	         */
	        this.responseHeaders = responseHeaders;

	        if (typeof this.responseHeaders === 'string') {
	            this.responseHeaders = parseResponseHeaders(this.responseHeaders);
	        }
	    };

	    /**
	     * Creates a string representing this RequestErrorEvent.
	     * @memberof RequestErrorEvent
	     *
	     * @returns {String} A string representing the provided RequestErrorEvent.
	     */
	    RequestErrorEvent.prototype.toString = function() {
	        var str = 'Request has failed.';
	        if (defined(this.statusCode)) {
	            str += ' Status Code: ' + this.statusCode;
	        }
	        return str;
	    };

	    return RequestErrorEvent;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError) {
	    "use strict";

	    /**
	     * A set of curvilinear 3-dimensional coordinates.
	     *
	     * @alias Spherical
	     * @constructor
	     *
	     * @param {Number} [clock=0.0] The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
	     * @param {Number} [cone=0.0] The angular coordinate measured from the positive z-axis and toward the negative z-axis.
	     * @param {Number} [magnitude=1.0] The linear coordinate measured from the origin.
	     */
	    var Spherical = function(clock, cone, magnitude) {
	        this.clock = defaultValue(clock, 0.0);
	        this.cone = defaultValue(cone, 0.0);
	        this.magnitude = defaultValue(magnitude, 1.0);
	    };

	    /**
	     * Converts the provided Cartesian3 into Spherical coordinates.
	     *
	     * @param {Cartesian3} cartesian3 The Cartesian3 to be converted to Spherical.
	     * @param {Spherical} [spherical] The object in which the result will be stored, if undefined a new instance will be created.
	     * @returns The modified result parameter, or a new instance if one was not provided.
	     */
	    Spherical.fromCartesian3 = function(cartesian3, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(cartesian3)) {
	            throw new DeveloperError('cartesian3 is required');
	        }
	        //>>includeEnd('debug');

	        var x = cartesian3.x;
	        var y = cartesian3.y;
	        var z = cartesian3.z;
	        var radialSquared = x * x + y * y;

	        if (!defined(result)) {
	            result = new Spherical();
	        }

	        result.clock = Math.atan2(y, x);
	        result.cone = Math.atan2(Math.sqrt(radialSquared), z);
	        result.magnitude = Math.sqrt(radialSquared + z * z);
	        return result;
	    };

	    /**
	     * Creates a duplicate of a Spherical.
	     *
	     * @param {Spherical} spherical The spherical to clone.
	     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
	     * @returns The modified result parameter or a new instance if result was undefined. (Returns undefined if spherical is undefined)
	     */
	    Spherical.clone = function(spherical, result) {
	        if (!defined(spherical)) {
	            return undefined;
	        }

	        if (!defined(result)) {
	            return new Spherical(spherical.clock, spherical.cone, spherical.magnitude);
	        }

	        result.clock = spherical.clock;
	        result.cone = spherical.cone;
	        result.magnitude = spherical.magnitude;
	        return result;
	    };

	    /**
	     * Computes the normalized version of the provided spherical.
	     *
	     * @param {Spherical} spherical The spherical to be normalized.
	     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
	     * @returns The modified result parameter or a new instance if result was undefined.
	     */
	    Spherical.normalize = function(spherical, result) {
	      //>>includeStart('debug', pragmas.debug);
	        if (!defined(spherical)) {
	            throw new DeveloperError('spherical is required');
	        }
	        //>>includeEnd('debug');

	        if (!defined(result)) {
	            return new Spherical(spherical.clock, spherical.cone, 1.0);
	        }

	        result.clock = spherical.clock;
	        result.cone = spherical.cone;
	        result.magnitude = 1.0;
	        return result;
	    };

	    /**
	     * Returns true if the first spherical is equal to the second spherical, false otherwise.
	     *
	     * @param {Spherical} left The first Spherical to be compared.
	     * @param {Spherical} right The second Spherical to be compared.
	     * @returns true if the first spherical is equal to the second spherical, false otherwise.
	     */
	    Spherical.equals = function(left, right) {
	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (left.clock === right.clock) &&
	                (left.cone === right.cone) &&
	                (left.magnitude === right.magnitude));
	    };

	    /**
	     * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
	     *
	     * @param {Spherical} left The first Spherical to be compared.
	     * @param {Spherical} right The second Spherical to be compared.
	     * @param {Number} [epsilon=0.0] The epsilon to compare against.
	     * @returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
	     */
	    Spherical.equalsEpsilon = function(left, right, epsilon) {
	        epsilon = defaultValue(epsilon, 0.0);
	        return (left === right) ||
	               ((defined(left)) &&
	                (defined(right)) &&
	                (Math.abs(left.clock - right.clock) <= epsilon) &&
	                (Math.abs(left.cone - right.cone) <= epsilon) &&
	                (Math.abs(left.magnitude - right.magnitude) <= epsilon));
	    };

	    /**
	     * Returns true if this spherical is equal to the provided spherical, false otherwise.
	     *
	     * @param {Spherical} other The Spherical to be compared.
	     * @returns true if this spherical is equal to the provided spherical, false otherwise.
	     */
	    Spherical.prototype.equals = function(other) {
	        return Spherical.equals(this, other);
	    };

	    /**
	     * Creates a duplicate of this Spherical.
	     *
	     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
	     * @returns The modified result parameter or a new instance if result was undefined.
	     */
	    Spherical.prototype.clone = function(result) {
	        return Spherical.clone(this, result);
	    };

	    /**
	    * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
	    *
	    * @param {Spherical} other The Spherical to be compared.
	    * @param {Number} epsilon The epsilon to compare against.
	    * @returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
	    */
	    Spherical.prototype.equalsEpsilon = function(other, epsilon) {
	        return Spherical.equalsEpsilon(this, other, epsilon);
	    };

	    /**
	    * Returns a string representing this instance in the format (clock, cone, magnitude).
	    *
	    * @returns A string representing this instance.
	    */
	    Spherical.prototype.toString = function() {
	        return '(' + this.clock + ', ' + this.cone + ', ' + this.magnitude + ')';
	    };

	    return Spherical;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(85),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Uri,
	        defined,
	        DeveloperError,
	        require) {
	    "use strict";
	    /*global CESIUM_BASE_URL*/

	    var cesiumScriptRegex = /((?:.*\/)|^)cesium[\w-]*\.js(?:\W|$)/i;
	    function getBaseUrlFromCesiumScript() {
	        var scripts = document.getElementsByTagName('script');
	        for ( var i = 0, len = scripts.length; i < len; ++i) {
	            var src = scripts[i].getAttribute('src');
	            var result = cesiumScriptRegex.exec(src);
	            if (result !== null) {
	                return result[1];
	            }
	        }
	        return undefined;
	    }

	    var baseUrl;
	    function getCesiumBaseUrl() {
	        if (defined(baseUrl)) {
	            return baseUrl;
	        }

	        var baseUrlString;
	        if (typeof CESIUM_BASE_URL !== 'undefined') {
	            baseUrlString = CESIUM_BASE_URL;
	        } else {
	            baseUrlString = getBaseUrlFromCesiumScript();
	        }

	        if (!defined(baseUrlString)) {
	            throw new DeveloperError('Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.');
	        }

	        baseUrl = new Uri(baseUrlString).resolve(new Uri(document.location.href));

	        return baseUrl;
	    }

	    function buildModuleUrlFromRequireToUrl(moduleID) {
	        //moduleID will be non-relative, so require it relative to this module, in Core.
	        return !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()).toUrl('../' + moduleID);
	    }

	    function buildModuleUrlFromBaseUrl(moduleID) {
	        return new Uri(moduleID).resolve(getCesiumBaseUrl()).toString();
	    }

	    var implementation;
	    var a;

	    /**
	     * Given a non-relative moduleID, returns an absolute URL to the file represented by that module ID,
	     * using, in order of preference, require.toUrl, the value of a global CESIUM_BASE_URL, or
	     * the base URL of the Cesium.js script.
	     *
	     * @private
	     */
	    var buildModuleUrl = function(moduleID) {
	        if (!defined(implementation)) {
	            //select implementation
	            if (defined(!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()).toUrl)) {
	                implementation = buildModuleUrlFromRequireToUrl;
	            } else {
	                implementation = buildModuleUrlFromBaseUrl;
	            }
	        }

	        if (!defined(a)) {
	            a = document.createElement('a');
	        }

	        var url = implementation(moduleID);

	        a.href = url;
	        a.href = a.href; // IE only absolutizes href on get, not set

	        return a.href;
	    };

	    // exposed for testing
	    buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;

	    return buildModuleUrl;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue) {
	    "use strict";

	    /**
	     * Clones an object, returning a new object containing the same properties.
	     *
	     * @exports clone
	     *
	     * @param {Object} object The object to clone.
	     * @param {Boolean} [deep=false] If true, all properties will be deep cloned recursively.
	     */
	    var clone = function(object, deep) {
	        if (object === null || typeof object !== 'object') {
	            return object;
	        }

	        deep = defaultValue(deep, false);

	        var result = new object.constructor();
	        for ( var propertyName in object) {
	            if (object.hasOwnProperty(propertyName)) {
	                var value = object[propertyName];
	                if (deep) {
	                    value = clone(value, deep);
	                }
	                result[propertyName] = value;
	            }
	        }

	        return result;
	    };

	    return clone;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(85),
	        __webpack_require__(1),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Uri,
	        defined,
	        DeveloperError) {
	    "use strict";

	    /**
	     * Given a URI, returns the last segment of the URI, removing any path or query information.
	     * @exports getFilenameFromUri
	     *
	     * @param {String} uri The Uri.
	     * @returns {String} The last segment of the Uri.
	     *
	     * @example
	     * //fileName will be"simple.czml";
	     * var fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');
	     */
	    var getFilenameFromUri = function(uri) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(uri)) {
	            throw new DeveloperError('uri is required.');
	        }
	        //>>includeEnd('debug');

	        var uriObject = new Uri(uri);
	        uriObject.normalize();
	        var path = uriObject.path;
	        var index = path.lastIndexOf('/');
	        if (index !== -1) {
	            path = path.substr(index + 1);
	        }
	        return path;
	    };

	    return getFilenameFromUri;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined) {
	    "use strict";
	    /*global performance*/

	    /**
	     * Gets a timestamp that can be used in measuring the time between events.  Timestamps
	     * are expressed in milliseconds, but it is not specified what the milliseconds are
	     * measured from.  This function uses performance.now() if it is available, or Date.now()
	     * otherwise.
	     *
	     * @exports getTimestamp
	     *
	     * @returns {Number} The timestamp in milliseconds since some unspecified reference time.
	     */
	    var getTimestamp;

	    if (typeof performance !== 'undefined' && defined(performance.now)) {
	        getTimestamp = function() {
	            return performance.now();
	        };
	    } else {
	        getTimestamp = function() {
	            return Date.now();
	        };
	    }

	    return getTimestamp;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined) {
	    "use strict";

	    /**
	     * Tests an object to see if it is an array.
	     * @exports isArray
	     *
	     * @param {Object} value The value to test.
	     * @returns {Boolean} true if the value is an array, false otherwise.
	     */
	    var isArray = Array.isArray;
	    if (!defined(isArray)) {
	        isArray = function(value) {
	            return Object.prototype.toString.call(value) === '[object Array]';
	        };
	    }

	    return isArray;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        DeveloperError) {
	    "use strict";

	    /**
	     * Determines if a given date is a leap year.
	     *
	     * @exports isLeapYear
	     *
	     * @param {Number} year The year to be tested.
	     * @returns {Boolean} True if <code>year</code> is a leap year.
	     *
	     * @example
	     * var leapYear = Cesium.isLeapYear(2000); // true
	     */
	    function isLeapYear(year) {
	        //>>includeStart('debug', pragmas.debug);
	        if (year === null || isNaN(year)) {
	            throw new DeveloperError('year is required and must be a number.');
	        }
	        //>>includeEnd('debug');

	        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
	    }

	    return isLeapYear;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(179)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        loadWithXhr) {
	    "use strict";

	    /**
	     * Asynchronously loads the given URL as text.  Returns a promise that will resolve to
	     * a String once loaded, or reject if the URL failed to load.  The data is loaded
	     * using XMLHttpRequest, which means that in order to make requests to another origin,
	     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	     *
	     * @exports loadText
	     *
	     * @param {String|Promise} url The URL to request, or a promise for the URL.
	     * @param {Object} [headers] HTTP headers to send with the request.
	     * @returns {Promise} a promise that will resolve to the requested data when loaded.
	     *
	     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}
	     * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	     * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	     *
	     * @example
	     * // load text from a URL, setting a custom header
	     * Cesium.loadText('http://someUrl.com/someJson.txt', {
	     *   'X-Custom-Header' : 'some value'
	     * }).then(function(text) {
	     *     // Do something with the text
	     * }).otherwise(function(error) {
	     *     // an error occurred
	     * });
	     */
	    var loadText = function(url, headers) {
	        return loadWithXhr({
	            url : url,
	            headers : headers
	        });
	    };

	    return loadText;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(47),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(170),
	        __webpack_require__(36)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        when,
	        defaultValue,
	        defined,
	        DeveloperError,
	        RequestErrorEvent,
	        RuntimeError) {
	    "use strict";

	    /**
	     * Asynchronously loads the given URL.  Returns a promise that will resolve to
	     * the result once loaded, or reject if the URL failed to load.  The data is loaded
	     * using XMLHttpRequest, which means that in order to make requests to another origin,
	     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	     *
	     * @exports loadWithXhr
	     *
	     * @param {Object} options Object with the following properties:
	     * @param {String|Promise} options.url The URL of the data, or a promise for the URL.
	     * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
	     * @param {String} [options.method='GET'] The HTTP method to use.
	     * @param {String} [options.data] The data to send with the request, if any.
	     * @param {Object} [options.headers] HTTP headers to send with the request, if any.
	     * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
	     * @returns {Promise} a promise that will resolve to the requested data when loaded.
	     *
	     * @see loadArrayBuffer
	     * @see loadBlob
	     * @see loadJson
	     * @see loadText
	     * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	     * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	     *
	     * @example
	     * // Load a single URL asynchronously. In real code, you should use loadBlob instead.
	     * Cesium.loadWithXhr({
	     *     url : 'some/url',
	     *     responseType : 'blob'
	     * }).then(function(blob) {
	     *     // use the data
	     * }).otherwise(function(error) {
	     *     // an error occurred
	     * });
	     */
	    var loadWithXhr = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(options.url)) {
	            throw new DeveloperError('options.url is required.');
	        }
	        //>>includeEnd('debug');

	        var responseType = options.responseType;
	        var method = defaultValue(options.method, 'GET');
	        var data = options.data;
	        var headers = options.headers;
	        var overrideMimeType = options.overrideMimeType;

	        return when(options.url, function(url) {
	            var deferred = when.defer();

	            loadWithXhr.load(url, responseType, method, data, headers, deferred, overrideMimeType);

	            return deferred.promise;
	        });
	    };

	    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;

	    function decodeDataUriText(isBase64, data) {
	        var result = decodeURIComponent(data);
	        if (isBase64) {
	            return atob(result);
	        }
	        return result;
	    }

	    function decodeDataUriArrayBuffer(isBase64, data) {
	        var byteString = decodeDataUriText(isBase64, data);
	        var buffer = new ArrayBuffer(byteString.length);
	        var view = new Uint8Array(buffer);
	        for (var i = 0; i < byteString.length; i++) {
	            view[i] = byteString.charCodeAt(i);
	        }
	        return buffer;
	    }

	    function decodeDataUri(dataUriRegexResult, responseType) {
	        responseType = defaultValue(responseType, '');
	        var mimeType = dataUriRegexResult[1];
	        var isBase64 = !!dataUriRegexResult[2];
	        var data = dataUriRegexResult[3];

	        switch (responseType) {
	        case '':
	        case 'text':
	            return decodeDataUriText(isBase64, data);
	        case 'arraybuffer':
	            return decodeDataUriArrayBuffer(isBase64, data);
	        case 'blob':
	            var buffer = decodeDataUriArrayBuffer(isBase64, data);
	            return new Blob([buffer], {
	                type : mimeType
	            });
	        case 'document':
	            var parser = new DOMParser();
	            return parser.parseFromString(decodeDataUriText(isBase64, data), mimeType);
	        case 'json':
	            return JSON.parse(decodeDataUriText(isBase64, data));
	        default:
	            throw new DeveloperError('Unhandled responseType: ' + responseType);
	        }
	    }

	    // This is broken out into a separate function so that it can be mocked for testing purposes.
	    loadWithXhr.load = function(url, responseType, method, data, headers, deferred, overrideMimeType) {
	        var dataUriRegexResult = dataUriRegex.exec(url);
	        if (dataUriRegexResult !== null) {
	            deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));
	            return;
	        }

	        var xhr = new XMLHttpRequest();

	        if (defined(overrideMimeType) && defined(xhr.overrideMimeType)) {
	            xhr.overrideMimeType(overrideMimeType);
	        }

	        xhr.open(method, url, true);

	        if (defined(headers)) {
	            for ( var key in headers) {
	                if (headers.hasOwnProperty(key)) {
	                    xhr.setRequestHeader(key, headers[key]);
	                }
	            }
	        }

	        if (defined(responseType)) {
	            xhr.responseType = responseType;
	        }

	        xhr.onload = function(e) {
	            if (xhr.status === 200) {
	                if (defined(xhr.response)) {
	                    deferred.resolve(xhr.response);
	                } else {
	                    // busted old browsers.
	                    if (defined(xhr.responseXML) && xhr.responseXML.hasChildNodes()) {
	                        deferred.resolve(xhr.responseXML);
	                    } else if (defined(xhr.responseText)) {
	                        deferred.resolve(xhr.responseText);
	                    } else {
	                        deferred.reject(new RuntimeError('unknown XMLHttpRequest response type.'));
	                    }
	                }
	            } else {
	                deferred.reject(new RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()));
	            }
	        };

	        xhr.onerror = function(e) {
	            deferred.reject(new RequestErrorEvent());
	        };

	        xhr.send(data);
	    };

	    loadWithXhr.defaultLoad = loadWithXhr.load;

	    return loadWithXhr;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    /**
	     * Parses the result of XMLHttpRequest's getAllResponseHeaders() method into
	     * a dictionary.
	     *
	     * @exports parseResponseHeaders
	     *
	     * @param {String} headerString The header string returned by getAllResponseHeaders().  The format is
	     *                 described here: http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
	     * @returns {Object} A dictionary of key/value pairs, where each key is the name of a header and the corresponding value
	     *                   is that header's value.
	     * 
	     * @private
	     */
	    var parseResponseHeaders = function(headerString) {
	        var headers = {};

	        if (!headerString) {
	          return headers;
	        }

	        var headerPairs = headerString.split('\u000d\u000a');

	        for (var i = 0; i < headerPairs.length; ++i) {
	          var headerPair = headerPairs[i];
	          // Can't use split() here because it does the wrong thing
	          // if the header value has the string ": " in it.
	          var index = headerPair.indexOf('\u003a\u0020');
	          if (index > 0) {
	            var key = headerPair.substring(0, index);
	            var val = headerPair.substring(index + 2);
	            headers[key] = val;
	          }
	        }

	        return headers;
	    };

	    return parseResponseHeaders;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a box. The center position and orientation are determined by the containing {@link Entity}.
	     *
	     * @alias BoxGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.dimensions] A {@link Cartesian3} Property specifying the length, width, and height of the box.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the box.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the box is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the box.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the box is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     *
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Box.html|Cesium Sandcastle Box Demo}
	     */
	    var BoxGraphics = function(options) {
	        this._dimensions = undefined;
	        this._dimensionsSubscription = undefined;
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(BoxGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof BoxGraphics.prototype
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the box.
	         * @memberof BoxGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets {@link Cartesian3} Property property specifying the length, width, and height of the box.
	         * @memberof BoxGraphics.prototype
	         * @type {Property}
	         */
	        dimensions : createPropertyDescriptor('dimensions'),

	        /**
	         * Gets or sets the material used to fill the box.
	         * @memberof BoxGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the boolean Property specifying whether the box is filled with the provided material.
	         * @memberof BoxGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the box is outlined.
	         * @memberof BoxGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof BoxGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof BoxGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {BoxGraphics} [result] The object onto which to store the result.
	     * @returns {BoxGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    BoxGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new BoxGraphics(this);
	        }
	        result.dimensions = this.dimensions;
	        result.show = this.show;
	        result.material = this.material;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {BoxGraphics} source The object to be merged into this object.
	     */
	    BoxGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.dimensions = defaultValue(this.dimensions, source.dimensions);
	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	    };

	    return BoxGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event) {
	    "use strict";

	    /**
	     * A {@link Property} whose value is lazily evaluated by a callback function.
	     *
	     * @alias CallbackProperty
	     * @constructor
	     *
	     * @param {CallbackProperty~Callback} callback The function to be called when the property is evaluated.
	     * @param {Boolean} isConstant <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
	     */
	    var CallbackProperty = function(callback, isConstant) {
	        this._callback = undefined;
	        this._isConstant = undefined;
	        this._definitionChanged = new Event();
	        this.setCallback(callback, isConstant);
	    };

	    defineProperties(CallbackProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.
	         * @memberof CallbackProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._isConstant;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever setCallback is called.
	         * @memberof CallbackProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property.
	     *
	     * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied or is unsupported.
	     */
	    CallbackProperty.prototype.getValue = function(time, result) {
	        return this._callback(time, result);
	    };

	    /**
	     * Sets the callback to be used.
	     *
	     * @param {CallbackProperty~Callback} callback The function to be called when the property is evaluated.
	     * @param {Boolean} isConstant <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
	     */
	    CallbackProperty.prototype.setCallback = function(callback, isConstant) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(callback)) {
	            throw new DeveloperError('callback is required.');
	        }
	        if (!defined(isConstant)) {
	            throw new DeveloperError('isConstant is required.');
	        }
	        //>>includeEnd('debug');

	        var changed = this._callback !== callback || this._isConstant !== isConstant;

	        this._callback = callback;
	        this._isConstant = isConstant;

	        if (changed) {
	            this._definitionChanged.raiseEvent(this);
	        }
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    CallbackProperty.prototype.equals = function(other) {
	        return this === other || (other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant);
	    };

	    /**
	     * A function that returns the value of the property.
	     * @callback CallbackProperty~Callback
	     *
	     * @param {JulianDate} [time] The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied or is unsupported.
	     */

	    return CallbackProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(46),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(37),
	        __webpack_require__(2),
	        __webpack_require__(11),
	        __webpack_require__(82),
	        __webpack_require__(83)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        createGuid,
	        defined,
	        defineProperties,
	        deprecationWarning,
	        DeveloperError,
	        CesiumMath,
	        Entity,
	        EntityCollection) {
	    "use strict";

	    var entityOptionsScratch = {
	        id : undefined
	    };
	    var entityIdScratch = new Array(2);

	    function clean(entity) {
	        var propertyNames = entity.propertyNames;
	        var propertyNamesLength = propertyNames.length;
	        for (var i = 0; i < propertyNamesLength; i++) {
	            entity[propertyNames[i]] = undefined;
	        }
	    }

	    function subscribeToEntity(that, eventHash, collectionId, entity) {
	        entityIdScratch[0] = collectionId;
	        entityIdScratch[1] = entity.id;
	        eventHash[JSON.stringify(entityIdScratch)] = entity.definitionChanged.addEventListener(CompositeEntityCollection.prototype._onDefinitionChanged, that);
	    }

	    function unsubscribeFromEntity(that, eventHash, collectionId, entity) {
	        entityIdScratch[0] = collectionId;
	        entityIdScratch[1] = entity.id;
	        var id = JSON.stringify(entityIdScratch);
	        eventHash[id]();
	        eventHash[id] = undefined;
	    }

	    function recomposite(that) {
	        that._shouldRecomposite = true;
	        if (that._suspendCount !== 0) {
	            return;
	        }

	        var collections = that._collections;
	        var collectionsLength = collections.length;

	        var collectionsCopy = that._collectionsCopy;
	        var collectionsCopyLength = collectionsCopy.length;

	        var i;
	        var entity;
	        var entities;
	        var iEntities;
	        var collection;
	        var composite = that._composite;
	        var newEntities = new EntityCollection();
	        var eventHash = that._eventHash;
	        var collectionId;

	        for (i = 0; i < collectionsCopyLength; i++) {
	            collection = collectionsCopy[i];
	            collection.collectionChanged.removeEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);
	            entities = collection.values;
	            collectionId = collection.id;
	            for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
	                entity = entities[iEntities];
	                unsubscribeFromEntity(that, eventHash, collectionId, entity);
	            }
	        }

	        for (i = collectionsLength - 1; i >= 0; i--) {
	            collection = collections[i];
	            collection.collectionChanged.addEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);

	            //Merge all of the existing entities.
	            entities = collection.values;
	            collectionId = collection.id;
	            for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
	                entity = entities[iEntities];
	                subscribeToEntity(that, eventHash, collectionId, entity);

	                var compositeEntity = newEntities.getById(entity.id);
	                if (!defined(compositeEntity)) {
	                    compositeEntity = composite.getById(entity.id);
	                    if (!defined(compositeEntity)) {
	                        entityOptionsScratch.id = entity.id;
	                        compositeEntity = new Entity(entityOptionsScratch);
	                    } else {
	                        clean(compositeEntity);
	                    }
	                    newEntities.add(compositeEntity);
	                }
	                compositeEntity.merge(entity);
	            }
	        }
	        that._collectionsCopy = collections.slice(0);

	        composite.suspendEvents();
	        composite.removeAll();
	        var newEntitiesArray = newEntities.values;
	        for (i = 0; i < newEntitiesArray.length; i++) {
	            composite.add(newEntitiesArray[i]);
	        }
	        composite.resumeEvents();
	    }

	    /**
	     * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.
	     * If a Entity with the same ID exists in multiple collections, it is non-destructively
	     * merged into a single new entity instance.  If an entity has the same property in multiple
	     * collections, the property of the Entity in the last collection of the list it
	     * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a
	     * EntityCollection is used.
	     *
	     * @alias CompositeEntityCollection
	     * @constructor
	     *
	     * @param {EntityCollection[]} [collections] The initial list of EntityCollection instances to merge.
	     */
	    var CompositeEntityCollection = function(collections) {
	        this._composite = new EntityCollection();
	        this._suspendCount = 0;
	        this._collections = defined(collections) ? collections.slice() : [];
	        this._collectionsCopy = [];
	        this._id = createGuid();
	        this._eventHash = {};
	        recomposite(this);
	        this._shouldRecomposite = false;
	    };

	    defineProperties(CompositeEntityCollection.prototype, {
	        /**
	         * Gets the event that is fired when entities are added or removed from the collection.
	         * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.
	         * @memberof CompositeEntityCollection.prototype
	         * @readonly
	         * @type {Event}
	         */
	        collectionChanged : {
	            get : function() {
	                return this._composite._collectionChanged;
	            }
	        },
	        /**
	         * Gets a globally unique identifier for this collection.
	         * @memberof CompositeEntityCollection.prototype
	         * @readonly
	         * @type {String}
	         */
	        id : {
	            get : function() {
	                return this._id;
	            }
	        },
	        /**
	         * Gets the array of Entity instances in the collection.
	         * This array should not be modified directly.
	         * @memberof CompositeEntityCollection.prototype
	         * @readonly
	         * @type {Entity[]}
	         * @deprecated
	         */
	        entities : {
	            get : function() {
	                deprecationWarning('CompositeEntityCollection.entities', 'EntityCollection.entities has been deprecated and will be removed in Cesium 1.9, use EntityCollection.values instead');
	                return this._composite.values;
	            }
	        },
	        /**
	         * Gets the array of Entity instances in the collection.
	         * This array should not be modified directly.
	         * @memberof CompositeEntityCollection.prototype
	         * @readonly
	         * @type {Entity[]}
	         */
	        values : {
	            get : function() {
	                return this._composite.values;
	            }
	        }
	    });

	    /**
	     * Adds a collection to the composite.
	     *
	     * @param {EntityCollection} collection the collection to add.
	     * @param {Number} [index] the index to add the collection at.  If omitted, the collection will
	     *                         added on top of all existing collections.
	     *
	     * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of collections.
	     */
	    CompositeEntityCollection.prototype.addCollection = function(collection, index) {
	        var hasIndex = defined(index);
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(collection)) {
	            throw new DeveloperError('collection is required.');
	        }
	        if (hasIndex) {
	            if (index < 0) {
	                throw new DeveloperError('index must be greater than or equal to zero.');
	            } else if (index > this._collections.length) {
	                throw new DeveloperError('index must be less than or equal to the number of collections.');
	            }
	        }
	        //>>includeEnd('debug');

	        if (!hasIndex) {
	            index = this._collections.length;
	            this._collections.push(collection);
	        } else {
	            this._collections.splice(index, 0, collection);
	        }

	        recomposite(this);
	    };

	    /**
	     * Removes a collection from this composite, if present.
	     *
	     * @param {EntityCollection} collection The collection to remove.
	     * @returns {Boolean} true if the collection was in the composite and was removed,
	     *                    false if the collection was not in the composite.
	     */
	    CompositeEntityCollection.prototype.removeCollection = function(collection) {
	        var index = this._collections.indexOf(collection);
	        if (index !== -1) {
	            this._collections.splice(index, 1);
	            recomposite(this);
	            return true;
	        }
	        return false;
	    };

	    /**
	     * Removes all collections from this composite.
	     */
	    CompositeEntityCollection.prototype.removeAllCollections = function() {
	        this._collections.length = 0;
	        recomposite(this);
	    };

	    /**
	     * Checks to see if the composite contains a given collection.
	     *
	     * @param {EntityCollection} collection the collection to check for.
	     * @returns {Boolean} true if the composite contains the collection, false otherwise.
	     */
	    CompositeEntityCollection.prototype.containsCollection = function(collection) {
	        return this._collections.indexOf(collection) !== -1;
	    };

	    /**
	     * Returns true if the provided entity is in this collection, false otherwise.
	     *
	     * @param entity The entity.
	     * @returns {Boolean} true if the provided entity is in this collection, false otherwise.
	     */
	    CompositeEntityCollection.prototype.contains = function(entity) {
	        return this._composite.contains(entity);
	    };

	    /**
	     * Determines the index of a given collection in the composite.
	     *
	     * @param {EntityCollection} collection The collection to find the index of.
	     * @returns {Number} The index of the collection in the composite, or -1 if the collection does not exist in the composite.
	     */
	    CompositeEntityCollection.prototype.indexOfCollection = function(collection) {
	        return this._collections.indexOf(collection);
	    };

	    /**
	     * Gets a collection by index from the composite.
	     *
	     * @param {Number} index the index to retrieve.
	     */
	    CompositeEntityCollection.prototype.getCollection = function(index) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(index)) {
	            throw new DeveloperError('index is required.', 'index');
	        }
	        //>>includeEnd('debug');

	        return this._collections[index];
	    };

	    /**
	     * Gets the number of collections in this composite.
	     */
	    CompositeEntityCollection.prototype.getCollectionsLength = function() {
	        return this._collections.length;
	    };

	    function getCollectionIndex(collections, collection) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(collection)) {
	            throw new DeveloperError('collection is required.');
	        }
	        //>>includeEnd('debug');

	        var index = collections.indexOf(collection);

	        //>>includeStart('debug', pragmas.debug);
	        if (index === -1) {
	            throw new DeveloperError('collection is not in this composite.');
	        }
	        //>>includeEnd('debug');

	        return index;
	    }

	    function swapCollections(composite, i, j) {
	        var arr = composite._collections;
	        i = CesiumMath.clamp(i, 0, arr.length - 1);
	        j = CesiumMath.clamp(j, 0, arr.length - 1);

	        if (i === j) {
	            return;
	        }

	        var temp = arr[i];
	        arr[i] = arr[j];
	        arr[j] = temp;

	        recomposite(composite);
	    }

	    /**
	     * Raises a collection up one position in the composite.
	     *
	     * @param {EntityCollection} collection the collection to move.
	     *
	     * @exception {DeveloperError} collection is not in this composite.
	     */
	    CompositeEntityCollection.prototype.raiseCollection = function(collection) {
	        var index = getCollectionIndex(this._collections, collection);
	        swapCollections(this, index, index + 1);
	    };

	    /**
	     * Lowers a collection down one position in the composite.
	     *
	     * @param {EntityCollection} collection the collection to move.
	     *
	     * @exception {DeveloperError} collection is not in this composite.
	     */
	    CompositeEntityCollection.prototype.lowerCollection = function(collection) {
	        var index = getCollectionIndex(this._collections, collection);
	        swapCollections(this, index, index - 1);
	    };

	    /**
	     * Raises a collection to the top of the composite.
	     *
	     * @param {EntityCollection} collection the collection to move.
	     *
	     * @exception {DeveloperError} collection is not in this composite.
	     */
	    CompositeEntityCollection.prototype.raiseCollectionToTop = function(collection) {
	        var index = getCollectionIndex(this._collections, collection);
	        if (index === this._collections.length - 1) {
	            return;
	        }
	        this._collections.splice(index, 1);
	        this._collections.push(collection);

	        recomposite(this);
	    };

	    /**
	     * Lowers a collection to the bottom of the composite.
	     *
	     * @param {EntityCollection} collection the collection to move.
	     *
	     * @exception {DeveloperError} collection is not in this composite.
	     */
	    CompositeEntityCollection.prototype.lowerCollectionToBottom = function(collection) {
	        var index = getCollectionIndex(this._collections, collection);
	        if (index === 0) {
	            return;
	        }
	        this._collections.splice(index, 1);
	        this._collections.splice(0, 0, collection);

	        recomposite(this);
	    };

	    /**
	     * Prevents {@link EntityCollection#collectionChanged} events from being raised
	     * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
	     * point a single event will be raised that covers all suspended operations.
	     * This allows for many items to be added and removed efficiently.
	     * While events are suspended, recompositing of the collections will
	     * also be suspended, as this can be a costly operation.
	     * This function can be safely called multiple times as long as there
	     * are corresponding calls to {@link EntityCollection#resumeEvents}.
	     */
	    CompositeEntityCollection.prototype.suspendEvents = function() {
	        this._suspendCount++;
	        this._composite.suspendEvents();
	    };

	    /**
	     * Resumes raising {@link EntityCollection#collectionChanged} events immediately
	     * when an item is added or removed.  Any modifications made while while events were suspended
	     * will be triggered as a single event when this function is called.  This function also ensures
	     * the collection is recomposited if events are also resumed.
	     * This function is reference counted and can safely be called multiple times as long as there
	     * are corresponding calls to {@link EntityCollection#resumeEvents}.
	     *
	     * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.
	     */
	    CompositeEntityCollection.prototype.resumeEvents = function() {
	        //>>includeStart('debug', pragmas.debug);
	        if (this._suspendCount === 0) {
	            throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
	        }
	        //>>includeEnd('debug');

	        this._suspendCount--;
	        // recomposite before triggering events (but only if required for performance) that might depend on a composited collection
	        if (this._shouldRecomposite && this._suspendCount === 0) {
	            recomposite(this);
	            this._shouldRecomposite = false;
	        }

	        this._composite.resumeEvents();
	    };

	    /**
	     * Computes the maximum availability of the entities in the collection.
	     * If the collection contains a mix of infinitely available data and non-infinite data,
	     * It will return the interval pertaining to the non-infinite data only.  If all
	     * data is infinite, an infinite interval will be returned.
	     *
	     * @returns {TimeInterval} The availability of entities in the collection.
	     */
	    CompositeEntityCollection.prototype.computeAvailability = function() {
	        return this._composite.computeAvailability();
	    };

	    /**
	     * Gets an entity with the specified id.
	     *
	     * @param {Object} id The id of the entity to retrieve.
	     * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.
	     */
	    CompositeEntityCollection.prototype.getById = function(id) {
	        return this._composite.getById(id);
	    };

	    CompositeEntityCollection.prototype._onCollectionChanged = function(collection, added, removed) {
	        var collections = this._collectionsCopy;
	        var collectionsLength = collections.length;
	        var composite = this._composite;
	        composite.suspendEvents();

	        var i;
	        var q;
	        var entity;
	        var compositeEntity;
	        var removedLength = removed.length;
	        var eventHash = this._eventHash;
	        var collectionId = collection.id;
	        for (i = 0; i < removedLength; i++) {
	            var removedEntity = removed[i];
	            unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);

	            var removedId = removedEntity.id;
	            //Check if the removed entity exists in any of the remaining collections
	            //If so, we clean and remerge it.
	            for (q = collectionsLength - 1; q >= 0; q--) {
	                entity = collections[q].getById(removedId);
	                if (defined(entity)) {
	                    if (!defined(compositeEntity)) {
	                        compositeEntity = composite.getById(removedId);
	                        clean(compositeEntity);
	                    }
	                    compositeEntity.merge(entity);
	                }
	            }
	            //We never retrieved the compositeEntity, which means it no longer
	            //exists in any of the collections, remove it from the composite.
	            if (!defined(compositeEntity)) {
	                composite.removeById(removedId);
	            }
	            compositeEntity = undefined;
	        }

	        var addedLength = added.length;
	        for (i = 0; i < addedLength; i++) {
	            var addedEntity = added[i];
	            subscribeToEntity(this, eventHash, collectionId, addedEntity);

	            var addedId = addedEntity.id;
	            //We know the added entity exists in at least one collection,
	            //but we need to check all collections and re-merge in order
	            //to maintain the priority of properties.
	            for (q = collectionsLength - 1; q >= 0; q--) {
	                entity = collections[q].getById(addedId);
	                if (defined(entity)) {
	                    if (!defined(compositeEntity)) {
	                        compositeEntity = composite.getById(addedId);
	                        if (!defined(compositeEntity)) {
	                            entityOptionsScratch.id = addedId;
	                            compositeEntity = new Entity(entityOptionsScratch);
	                            composite.add(compositeEntity);
	                        } else {
	                            clean(compositeEntity);
	                        }
	                    }
	                    compositeEntity.merge(entity);
	                }
	            }
	            compositeEntity = undefined;
	        }

	        composite.resumeEvents();
	    };

	    CompositeEntityCollection.prototype._onDefinitionChanged = function(entity, propertyName, newValue, oldValue) {
	        var collections = this._collections;
	        var composite = this._composite;

	        var collectionsLength = collections.length;
	        var id = entity.id;
	        var compositeEntity = composite.getById(id);
	        var compositeProperty = compositeEntity[propertyName];
	        var newProperty = !defined(compositeProperty);

	        var firstTime = true;
	        for (var q = collectionsLength - 1; q >= 0; q--) {
	            var innerEntity = collections[q].getById(entity.id);
	            if (defined(innerEntity)) {
	                var property = innerEntity[propertyName];
	                if (defined(property)) {
	                    if (firstTime) {
	                        firstTime = false;
	                        //We only want to clone if the property is also mergeable.
	                        //This ensures that leaf properties are referenced and not copied,
	                        //which is the entire point of compositing.
	                        if (defined(property.merge) && defined(property.clone)) {
	                            compositeProperty = property.clone(compositeProperty);
	                        } else {
	                            compositeProperty = property;
	                            break;
	                        }
	                    }
	                    compositeProperty.merge(property);
	                }
	            }
	        }

	        if (newProperty && compositeEntity.propertyNames.indexOf(propertyName) === -1) {
	            compositeEntity.addProperty(propertyName);
	        }

	        compositeEntity[propertyName] = compositeProperty;
	    };

	    return CompositeEntityCollection;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(80),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        CompositeProperty,
	        Property) {
	    "use strict";

	    /**
	     * A {@link CompositeProperty} which is also a {@link MaterialProperty}.
	     *
	     * @alias CompositeMaterialProperty
	     * @constructor
	     */
	    var CompositeMaterialProperty = function() {
	        this._definitionChanged = new Event();
	        this._composite = new CompositeProperty();
	        this._composite.definitionChanged.addEventListener(CompositeMaterialProperty.prototype._raiseDefinitionChanged, this);
	    };

	    defineProperties(CompositeMaterialProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof CompositeMaterialProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._composite.isConstant;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever setValue is called with data different
	         * than the current value.
	         * @memberof CompositeMaterialProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the interval collection.
	         * @memberof CompositeMaterialProperty.prototype
	         *
	         * @type {TimeIntervalCollection}
	         */
	        intervals : {
	            get : function() {
	                return this._composite._intervals;
	            }
	        }
	    });

	    /**
	     * Gets the {@link Material} type at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    CompositeMaterialProperty.prototype.getType = function(time) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required');
	        }
	        //>>includeEnd('debug');

	        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
	        if (defined(innerProperty)) {
	            return innerProperty.getType(time);
	        }
	        return undefined;
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    CompositeMaterialProperty.prototype.getValue = function(time, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required');
	        }
	        //>>includeEnd('debug');

	        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
	        if (defined(innerProperty)) {
	            return innerProperty.getValue(time, result);
	        }
	        return undefined;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    CompositeMaterialProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof CompositeMaterialProperty && //
	                this._composite.equals(other._composite, Property.equals));
	    };

	    /**
	     * @private
	     */
	    CompositeMaterialProperty.prototype._raiseDefinitionChanged = function() {
	        this._definitionChanged.raiseEvent(this);
	    };

	    return CompositeMaterialProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(21),
	        __webpack_require__(80),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        ReferenceFrame,
	        CompositeProperty,
	        Property) {
	    "use strict";

	    /**
	     * A {@link CompositeProperty} which is also a {@link PositionProperty}.
	     *
	     * @alias CompositePositionProperty
	     * @constructor
	     */
	    var CompositePositionProperty = function(referenceFrame) {
	        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
	        this._definitionChanged = new Event();
	        this._composite = new CompositeProperty();
	        this._composite.definitionChanged.addEventListener(CompositePositionProperty.prototype._raiseDefinitionChanged, this);
	    };

	    defineProperties(CompositePositionProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof CompositePositionProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._composite.isConstant;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever setValue is called with data different
	         * than the current value.
	         * @memberof CompositePositionProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the interval collection.
	         * @memberof CompositePositionProperty.prototype
	         *
	         * @type {TimeIntervalCollection}
	         */
	        intervals : {
	            get : function() {
	                return this._composite.intervals;
	            }
	        },
	        /**
	         * Gets or sets the reference frame which this position presents itself as.
	         * Each PositionProperty making up this object has it's own reference frame,
	         * so this property merely exposes a "preferred" reference frame for clients
	         * to use.
	         * @memberof CompositePositionProperty.prototype
	         *
	         * @type {ReferenceFrame}
	         */
	        referenceFrame : {
	            get : function() {
	                return this._referenceFrame;
	            },
	            set : function(value) {
	                this._referenceFrame = value;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time in the fixed frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    CompositePositionProperty.prototype.getValue = function(time, result) {
	        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
	    };

	    /**
	     * Gets the value of the property at the provided time and in the provided reference frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    CompositePositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        if (!defined(referenceFrame)) {
	            throw new DeveloperError('referenceFrame is required.');
	        }
	        //>>includeEnd('debug');

	        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
	        if (defined(innerProperty)) {
	            return innerProperty.getValueInReferenceFrame(time, referenceFrame, result);
	        }
	        return undefined;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    CompositePositionProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof CompositePositionProperty && //
	                this._referenceFrame === other._referenceFrame && //
	                this._composite.equals(other._composite, Property.equals));
	    };

	    /**
	     * @private
	     */
	    CompositePositionProperty.prototype._raiseDefinitionChanged = function() {
	        this._definitionChanged.raiseEvent(this);
	    };

	    return CompositePositionProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a corridor, which is a shape defined by a centerline and width that
	     * conforms to the curvature of the globe. It can be placed on the surface or at altitude
	     * and can optionally be extruded into a volume.
	     *
	     * @alias CorridorGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
	     * @param {Property} [options.width] A numeric Property specifying the distance between the edges of the corridor.
	     * @param {Property} [options.cornerType=CornerType.ROUNDED] A {@link CornerType} Property specifying the style of the corners.
	     * @param {Property} [options.height=0] A numeric Property specifying the altitude of the corridor.
	     * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the corridor extrusion.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the corridor.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the corridor is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the corridor.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the corridor is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the distance between each latitude and longitude.
	     *
	     * @see Entity
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}
	     */
	    var CorridorGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._positions = undefined;
	        this._positionsSubscription = undefined;
	        this._height = undefined;
	        this._heightSubscription = undefined;
	        this._extrudedHeight = undefined;
	        this._extrudedHeightSubscription = undefined;
	        this._granularity = undefined;
	        this._granularitySubscription = undefined;
	        this._width = undefined;
	        this._widthSubscription = undefined;
	        this._cornerType = undefined;
	        this._cornerTypeSubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(CorridorGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof CorridorGraphics.prototype
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the corridor.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the corridor.
	         * @memberof CorridorGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets a Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         */
	        positions : createPropertyDescriptor('positions'),

	        /**
	         * Gets or sets the numeric Property specifying the altitude of the corridor.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default 0.0
	         */
	        height : createPropertyDescriptor('height'),

	        /**
	         * Gets or sets the numeric Property specifying the altitude of the corridor extrusion.
	         * Setting this property creates a corridor shaped volume starting at height and ending
	         * at this altitude.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         */
	        extrudedHeight : createPropertyDescriptor('extrudedHeight'),

	        /**
	         * Gets or sets the numeric Property specifying the sampling distance between each latitude and longitude point.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default {CesiumMath.RADIANS_PER_DEGREE}
	         */
	        granularity : createPropertyDescriptor('granularity'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the corridor.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         */
	        width : createPropertyDescriptor('width'),

	        /**
	         * Gets or sets the boolean Property specifying whether the corridor is filled with the provided material.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the corridor is outlined.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the {@link CornerType} Property specifying how corners are styled.
	         * @memberof CorridorGraphics.prototype
	         * @type {Property}
	         * @default CornerType.ROUNDED
	         */
	        cornerType : createPropertyDescriptor('cornerType')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {CorridorGraphics} [result] The object onto which to store the result.
	     * @returns {CorridorGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    CorridorGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new CorridorGraphics(this);
	        }
	        result.show = this.show;
	        result.material = this.material;
	        result.positions = this.positions;
	        result.height = this.height;
	        result.extrudedHeight = this.extrudedHeight;
	        result.granularity = this.granularity;
	        result.width = this.width;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.cornerType = this.cornerType;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {CorridorGraphics} source The object to be merged into this object.
	     */
	    CorridorGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.positions = defaultValue(this.positions, source.positions);
	        this.height = defaultValue(this.height, source.height);
	        this.extrudedHeight = defaultValue(this.extrudedHeight, source.extrudedHeight);
	        this.granularity = defaultValue(this.granularity, source.granularity);
	        this.width = defaultValue(this.width, source.width);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.cornerType = defaultValue(this.cornerType, source.cornerType);
	    };

	    return CorridorGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius.
	     * The center position and orientation are determined by the containing {@link Entity}.
	     *
	     * @alias CylinderGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.length] A numeric Property specifying the length of the cylinder.
	     * @param {Property} [options.topRadius] A numeric Property specifying the radius of the top of the cylinder.
	     * @param {Property} [options.bottomRadius] A numeric Property specifying the radius of the bottom of the cylinder.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the cylinder.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the cylinder is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the cylinder.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the cylinder is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.numberOfVerticalLines=16] A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
	     * @param {Property} [options.slices=128] The number of edges around perimeter of the cylinder.
	     *
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Cylinder.html|Cesium Sandcastle Cylinder Demo}
	     */
	    var CylinderGraphics = function(options) {
	        this._length = undefined;
	        this._lengthSubscription = undefined;
	        this._topRadius = undefined;
	        this._topRadiusSubscription = undefined;
	        this._bottomRadius = undefined;
	        this._bottomRadiusSubscription = undefined;
	        this._numberOfVerticalLines = undefined;
	        this._numberOfVerticalLinesSubscription = undefined;
	        this._slices = undefined;
	        this._slicesSubscription = undefined;
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };
	    defineProperties(CylinderGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof CylinderGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the numeric Property specifying the length of the cylinder.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         */
	        length : createPropertyDescriptor('length'),

	        /**
	         * Gets or sets the numeric Property specifying the radius of the top of the cylinder.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         */
	        topRadius : createPropertyDescriptor('topRadius'),

	        /**
	         * Gets or sets the numeric Property specifying the radius of the bottom of the cylinder.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         */
	        bottomRadius : createPropertyDescriptor('bottomRadius'),

	        /**
	         * Gets or sets the Property specifying the number of vertical lines to draw along the perimeter for the outline.
	         * to use when outlining the cylinder.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         * @default 16
	         */
	        numberOfVerticalLines : createPropertyDescriptor('numberOfVerticalLines'),

	        /**
	         * Gets or sets the Property specifying the number of edges around perimeter of the cylinder.
	         * between each latitude and longitude point.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         * @default 16
	         */
	        slices : createPropertyDescriptor('slices'),

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the cylinder.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the cylinder.
	         * @memberof CylinderGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the boolean Property specifying whether the cylinder is filled with the provided material.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the boolean Property specifying whether the cylinder is outlined.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof CylinderGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {CylinderGraphics} [result] The object onto which to store the result.
	     * @returns {CylinderGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    CylinderGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new CylinderGraphics(this);
	        }
	        result.bottomRadius = this.bottomRadius;
	        result.length = this.length;
	        result.topRadius = this.topRadius;
	        result.show = this.show;
	        result.material = this.material;
	        result.numberOfVerticalLines = this.numberOfVerticalLines;
	        result.slices = this.slices;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {CylinderGraphics} source The object to be merged into this object.
	     */
	    CylinderGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.bottomRadius = defaultValue(this.bottomRadius, source.bottomRadius);
	        this.length = defaultValue(this.length, source.length);
	        this.topRadius = defaultValue(this.topRadius, source.topRadius);
	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.numberOfVerticalLines = defaultValue(this.numberOfVerticalLines, source.numberOfVerticalLines);
	        this.slices = defaultValue(this.slices, source.slices);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	    };

	    return CylinderGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(34),
	        __webpack_require__(12),
	        __webpack_require__(52),
	        __webpack_require__(116),
	        __webpack_require__(74),
	        __webpack_require__(28),
	        __webpack_require__(46),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(37),
	        __webpack_require__(2),
	        __webpack_require__(43),
	        __webpack_require__(6),
	        __webpack_require__(75),
	        __webpack_require__(174),
	        __webpack_require__(120),
	        __webpack_require__(176),
	        __webpack_require__(76),
	        __webpack_require__(16),
	        __webpack_require__(168),
	        __webpack_require__(123),
	        __webpack_require__(79),
	        __webpack_require__(11),
	        __webpack_require__(35),
	        __webpack_require__(169),
	        __webpack_require__(21),
	        __webpack_require__(36),
	        __webpack_require__(171),
	        __webpack_require__(53),
	        __webpack_require__(54),
	        __webpack_require__(201),
	        __webpack_require__(202),
	        __webpack_require__(205),
	        __webpack_require__(85),
	        __webpack_require__(47),
	        __webpack_require__(124),
	        __webpack_require__(125),
	        __webpack_require__(184),
	        __webpack_require__(185),
	        __webpack_require__(80),
	        __webpack_require__(81),
	        __webpack_require__(56),
	        __webpack_require__(189),
	        __webpack_require__(190),
	        __webpack_require__(126),
	        __webpack_require__(127),
	        __webpack_require__(83),
	        __webpack_require__(191),
	        __webpack_require__(128),
	        __webpack_require__(129),
	        __webpack_require__(130),
	        __webpack_require__(131),
	        __webpack_require__(132),
	        __webpack_require__(133),
	        __webpack_require__(193),
	        __webpack_require__(134),
	        __webpack_require__(194),
	        __webpack_require__(196),
	        __webpack_require__(135),
	        __webpack_require__(136),
	        __webpack_require__(137),
	        __webpack_require__(138),
	        __webpack_require__(84),
	        __webpack_require__(197),
	        __webpack_require__(139),
	        __webpack_require__(198),
	        __webpack_require__(199),
	        __webpack_require__(140)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian2,
	        Cartesian3,
	        Cartographic,
	        ClockRange,
	        ClockStep,
	        Color,
	        createGuid,
	        defaultValue,
	        defined,
	        defineProperties,
	        deprecationWarning,
	        DeveloperError,
	        Ellipsoid,
	        Event,
	        ExtrapolationType,
	        getFilenameFromUri,
	        HermitePolynomialApproximation,
	        isArray,
	        Iso8601,
	        JulianDate,
	        LagrangePolynomialApproximation,
	        LinearApproximation,
	        loadJson,
	        CesiumMath,
	        Quaternion,
	        Rectangle,
	        ReferenceFrame,
	        RuntimeError,
	        Spherical,
	        TimeInterval,
	        TimeIntervalCollection,
	        HorizontalOrigin,
	        LabelStyle,
	        VerticalOrigin,
	        Uri,
	        when,
	        BillboardGraphics,
	        ColorMaterialProperty,
	        CompositeMaterialProperty,
	        CompositePositionProperty,
	        CompositeProperty,
	        ConstantPositionProperty,
	        ConstantProperty,
	        DataSource,
	        DataSourceClock,
	        EllipseGraphics,
	        EllipsoidGraphics,
	        EntityCollection,
	        GridMaterialProperty,
	        ImageMaterialProperty,
	        LabelGraphics,
	        ModelGraphics,
	        PathGraphics,
	        PointGraphics,
	        PolygonGraphics,
	        PolylineGlowMaterialProperty,
	        PolylineGraphics,
	        PolylineOutlineMaterialProperty,
	        PositionPropertyArray,
	        RectangleGraphics,
	        ReferenceEntity,
	        ReferenceProperty,
	        SampledPositionProperty,
	        SampledProperty,
	        StripeMaterialProperty,
	        StripeOrientation,
	        TimeIntervalCollectionPositionProperty,
	        TimeIntervalCollectionProperty,
	        WallGraphics) {
	    "use strict";

	    var currentId;

	    function makeReference(collection, referenceString) {
	        if (referenceString[0] === '#') {
	            referenceString = currentId + referenceString;
	        }
	        return ReferenceProperty.fromString(collection, referenceString);
	    }

	    function makeReferenceEntity(collection, referenceFrameString, currentReferenceFrame) {
	        if (referenceFrameString === null) return null;

	        if (referenceFrameString[0] === '#') {
	            referenceFrameString = referenceFrameString.slice(1)
	        }

	        if (currentReferenceFrame instanceof ReferenceEntity && currentReferenceFrame.targetCollection === collection && currentReferenceFrame.targetId === referenceFrameString) {
	            return currentReferenceFrame
	        }
	        return new ReferenceEntity(collection, referenceFrameString)
	    }

	    var scratchCartesian = new Cartesian3();
	    var scratchSpherical = new Spherical();
	    var scratchCartographic = new Cartographic();
	    var scratchTimeInterval = new TimeInterval();

	    function unwrapColorInterval(czmlInterval) {
	        var rgbaf = czmlInterval.rgbaf;
	        if (defined(rgbaf)) {
	            return rgbaf;
	        }

	        var rgba = czmlInterval.rgba;
	        if (!defined(rgba)) {
	            return undefined;
	        }

	        if (rgba.length === Color.length) {
	            return [Color.byteToFloat(rgba[0]), Color.byteToFloat(rgba[1]), Color.byteToFloat(rgba[2]), Color.byteToFloat(rgba[3])];
	        }

	        var len = rgba.length;
	        rgbaf = new Array(len);
	        for (var i = 0; i < len; i += 5) {
	            rgbaf[i] = rgba[i];
	            rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);
	            rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);
	            rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);
	            rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);
	        }
	        return rgbaf;
	    }

	    function unwrapImageInterval(czmlInterval, sourceUri) {
	        var result = defaultValue(czmlInterval.image, czmlInterval);
	        if (defined(sourceUri)) {
	            var baseUri = new Uri(document.location.href);
	            sourceUri = new Uri(sourceUri);
	            result = new Uri(result).resolve(sourceUri.resolve(baseUri)).toString();
	        }
	        return result;
	    }

	    function unwrapUriInterval(czmlInterval, sourceUri) {
	        var result = defaultValue(czmlInterval.uri, czmlInterval);
	        if (defined(sourceUri)) {
	            var baseUri = new Uri(document.location.href);
	            sourceUri = new Uri(sourceUri);
	            result = new Uri(result).resolve(sourceUri.resolve(baseUri)).toString();
	        }
	        return result;
	    }

	    function unwrapRectangleInterval(czmlInterval) {
	        var wsenDegrees = czmlInterval.wsenDegrees;
	        if (defined(wsenDegrees)) {
	            var length = wsenDegrees.length;
	            for (var i = 0; i < length; i++) {
	                wsenDegrees[i] = CesiumMath.toRadians(wsenDegrees[i]);
	            }
	            return wsenDegrees;
	        }
	        return czmlInterval.wsen;
	    }

	    function unwrapCartesianInterval(czmlInterval) {
	        if (defined(czmlInterval.cartesian)) {
	            return czmlInterval.cartesian;
	        }

	        if (defined(czmlInterval.cartesianVelocity)) {
	            return czmlInterval.cartesianVelocity;
	        }

	        if (defined(czmlInterval.unitCartesian)) {
	            return czmlInterval.unitCartesian;
	        }

	        var i;
	        var len;
	        var result;

	        var unitSpherical = czmlInterval.unitSpherical;
	        if (defined(unitSpherical)) {
	            len = unitSpherical.length;
	            if (len === 2) {
	                scratchSpherical.clock = unitSpherical[0];
	                scratchSpherical.cone = unitSpherical[1];
	                Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);
	                result = [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];
	            } else {
	                var sphericalIt = 0;
	                result = new Array((len / 3) * 4);
	                for (i = 0; i < len; i += 4) {
	                    result[i] = unitSpherical[sphericalIt++];

	                    scratchSpherical.clock = unitSpherical[sphericalIt++];
	                    scratchSpherical.cone = unitSpherical[sphericalIt++];
	                    Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);

	                    result[i + 1] = scratchCartesian.x;
	                    result[i + 2] = scratchCartesian.y;
	                    result[i + 3] = scratchCartesian.z;
	                }
	            }
	            return result;
	        }

	        var cartographic = czmlInterval.cartographicRadians;
	        if (defined(cartographic)) {
	            if (cartographic.length === 3) {
	                scratchCartographic.longitude = cartographic[0];
	                scratchCartographic.latitude = cartographic[1];
	                scratchCartographic.height = cartographic[2];
	                Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
	                result = [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];
	            } else {
	                len = cartographic.length;
	                result = new Array(len);
	                for (i = 0; i < len; i += 4) {
	                    scratchCartographic.longitude = cartographic[i + 1];
	                    scratchCartographic.latitude = cartographic[i + 2];
	                    scratchCartographic.height = cartographic[i + 3];
	                    Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);

	                    result[i] = cartographic[i];
	                    result[i + 1] = scratchCartesian.x;
	                    result[i + 2] = scratchCartesian.y;
	                    result[i + 3] = scratchCartesian.z;
	                }
	            }
	            return result;
	        }

	        var cartographicDegrees = czmlInterval.cartographicDegrees;
	        if (!defined(cartographicDegrees)) {
	            throw new RuntimeError(JSON.stringify(czmlInterval) + ' is not a valid CZML interval.');
	        }

	        if (cartographicDegrees.length === 3) {
	            scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[0]);
	            scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[1]);
	            scratchCartographic.height = cartographicDegrees[2];
	            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
	            result = [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];
	        } else {
	            len = cartographicDegrees.length;
	            result = new Array(len);
	            for (i = 0; i < len; i += 4) {
	                scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[i + 1]);
	                scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[i + 2]);
	                scratchCartographic.height = cartographicDegrees[i + 3];
	                Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);

	                result[i] = cartographicDegrees[i];
	                result[i + 1] = scratchCartesian.x;
	                result[i + 2] = scratchCartesian.y;
	                result[i + 3] = scratchCartesian.z;
	            }
	        }

	        return result;
	    }

	    function normalizePackedQuaternionArray(array, startingIndex) {
	        var x = array[startingIndex];
	        var y = array[startingIndex + 1];
	        var z = array[startingIndex + 2];
	        var w = array[startingIndex + 3];

	        var inverseMagnitude = 1.0 / Math.sqrt(x * x + y * y + z * z + w * w);
	        array[startingIndex] = x * inverseMagnitude;
	        array[startingIndex + 1] = y * inverseMagnitude;
	        array[startingIndex + 2] = z * inverseMagnitude;
	        array[startingIndex + 3] = w * inverseMagnitude;
	    }

	    function unwrapQuaternionInterval(czmlInterval) {
	        var unitQuaternion = czmlInterval.unitQuaternion;
	        if (defined(unitQuaternion)) {
	            if (unitQuaternion.length === 4) {
	                normalizePackedQuaternionArray(unitQuaternion, 0);
	                return unitQuaternion;
	            }

	            for (var i = 1; i < unitQuaternion.length; i += 5) {
	                normalizePackedQuaternionArray(unitQuaternion, i);
	            }
	        }
	        return unitQuaternion;
	    }

	    function unwrapInterval(type, czmlInterval, sourceUri) {
	        /*jshint sub:true*/
	        switch (type) {
	        case Boolean:
	            return defaultValue(czmlInterval['boolean'], czmlInterval);
	        case Cartesian2:
	            return czmlInterval.cartesian2;
	        case Cartesian3:
	            return unwrapCartesianInterval(czmlInterval);
	        case Color:
	            return unwrapColorInterval(czmlInterval);
	        case StripeOrientation:
	            return StripeOrientation[defaultValue(czmlInterval.stripeOrientation, czmlInterval)];
	        case HorizontalOrigin:
	            return HorizontalOrigin[defaultValue(czmlInterval.horizontalOrigin, czmlInterval)];
	        case Image:
	            return unwrapUriInterval(czmlInterval, sourceUri);
	        case JulianDate:
	            return JulianDate.fromIso8601(defaultValue(czmlInterval.date, czmlInterval));
	        case LabelStyle:
	            return LabelStyle[defaultValue(czmlInterval.labelStyle, czmlInterval)];
	        case Number:
	            return defaultValue(czmlInterval.number, czmlInterval);
	        case String:
	            return defaultValue(czmlInterval.string, czmlInterval);
	        case Array:
	            return czmlInterval.array;
	        case Quaternion:
	            return unwrapQuaternionInterval(czmlInterval);
	        case Rectangle:
	            return unwrapRectangleInterval(czmlInterval);
	        case Uri:
	            return unwrapUriInterval(czmlInterval, sourceUri);
	        case VerticalOrigin:
	            return VerticalOrigin[defaultValue(czmlInterval.verticalOrigin, czmlInterval)];
	        default:
	            throw new RuntimeError(type);
	        }
	    }

	    var interpolators = {
	        HERMITE : HermitePolynomialApproximation,
	        LAGRANGE : LagrangePolynomialApproximation,
	        LINEAR : LinearApproximation
	    };

	    function updateInterpolationSettings(packetData, property) {
	        var interpolationAlgorithm = packetData.interpolationAlgorithm;
	        if (defined(interpolationAlgorithm) || defined(packetData.interpolationDegree)) {
	            property.setInterpolationOptions({
	                interpolationAlgorithm : interpolators[interpolationAlgorithm],
	                interpolationDegree : packetData.interpolationDegree
	            });
	        }

	        var forwardExtrapolationType = packetData.forwardExtrapolationType;
	        if (defined(forwardExtrapolationType)) {
	            property.forwardExtrapolationType = ExtrapolationType[forwardExtrapolationType];
	        }

	        var forwardExtrapolationDuration = packetData.forwardExtrapolationDuration;
	        if (defined(forwardExtrapolationDuration)) {
	            property.forwardExtrapolationDuration = forwardExtrapolationDuration;
	        }

	        var backwardExtrapolationType = packetData.backwardExtrapolationType;
	        if (defined(backwardExtrapolationType)) {
	            property.backwardExtrapolationType = ExtrapolationType[backwardExtrapolationType];
	        }

	        var backwardExtrapolationDuration = packetData.backwardExtrapolationDuration;
	        if (defined(backwardExtrapolationDuration)) {
	            property.backwardExtrapolationDuration = backwardExtrapolationDuration;
	        }
	    }

	    function processProperty(type, object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
	        var combinedInterval;
	        var packetInterval = packetData.interval;
	        if (defined(packetInterval)) {
	            iso8601Scratch.iso8601 = packetInterval;
	            combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
	            if (defined(constrainedInterval)) {
	                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
	            }
	        } else if (defined(constrainedInterval)) {
	            combinedInterval = constrainedInterval;
	        }

	        var packedLength;
	        var isSampled;
	        var unwrappedInterval;
	        var unwrappedIntervalLength;
	        var isReference = defined(packetData.reference);
	        var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);

	        if (!isReference) {
	            unwrappedInterval = unwrapInterval(type, packetData, sourceUri);
	            packedLength = defaultValue(type.packedLength, 1);
	            unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);
	            isSampled = !defined(packetData.array) && (typeof unwrappedInterval !== 'string') && unwrappedIntervalLength > packedLength;
	        }


	        //Any time a constant value is assigned, it completely blows away anything else.
	        if (!isSampled && !hasInterval) {
	            if (isReference) {
	                object[propertyName] = makeReference(entityCollection, packetData.reference);
	            } else if (defined(type.unpack)) {
	                object[propertyName] = new ConstantProperty(type.unpack(unwrappedInterval, 0));
	            } else {
	                object[propertyName] = new ConstantProperty(unwrappedInterval);
	            }
	            return;
	        }

	        var property = object[propertyName];

	        var epoch;
	        var packetEpoch = packetData.epoch;
	        if (defined(packetEpoch)) {
	            epoch = JulianDate.fromIso8601(packetEpoch);
	        }

	        //Without an interval, any sampled value is infinite, meaning it completely
	        //replaces any non-sampled property that may exist.
	        if (isSampled && !hasInterval) {
	            if (!(property instanceof SampledProperty)) {
	                property = new SampledProperty(type);
	                object[propertyName] = property;
	            }
	            property.addSamplesPackedArray(unwrappedInterval, epoch);
	            updateInterpolationSettings(packetData, property);
	            return;
	        }

	        var interval;

	        //A constant value with an interval is normally part of a TimeIntervalCollection,
	        //However, if the current property is not a time-interval collection, we need
	        //to turn it into a Composite, preserving the old data with the new interval.
	        if (!isSampled && hasInterval) {
	            //Create a new interval for the constant value.
	            combinedInterval = combinedInterval.clone();
	            if (isReference) {
	                combinedInterval.data = makeReference(entityCollection, packetData.reference);
	            } else if (defined(type.unpack)) {
	                combinedInterval.data = type.unpack(unwrappedInterval, 0);
	            } else {
	                combinedInterval.data = unwrappedInterval;
	            }

	            //If no property exists, simply use a new interval collection
	            if (!defined(property)) {
	                if (isReference) {
	                    property = new CompositeProperty();
	                } else {
	                    property = new TimeIntervalCollectionProperty();
	                }
	                object[propertyName] = property;
	            }

	            if (!isReference && property instanceof TimeIntervalCollectionProperty) {
	                //If we create a collection, or it already existed, use it.
	                property.intervals.addInterval(combinedInterval);
	            } else if (property instanceof CompositeProperty) {
	                //If the collection was already a CompositeProperty, use it.
	                combinedInterval.data = isReference ? combinedInterval.data : new ConstantProperty(combinedInterval.data);
	                property.intervals.addInterval(combinedInterval);
	            } else {
	                //Otherwise, create a CompositeProperty but preserve the existing data.

	                //Put the old property in an infinite interval.
	                interval = Iso8601.MAXIMUM_INTERVAL.clone();
	                interval.data = property;

	                //Create the composite.
	                property = new CompositeProperty();
	                object[propertyName] = property;

	                //add the old property interval
	                property.intervals.addInterval(interval);

	                //Change the new data to a ConstantProperty and add it.
	                combinedInterval.data = isReference ? combinedInterval.data : new ConstantProperty(combinedInterval.data);
	                property.intervals.addInterval(combinedInterval);
	            }

	            return;
	        }

	        //isSampled && hasInterval
	        if (!defined(property)) {
	            property = new CompositeProperty();
	            object[propertyName] = property;
	        }

	        //create a CompositeProperty but preserve the existing data.
	        if (!(property instanceof CompositeProperty)) {
	            //Put the old property in an infinite interval.
	            interval = Iso8601.MAXIMUM_INTERVAL.clone();
	            interval.data = property;

	            //Create the composite.
	            property = new CompositeProperty();
	            object[propertyName] = property;

	            //add the old property interval
	            property.intervals.addInterval(interval);
	        }

	        //Check if the interval already exists in the composite
	        var intervals = property.intervals;
	        interval = intervals.findInterval(combinedInterval);
	        if (!defined(interval) || !(interval.data instanceof SampledProperty)) {
	            //If not, create a SampledProperty for it.
	            interval = combinedInterval.clone();
	            interval.data = new SampledProperty(type);
	            intervals.addInterval(interval);
	        }
	        interval.data.addSamplesPackedArray(unwrappedInterval, epoch);
	        updateInterpolationSettings(packetData, interval.data);
	        return;
	    }

	    function processPacketData(type, object, propertyName, packetData, interval, sourceUri, entityCollection) {
	        if (!defined(packetData)) {
	            return;
	        }

	        if (isArray(packetData)) {
	            for (var i = 0, len = packetData.length; i < len; i++) {
	                processProperty(type, object, propertyName, packetData[i], interval, sourceUri, entityCollection);
	            }
	        } else {
	            processProperty(type, object, propertyName, packetData, interval, sourceUri, entityCollection);
	        }
	    }

	    function processPositionProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
	        var combinedInterval;
	        var packetInterval = packetData.interval;
	        if (defined(packetInterval)) {
	            iso8601Scratch.iso8601 = packetInterval;
	            combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
	            if (defined(constrainedInterval)) {
	                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
	            }
	        } else if (defined(constrainedInterval)) {
	            combinedInterval = constrainedInterval;
	        }

	        var referenceFrame;
	        var unwrappedInterval;
	        var isSampled = false;
	        var unwrappedIntervalLength;
	        var numberOfDerivatives = defined(packetData.cartesianVelocity) ? 1 : 0;
	        var packedLength = Cartesian3.packedLength * (numberOfDerivatives + 1);
	        var isReference = defined(packetData.reference);
	        var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);

	        var property = object[propertyName];

	        if (!isReference) {
	            var packetReferenceFrame = packetData.referenceFrame;
	            if (defined(packetReferenceFrame)) {
	                referenceFrame = ReferenceFrame[packetReferenceFrame];
	                if (!defined(referenceFrame)) {
	                    var currentReferenceFrame = defined(property) && property.referenceFrame;
	                    referenceFrame = makeReferenceEntity(entityCollection, packetReferenceFrame, currentReferenceFrame);
	                }
	            }
	            unwrappedInterval = unwrapCartesianInterval(packetData);
	            unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);
	            isSampled = unwrappedIntervalLength > packedLength;
	        }

	        //Any time a constant value is assigned, it completely blows away anything else.
	        if (!isSampled && !hasInterval) {
	            if (isReference) {
	                object[propertyName] = makeReference(entityCollection, packetData.reference);
	            } else {
	                object[propertyName] = new ConstantPositionProperty(Cartesian3.unpack(unwrappedInterval), referenceFrame);
	            }
	            return;
	        }

	        var epoch;
	        var packetEpoch = packetData.epoch;
	        if (defined(packetEpoch)) {
	            epoch = JulianDate.fromIso8601(packetEpoch);
	        }

	        //Without an interval, any sampled value is infinite, meaning it completely
	        //replaces any non-sampled property that may exist.
	        if (isSampled && !hasInterval) {
	            if (!(property instanceof SampledPositionProperty) || (defined(referenceFrame) && property.referenceFrame !== referenceFrame)) {
	                property = new SampledPositionProperty(referenceFrame, numberOfDerivatives);
	                object[propertyName] = property;
	            }
	            property.addSamplesPackedArray(unwrappedInterval, epoch);
	            updateInterpolationSettings(packetData, property);
	            return;
	        }

	        var interval;

	        //A constant value with an interval is normally part of a TimeIntervalCollection,
	        //However, if the current property is not a time-interval collection, we need
	        //to turn it into a Composite, preserving the old data with the new interval.
	        if (!isSampled && hasInterval) {
	            //Create a new interval for the constant value.
	            combinedInterval = combinedInterval.clone();
	            if (isReference) {
	                combinedInterval.data = makeReference(entityCollection, packetData.reference);
	            } else {
	                combinedInterval.data = Cartesian3.unpack(unwrappedInterval);
	            }

	            //If no property exists, simply use a new interval collection
	            if (!defined(property)) {
	                if (isReference) {
	                    property = new CompositePositionProperty(referenceFrame);
	                } else {
	                    property = new TimeIntervalCollectionPositionProperty(referenceFrame);
	                }
	                object[propertyName] = property;
	            }

	            if (!isReference && property instanceof TimeIntervalCollectionPositionProperty && (defined(referenceFrame) && property.referenceFrame === referenceFrame)) {
	                //If we create a collection, or it already existed, use it.
	                property.intervals.addInterval(combinedInterval);
	            } else if (property instanceof CompositePositionProperty) {
	                //If the collection was already a CompositePositionProperty, use it.
	                combinedInterval.data = isReference ? combinedInterval.data : new ConstantPositionProperty(combinedInterval.data, referenceFrame);
	                property.intervals.addInterval(combinedInterval);
	            } else {
	                //Otherwise, create a CompositePositionProperty but preserve the existing data.

	                //Put the old property in an infinite interval.
	                interval = Iso8601.MAXIMUM_INTERVAL.clone();
	                interval.data = property;

	                //Create the composite.
	                property = new CompositePositionProperty(property.referenceFrame);
	                object[propertyName] = property;

	                //add the old property interval
	                property.intervals.addInterval(interval);

	                //Change the new data to a ConstantPositionProperty and add it.
	                combinedInterval.data = isReference ? combinedInterval.data : new ConstantPositionProperty(combinedInterval.data, referenceFrame);
	                property.intervals.addInterval(combinedInterval);
	            }

	            return;
	        }

	        //isSampled && hasInterval
	        if (!defined(property)) {
	            property = new CompositePositionProperty(referenceFrame);
	            object[propertyName] = property;
	        } else if (!(property instanceof CompositePositionProperty)) {
	            //create a CompositeProperty but preserve the existing data.
	            //Put the old property in an infinite interval.
	            interval = Iso8601.MAXIMUM_INTERVAL.clone();
	            interval.data = property;

	            //Create the composite.
	            property = new CompositePositionProperty(property.referenceFrame);
	            object[propertyName] = property;

	            //add the old property interval
	            property.intervals.addInterval(interval);
	        }

	        //Check if the interval already exists in the composite
	        var intervals = property.intervals;
	        interval = intervals.findInterval(combinedInterval);
	        if (!defined(interval) || !(interval.data instanceof SampledPositionProperty) || (defined(referenceFrame) && interval.data.referenceFrame !== referenceFrame)) {
	            //If not, create a SampledPositionProperty for it.
	            interval = combinedInterval.clone();
	            interval.data = new SampledPositionProperty(referenceFrame, numberOfDerivatives);
	            intervals.addInterval(interval);
	        }
	        interval.data.addSamplesPackedArray(unwrappedInterval, epoch);
	        updateInterpolationSettings(packetData, interval.data);
	    }

	    function processPositionPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {
	        if (!defined(packetData)) {
	            return;
	        }

	        if (isArray(packetData)) {
	            for (var i = 0, len = packetData.length; i < len; i++) {
	                processPositionProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);
	            }
	        } else {
	            processPositionProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);
	        }
	    }

	    function processMaterialProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
	        var combinedInterval;
	        var packetInterval = packetData.interval;
	        if (defined(packetInterval)) {
	            iso8601Scratch.iso8601 = packetInterval;
	            combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
	            if (defined(constrainedInterval)) {
	                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
	            }
	        } else if (defined(constrainedInterval)) {
	            combinedInterval = constrainedInterval;
	        }

	        var property = object[propertyName];
	        var existingMaterial;
	        var existingInterval;

	        if (defined(combinedInterval)) {
	            if (!(property instanceof CompositeMaterialProperty)) {
	                property = new CompositeMaterialProperty();
	                object[propertyName] = property;
	            }
	            //See if we already have data at that interval.
	            var thisIntervals = property.intervals;
	            existingInterval = thisIntervals.findInterval({
	                start : combinedInterval.start,
	                stop : combinedInterval.stop
	            });
	            if (defined(existingInterval)) {
	                //We have an interval, but we need to make sure the
	                //new data is the same type of material as the old data.
	                existingMaterial = existingInterval.data;
	            } else {
	                //If not, create it.
	                existingInterval = combinedInterval.clone();
	                thisIntervals.addInterval(existingInterval);
	            }
	        } else {
	            existingMaterial = property;
	        }

	        var materialData;
	        if (defined(packetData.solidColor)) {
	            if (!(existingMaterial instanceof ColorMaterialProperty)) {
	                existingMaterial = new ColorMaterialProperty();
	            }
	            materialData = packetData.solidColor;
	            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);
	        } else if (defined(packetData.grid)) {
	            if (!(existingMaterial instanceof GridMaterialProperty)) {
	                existingMaterial = new GridMaterialProperty();
	            }
	            materialData = packetData.grid;
	            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
	            processPacketData(Number, existingMaterial, 'cellAlpha', materialData.cellAlpha, undefined, sourceUri, entityCollection);
	            processPacketData(Cartesian2, existingMaterial, 'lineThickness', materialData.lineThickness, undefined, sourceUri, entityCollection);
	            processPacketData(Cartesian2, existingMaterial, 'lineOffset', materialData.lineOffset, undefined, sourceUri, entityCollection);
	            processPacketData(Cartesian2, existingMaterial, 'lineCount', materialData.lineCount, undefined, sourceUri, entityCollection);
	        } else if (defined(packetData.image)) {
	            if (!(existingMaterial instanceof ImageMaterialProperty)) {
	                existingMaterial = new ImageMaterialProperty();
	            }
	            materialData = packetData.image;
	            processPacketData(Image, existingMaterial, 'image', materialData.image, undefined, sourceUri, entityCollection);
	            processPacketData(Cartesian2, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);
	        } else if (defined(packetData.stripe)) {
	            if (!(existingMaterial instanceof StripeMaterialProperty)) {
	                existingMaterial = new StripeMaterialProperty();
	            }
	            materialData = packetData.stripe;
	            processPacketData(StripeOrientation, existingMaterial, 'orientation', materialData.orientation, undefined, sourceUri, entityCollection);
	            processPacketData(Color, existingMaterial, 'evenColor', materialData.evenColor, undefined, sourceUri, entityCollection);
	            processPacketData(Color, existingMaterial, 'oddColor', materialData.oddColor, undefined, sourceUri, entityCollection);
	            processPacketData(Number, existingMaterial, 'offset', materialData.offset, undefined, sourceUri, entityCollection);
	            processPacketData(Number, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);
	        } else if (defined(packetData.polylineOutline)) {
	            if (!(existingMaterial instanceof PolylineOutlineMaterialProperty)) {
	                existingMaterial = new PolylineOutlineMaterialProperty();
	            }
	            materialData = packetData.polylineOutline;
	            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
	            processPacketData(Color, existingMaterial, 'outlineColor', materialData.outlineColor, undefined, sourceUri, entityCollection);
	            processPacketData(Number, existingMaterial, 'outlineWidth', materialData.outlineWidth, undefined, sourceUri, entityCollection);
	        } else if (defined(packetData.polylineGlow)) {
	            if (!(existingMaterial instanceof PolylineGlowMaterialProperty)) {
	                existingMaterial = new PolylineGlowMaterialProperty();
	            }
	            materialData = packetData.polylineGlow;
	            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
	            processPacketData(Number, existingMaterial, 'glowPower', materialData.glowPower, undefined, sourceUri, entityCollection);
	        }

	        if (defined(existingInterval)) {
	            existingInterval.data = existingMaterial;
	        } else {
	            object[propertyName] = existingMaterial;
	        }
	    }

	    function processMaterialPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {
	        if (!defined(packetData)) {
	            return;
	        }

	        if (isArray(packetData)) {
	            for (var i = 0, len = packetData.length; i < len; i++) {
	                processMaterialProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);
	            }
	        } else {
	            processMaterialProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);
	        }
	    }

	    function processName(entity, packet, entityCollection, sourceUri) {
	        entity.name = defaultValue(packet.name, entity.name);
	    }

	    function processDescription(entity, packet, entityCollection, sourceUri) {
	        var descriptionData = packet.description;
	        if (defined(descriptionData)) {
	            processPacketData(String, entity, 'description', descriptionData, undefined, sourceUri, entityCollection);
	        }
	    }

	    function processPosition(entity, packet, entityCollection, sourceUri) {
	        var positionData = packet.position;
	        if (defined(positionData)) {
	            processPositionPacketData(entity, 'position', positionData, undefined, sourceUri, entityCollection);
	        }
	    }

	    function processViewFrom(entity, packet, entityCollection, sourceUri) {
	        var viewFromData = packet.viewFrom;
	        if (defined(viewFromData)) {
	            processPacketData(Cartesian3, entity, 'viewFrom', viewFromData, undefined, sourceUri, entityCollection);
	        }
	    }

	    function processOrientation(entity, packet, entityCollection, sourceUri) {
	        var orientationData = packet.orientation;
	        if (defined(orientationData)) {
	            processPacketData(Quaternion, entity, 'orientation', orientationData, undefined, sourceUri, entityCollection);
	        }
	    }

	    function processVertexData(object, propertyName, positionsData, entityCollection) {
	        var i;
	        var len;
	        var references = positionsData.references;
	        if (defined(references)) {
	            var properties = [];
	            for (i = 0, len = references.length; i < len; i++) {
	                properties.push(makeReference(entityCollection, references[i]));
	            }

	            var iso8601Interval = positionsData.interval;
	            if (defined(iso8601Interval)) {
	                iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
	                if (!(object[propertyName] instanceof CompositePositionProperty)) {
	                    iso8601Interval.data = new PositionPropertyArray(properties);
	                    var property = new CompositePositionProperty();
	                    property.intervals.addInterval(iso8601Interval);
	                    object[propertyName] = property;
	                }
	            } else {
	                object[propertyName] = new PositionPropertyArray(properties);
	            }
	        } else {
	            var values = [];
	            var tmp = positionsData.cartesian;
	            if (defined(tmp)) {
	                for (i = 0, len = tmp.length; i < len; i += 3) {
	                    values.push(new Cartesian3(tmp[i], tmp[i + 1], tmp[i + 2]));
	                }
	                positionsData.array = values;
	            } else {
	                tmp = positionsData.cartographicRadians;
	                if (defined(tmp)) {
	                    for (i = 0, len = tmp.length; i < len; i += 3) {
	                        scratchCartographic.longitude = tmp[i];
	                        scratchCartographic.latitude = tmp[i + 1];
	                        scratchCartographic.height = tmp[i + 2];
	                        values.push(Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic));
	                    }
	                    positionsData.array = values;
	                } else {
	                    tmp = positionsData.cartographicDegrees;
	                    if (defined(tmp)) {
	                        for (i = 0, len = tmp.length; i < len; i += 3) {
	                            values.push(Cartesian3.fromDegrees(tmp[i], tmp[i + 1], tmp[i + 2]));
	                        }
	                        positionsData.array = values;
	                    }
	                }
	            }
	            if (defined(positionsData.array)) {
	                processPacketData(Array, object, propertyName, positionsData, undefined, undefined, entityCollection);
	            }
	        }
	    }

	    function processPositions(object, propertyName, positionsData, entityCollection) {
	        if (!defined(positionsData)) {
	            return;
	        }

	        if (isArray(positionsData)) {
	            var length = positionsData.length;
	            for (var i = 0; i < length; i++) {
	                processVertexData(object, propertyName, positionsData[i], entityCollection);
	            }
	        } else {
	            processVertexData(object, propertyName, positionsData, entityCollection);
	        }
	    }

	    function processAvailability(entity, packet, entityCollection, sourceUri) {
	        var interval;
	        var packetData = packet.availability;
	        if (!defined(packetData)) {
	            return;
	        }

	        var intervals;
	        if (isArray(packetData)) {
	            var length = packetData.length;
	            for (var i = 0; i < length; i++) {
	                if (!defined(intervals)) {
	                    intervals = new TimeIntervalCollection();
	                }
	                iso8601Scratch.iso8601 = packetData[i];
	                interval = TimeInterval.fromIso8601(iso8601Scratch);
	                intervals.addInterval(interval);
	            }
	        } else {
	            iso8601Scratch.iso8601 = packetData;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	            intervals = new TimeIntervalCollection();
	            intervals.addInterval(interval);
	        }
	        entity.availability = intervals;
	    }

	    var iso8601Scratch = {
	        iso8601 : undefined
	    };

	    function processBillboard(entity, packet, entityCollection, sourceUri) {
	        var billboardData = packet.billboard;
	        if (!defined(billboardData)) {
	            return;
	        }

	        var interval;
	        var intervalString = billboardData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var billboard = entity.billboard;
	        if (!defined(billboard)) {
	            entity.billboard = billboard = new BillboardGraphics();
	        }

	        processPacketData(Color, billboard, 'color', billboardData.color, interval, sourceUri, entityCollection);
	        processPacketData(Cartesian3, billboard, 'eyeOffset', billboardData.eyeOffset, interval, sourceUri, entityCollection);
	        processPacketData(HorizontalOrigin, billboard, 'horizontalOrigin', billboardData.horizontalOrigin, interval, sourceUri, entityCollection);
	        processPacketData(Image, billboard, 'image', billboardData.image, interval, sourceUri, entityCollection);
	        processPacketData(Cartesian2, billboard, 'pixelOffset', billboardData.pixelOffset, interval, sourceUri, entityCollection);
	        processPacketData(Number, billboard, 'scale', billboardData.scale, interval, sourceUri, entityCollection);
	        processPacketData(Number, billboard, 'rotation', billboardData.rotation, interval, sourceUri, entityCollection);
	        processPacketData(Cartesian3, billboard, 'alignedAxis', billboardData.alignedAxis, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, billboard, 'show', billboardData.show, interval, sourceUri, entityCollection);
	        processPacketData(VerticalOrigin, billboard, 'verticalOrigin', billboardData.verticalOrigin, interval, sourceUri, entityCollection);
	    }

	    function processDocument(packet, dataSource) {
	        var version = packet.version;
	        if (defined(version)) {
	            if (typeof version === 'string') {
	                var tokens = version.split('.');
	                if (tokens.length === 2) {
	                    if (tokens[0] !== '1') {
	                        throw new RuntimeError('Cesium only supports CZML version 1.');
	                    }
	                    dataSource._version = version;
	                }
	            }
	        }

	        if (!defined(dataSource._version)) {
	            throw new RuntimeError('CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.');
	        }

	        var documentPacket = dataSource._documentPacket;

	        if (defined(packet.name)) {
	            documentPacket.name = packet.name;
	        }

	        var clockPacket = packet.clock;
	        if (defined(clockPacket)) {
	            var clock = documentPacket.clock;
	            if (!defined(clock)) {
	                documentPacket.clock = {
	                    interval : clockPacket.interval,
	                    currentTime : clockPacket.currentTime,
	                    range : clockPacket.range,
	                    step : clockPacket.step,
	                    multiplier : clockPacket.multiplier
	                };
	            } else {
	                clock.interval = defaultValue(clockPacket.interval, clock.interval);
	                clock.currentTime = defaultValue(clockPacket.currentTime, clock.currentTime);
	                clock.range = defaultValue(clockPacket.range, clock.range);
	                clock.step = defaultValue(clockPacket.step, clock.step);
	                clock.multiplier = defaultValue(clockPacket.multiplier, clock.multiplier);
	            }
	        }
	    }

	    function processEllipse(entity, packet, entityCollection, sourceUri) {
	        var ellipseData = packet.ellipse;
	        if (!defined(ellipseData)) {
	            return;
	        }

	        var interval;
	        var intervalString = ellipseData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var ellipse = entity.ellipse;
	        if (!defined(ellipse)) {
	            entity.ellipse = ellipse = new EllipseGraphics();
	        }

	        processPacketData(Boolean, ellipse, 'show', ellipseData.show, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'rotation', ellipseData.rotation, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'semiMajorAxis', ellipseData.semiMajorAxis, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'semiMinorAxis', ellipseData.semiMinorAxis, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'height', ellipseData.height, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'extrudedHeight', ellipseData.extrudedHeight, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'granularity', ellipseData.granularity, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'stRotation', ellipseData.stRotation, interval, sourceUri, entityCollection);
	        processMaterialPacketData(ellipse, 'material', ellipseData.material, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, ellipse, 'fill', ellipseData.fill, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, ellipse, 'outline', ellipseData.outline, interval, sourceUri, entityCollection);
	        processPacketData(Color, ellipse, 'outlineColor', ellipseData.outlineColor, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'outlineWidth', ellipseData.outlineWidth, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipse, 'numberOfVerticalLines', ellipseData.numberOfVerticalLines, interval, sourceUri, entityCollection);
	    }

	    function processEllipsoid(entity, packet, entityCollection, sourceUri) {
	        var ellipsoidData = packet.ellipsoid;
	        if (!defined(ellipsoidData)) {
	            return;
	        }

	        var interval;
	        var intervalString = ellipsoidData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var ellipsoid = entity.ellipsoid;
	        if (!defined(ellipsoid)) {
	            entity.ellipsoid = ellipsoid = new EllipsoidGraphics();
	        }

	        processPacketData(Boolean, ellipsoid, 'show', ellipsoidData.show, interval, sourceUri, entityCollection);
	        processPacketData(Cartesian3, ellipsoid, 'radii', ellipsoidData.radii, interval, sourceUri, entityCollection);
	        processMaterialPacketData(ellipsoid, 'material', ellipsoidData.material, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, ellipsoid, 'fill', ellipsoidData.fill, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, ellipsoid, 'outline', ellipsoidData.outline, interval, sourceUri, entityCollection);
	        processPacketData(Color, ellipsoid, 'outlineColor', ellipsoidData.outlineColor, interval, sourceUri, entityCollection);
	        processPacketData(Number, ellipsoid, 'outlineWidth', ellipsoidData.outlineWidth, interval, sourceUri, entityCollection);
	    }

	    function processLabel(entity, packet, entityCollection, sourceUri) {
	        var labelData = packet.label;
	        if (!defined(labelData)) {
	            return;
	        }

	        var interval;
	        var intervalString = labelData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var label = entity.label;
	        if (!defined(label)) {
	            entity.label = label = new LabelGraphics();
	        }

	        processPacketData(Color, label, 'fillColor', labelData.fillColor, interval, sourceUri, entityCollection);
	        processPacketData(Color, label, 'outlineColor', labelData.outlineColor, interval, sourceUri, entityCollection);
	        processPacketData(Number, label, 'outlineWidth', labelData.outlineWidth, interval, sourceUri, entityCollection);
	        processPacketData(Cartesian3, label, 'eyeOffset', labelData.eyeOffset, interval, sourceUri, entityCollection);
	        processPacketData(HorizontalOrigin, label, 'horizontalOrigin', labelData.horizontalOrigin, interval, sourceUri, entityCollection);
	        processPacketData(String, label, 'text', labelData.text, interval, sourceUri, entityCollection);
	        processPacketData(Cartesian2, label, 'pixelOffset', labelData.pixelOffset, interval, sourceUri, entityCollection);
	        processPacketData(Number, label, 'scale', labelData.scale, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, label, 'show', labelData.show, interval, sourceUri, entityCollection);
	        processPacketData(VerticalOrigin, label, 'verticalOrigin', labelData.verticalOrigin, interval, sourceUri, entityCollection);
	        processPacketData(String, label, 'font', labelData.font, interval, sourceUri, entityCollection);
	        processPacketData(LabelStyle, label, 'style', labelData.style, interval, sourceUri, entityCollection);
	    }

	    function processModel(entity, packet, entityCollection, sourceUri) {
	        var modelData = packet.model;
	        if (!defined(modelData)) {
	            return;
	        }

	        var interval;
	        var intervalString = modelData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var model = entity.model;
	        if (!defined(model)) {
	            entity.model = model = new ModelGraphics();
	        }

	        processPacketData(Boolean, model, 'show', modelData.show, interval, sourceUri, entityCollection);
	        processPacketData(Number, model, 'scale', modelData.scale, interval, sourceUri, entityCollection);
	        processPacketData(Number, model, 'minimumPixelSize', modelData.minimumPixelSize, interval, sourceUri, entityCollection);
	        processPacketData(Uri, model, 'uri', modelData.gltf, interval, sourceUri, entityCollection);
	    }

	    function processPath(entity, packet, entityCollection, sourceUri) {
	        var pathData = packet.path;
	        if (!defined(pathData)) {
	            return;
	        }

	        var interval;
	        var intervalString = pathData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var path = entity.path;
	        if (!defined(path)) {
	            entity.path = path = new PathGraphics();
	        }

	        processPacketData(Boolean, path, 'show', pathData.show, interval, sourceUri, entityCollection);
	        processPacketData(Number, path, 'width', pathData.width, interval, sourceUri, entityCollection);
	        processPacketData(Number, path, 'resolution', pathData.resolution, interval, sourceUri, entityCollection);
	        processPacketData(Number, path, 'leadTime', pathData.leadTime, interval, sourceUri, entityCollection);
	        processPacketData(Number, path, 'trailTime', pathData.trailTime, interval, sourceUri, entityCollection);
	        processMaterialPacketData(path, 'material', pathData.material, interval, sourceUri, entityCollection);
	    }

	    function processPoint(entity, packet, entityCollection, sourceUri) {
	        var pointData = packet.point;
	        if (!defined(pointData)) {
	            return;
	        }

	        var interval;
	        var intervalString = pointData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var point = entity.point;
	        if (!defined(point)) {
	            entity.point = point = new PointGraphics();
	        }

	        processPacketData(Color, point, 'color', pointData.color, interval, sourceUri, entityCollection);
	        processPacketData(Number, point, 'pixelSize', pointData.pixelSize, interval, sourceUri, entityCollection);
	        processPacketData(Color, point, 'outlineColor', pointData.outlineColor, interval, sourceUri, entityCollection);
	        processPacketData(Number, point, 'outlineWidth', pointData.outlineWidth, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, point, 'show', pointData.show, interval, sourceUri, entityCollection);
	    }

	    function processPolygon(entity, packet, entityCollection, sourceUri) {
	        var polygonData = packet.polygon;
	        if (!defined(polygonData)) {
	            return;
	        }

	        var interval;
	        var intervalString = polygonData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var polygon = entity.polygon;
	        if (!defined(polygon)) {
	            entity.polygon = polygon = new PolygonGraphics();
	        }

	        processPacketData(Boolean, polygon, 'show', polygonData.show, interval, sourceUri, entityCollection);
	        processMaterialPacketData(polygon, 'material', polygonData.material, interval, sourceUri, entityCollection);
	        processPacketData(Number, polygon, 'height', polygonData.height, interval, sourceUri, entityCollection);
	        processPacketData(Number, polygon, 'extrudedHeight', polygonData.extrudedHeight, interval, sourceUri, entityCollection);
	        processPacketData(Number, polygon, 'granularity', polygonData.granularity, interval, sourceUri, entityCollection);
	        processPacketData(Number, polygon, 'stRotation', polygonData.stRotation, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, polygon, 'fill', polygonData.fill, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, polygon, 'outline', polygonData.outline, interval, sourceUri, entityCollection);
	        processPacketData(Color, polygon, 'outlineColor', polygonData.outlineColor, interval, sourceUri, entityCollection);
	        processPacketData(Number, polygon, 'outlineWidth', polygonData.outlineWidth, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, polygon, 'perPositionHeight', polygonData.perPositionHeight, interval, sourceUri, entityCollection);
	        processPositions(polygon, 'hierarchy', polygonData.positions, entityCollection);
	    }

	    function processRectangle(entity, packet, entityCollection, sourceUri) {
	        var rectangleData = packet.rectangle;
	        if (!defined(rectangleData)) {
	            return;
	        }

	        var interval;
	        var intervalString = rectangleData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var rectangle = entity.rectangle;
	        if (!defined(rectangle)) {
	            entity.rectangle = rectangle = new RectangleGraphics();
	        }

	        processPacketData(Boolean, rectangle, 'show', rectangleData.show, interval, sourceUri, entityCollection);
	        processPacketData(Rectangle, rectangle, 'coordinates', rectangleData.coordinates, interval, sourceUri, entityCollection);
	        processMaterialPacketData(rectangle, 'material', rectangleData.material, interval, sourceUri, entityCollection);
	        processPacketData(Number, rectangle, 'height', rectangleData.height, interval, sourceUri, entityCollection);
	        processPacketData(Number, rectangle, 'extrudedHeight', rectangleData.extrudedHeight, interval, sourceUri, entityCollection);
	        processPacketData(Number, rectangle, 'granularity', rectangleData.granularity, interval, sourceUri, entityCollection);
	        processPacketData(Number, rectangle, 'rotation', rectangleData.rotation, interval, sourceUri, entityCollection);
	        processPacketData(Number, rectangle, 'stRotation', rectangleData.stRotation, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, rectangle, 'fill', rectangleData.fill, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, rectangle, 'outline', rectangleData.outline, interval, sourceUri, entityCollection);
	        processPacketData(Color, rectangle, 'outlineColor', rectangleData.outlineColor, interval, sourceUri, entityCollection);
	        processPacketData(Number, rectangle, 'outlineWidth', rectangleData.outlineWidth, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, rectangle, 'closeBottom', rectangleData.closeBottom, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, rectangle, 'closeTop', rectangleData.closeTop, interval, sourceUri, entityCollection);
	    }

	    function processWall(entity, packet, entityCollection, sourceUri) {
	        var wallData = packet.wall;
	        if (!defined(wallData)) {
	            return;
	        }

	        var interval;
	        var intervalString = wallData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var wall = entity.wall;
	        if (!defined(wall)) {
	            entity.wall = wall = new WallGraphics();
	        }

	        processPacketData(Boolean, wall, 'show', wallData.show, interval, sourceUri, entityCollection);
	        processMaterialPacketData(wall, 'material', wallData.material, interval, sourceUri, entityCollection);
	        processPacketData(Array, wall, 'minimumHeights', wallData.minimumHeights, interval, sourceUri, entityCollection);
	        processPacketData(Array, wall, 'maximumHeights', wallData.maximumHeights, interval, sourceUri, entityCollection);
	        processPacketData(Number, wall, 'granularity', wallData.granularity, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, wall, 'fill', wallData.fill, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, wall, 'outline', wallData.outline, interval, sourceUri, entityCollection);
	        processPacketData(Color, wall, 'outlineColor', wallData.outlineColor, interval, sourceUri, entityCollection);
	        processPacketData(Number, wall, 'outlineWidth', wallData.outlineWidth, interval, sourceUri, entityCollection);
	        processPositions(wall, 'positions', wallData.positions, entityCollection);
	    }

	    function processPolyline(entity, packet, entityCollection, sourceUri) {
	        var polylineData = packet.polyline;
	        if (!defined(polylineData)) {
	            return;
	        }

	        var interval;
	        var intervalString = polylineData.interval;
	        if (defined(intervalString)) {
	            iso8601Scratch.iso8601 = intervalString;
	            interval = TimeInterval.fromIso8601(iso8601Scratch);
	        }

	        var polyline = entity.polyline;
	        if (!defined(polyline)) {
	            entity.polyline = polyline = new PolylineGraphics();
	        }

	        processPacketData(Boolean, polyline, 'show', polylineData.show, interval, sourceUri, entityCollection);
	        processPacketData(Number, polyline, 'width', polylineData.width, interval, sourceUri, entityCollection);
	        processMaterialPacketData(polyline, 'material', polylineData.material, interval, sourceUri, entityCollection);
	        processPacketData(Boolean, polyline, 'followSurface', polylineData.followSurface, interval, sourceUri, entityCollection);
	        processPacketData(Number, polyline, 'granularity', polylineData.granularity, interval, sourceUri, entityCollection);
	        processPositions(polyline, 'positions', polylineData.positions, entityCollection);
	    }

	    function processCzmlPacket(packet, entityCollection, updaterFunctions, sourceUri, dataSource) {
	        var objectId = packet.id;
	        if (!defined(objectId)) {
	            objectId = createGuid();
	        }

	        currentId = objectId;

	        if (!defined(dataSource._version) && objectId !== 'document') {
	            throw new RuntimeError('The first CZML packet is required to be the document object.');
	        }

	        if (packet['delete'] === true) {
	            entityCollection.removeById(objectId);
	        } else if (objectId === 'document') {
	            processDocument(packet, dataSource);
	        } else {
	            var entity = entityCollection.getOrCreateEntity(objectId);

	            var parentId = packet.parent;
	            if (defined(parentId)) {
	                entity.parent = entityCollection.getOrCreateEntity(parentId);
	            }

	            for (var i = updaterFunctions.length - 1; i > -1; i--) {
	                updaterFunctions[i](entity, packet, entityCollection, sourceUri);
	            }
	        }

	        currentId = undefined;
	    }

	    function updateClock(dataSource) {
	        var clock;
	        var clockPacket = dataSource._documentPacket.clock;
	        if (!defined(clockPacket)) {
	            if (!defined(dataSource._clock)) {
	                var availability = dataSource._entityCollection.computeAvailability();
	                if (!availability.start.equals(Iso8601.MINIMUM_VALUE)) {
	                    var startTime = availability.start;
	                    var stopTime = availability.stop;
	                    var totalSeconds = JulianDate.secondsDifference(stopTime, startTime);
	                    var multiplier = Math.round(totalSeconds / 120.0);

	                    clock = new DataSourceClock();
	                    clock.startTime = JulianDate.clone(startTime);
	                    clock.stopTime = JulianDate.clone(stopTime);
	                    clock.clockRange = ClockRange.LOOP_STOP;
	                    clock.multiplier = multiplier;
	                    clock.currentTime = JulianDate.clone(startTime);
	                    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
	                    dataSource._clock = clock;
	                    return true;
	                }
	            }
	            return false;
	        }

	        if (defined(dataSource._clock)) {
	            clock = dataSource._clock.clone();
	        } else {
	            clock = new DataSourceClock();
	            clock.startTime = Iso8601.MINIMUM_VALUE.clone();
	            clock.stopTime = Iso8601.MAXIMUM_VALUE.clone();
	            clock.currentTime = Iso8601.MINIMUM_VALUE.clone();
	            clock.clockRange = ClockRange.LOOP_STOP;
	            clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
	            clock.multiplier = 1.0;
	        }
	        if (defined(clockPacket.interval)) {
	            iso8601Scratch.iso8601 = clockPacket.interval;
	            var interval = TimeInterval.fromIso8601(iso8601Scratch);
	            clock.startTime = interval.start;
	            clock.stopTime = interval.stop;
	        }
	        if (defined(clockPacket.currentTime)) {
	            clock.currentTime = JulianDate.fromIso8601(clockPacket.currentTime);
	        }
	        if (defined(clockPacket.range)) {
	            clock.clockRange = defaultValue(ClockRange[clockPacket.range], ClockRange.LOOP_STOP);
	        }
	        if (defined(clockPacket.step)) {
	            clock.clockStep = defaultValue(ClockStep[clockPacket.step], ClockStep.SYSTEM_CLOCK_MULTIPLIER);
	        }
	        if (defined(clockPacket.multiplier)) {
	            clock.multiplier = clockPacket.multiplier;
	        }

	        if (!clock.equals(dataSource._clock)) {
	            dataSource._clock = clock.clone(dataSource._clock);
	            return true;
	        }

	        return false;
	    }

	    function load(dataSource, czml, options, clear) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(czml)) {
	            throw new DeveloperError('czml is required.');
	        }
	        //>>includeEnd('debug');

	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        var promise = czml;
	        var sourceUri = options.sourceUri;
	        if (typeof czml === 'string') {
	            promise = loadJson(czml);
	            sourceUri = defaultValue(sourceUri, czml);
	        }

	        DataSource.setLoading(dataSource, true);

	        return when(promise, function(czml) {
	            return loadCzml(dataSource, czml, sourceUri, clear);
	        }).otherwise(function(error) {
	            DataSource.setLoading(dataSource, false);
	            dataSource._error.raiseEvent(dataSource, error);
	            window.console.log(error);
	            return when.reject(error);
	        });
	    }

	    function loadCzml(dataSource, czml, sourceUri, clear) {
	        DataSource.setLoading(dataSource, true);
	        var entityCollection = dataSource._entityCollection;

	        if (clear) {
	            dataSource._version = undefined;
	            dataSource._documentPacket = new DocumentPacket();
	            entityCollection.removeAll();
	        }

	        CzmlDataSource._processCzml(czml, entityCollection, sourceUri, undefined, dataSource);

	        var raiseChangedEvent = updateClock(dataSource);

	        var documentPacket = dataSource._documentPacket;
	        if (defined(documentPacket.name) && dataSource._name !== documentPacket.name) {
	            dataSource._name = documentPacket.name;
	            raiseChangedEvent = true;
	        } else if (!defined(dataSource._name) && defined(sourceUri)) {
	            dataSource._name = getFilenameFromUri(sourceUri);
	            raiseChangedEvent = true;
	        }

	        DataSource.setLoading(dataSource, false);
	        if (raiseChangedEvent) {
	            dataSource._changed.raiseEvent(dataSource);
	        }

	        return dataSource;
	    }

	    var DocumentPacket = function() {
	        this.name = undefined;
	        this.clock = undefined;
	    };

	    /**
	     * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Guide|CZML}.
	     * @alias CzmlDataSource
	     * @constructor
	     *
	     * @param {String} [name] An optional name for the data source.  This value will be overwritten if a loaded document contains a name.
	     *
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=CZML.html|Cesium Sandcastle CZML Demo}
	     */
	    var CzmlDataSource = function(name) {
	        this._name = name;
	        this._changed = new Event();
	        this._error = new Event();
	        this._isLoading = false;
	        this._loading = new Event();
	        this._clock = undefined;
	        this._documentPacket = new DocumentPacket();
	        this._version = undefined;
	        this._entityCollection = new EntityCollection();
	    };

	    /**
	     * Creates a Promise to a new instance loaded with the provided CZML data.
	     *
	     * @param {String|Object} data A url or CZML object to be processed.
	     * @param {Object} [options] An object with the following properties:
	     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
	     * @returns {Promise} A promise that resolves to the new instance once the data is processed.
	     */
	    CzmlDataSource.load = function(czml, options) {
	        return new CzmlDataSource().load(czml, options);
	    };

	    defineProperties(CzmlDataSource.prototype, {
	        /**
	         * Gets a human-readable name for this instance.
	         * @memberof CzmlDataSource.prototype
	         * @type {String}
	         */
	        name : {
	            get : function() {
	                return this._name;
	            }
	        },
	        /**
	         * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly
	         * defined in the CZML, the combined availability of all objects is returned.  If
	         * only static data exists, this value is undefined.
	         * @memberof CzmlDataSource.prototype
	         * @type {DataSourceClock}
	         */
	        clock : {
	            get : function() {
	                return this._clock;
	            }
	        },
	        /**
	         * Gets the collection of {@link Entity} instances.
	         * @memberof CzmlDataSource.prototype
	         * @type {EntityCollection}
	         */
	        entities : {
	            get : function() {
	                return this._entityCollection;
	            }
	        },
	        /**
	         * Gets a value indicating if the data source is currently loading data.
	         * @memberof CzmlDataSource.prototype
	         * @type {Boolean}
	         */
	        isLoading : {
	            get : function() {
	                return this._isLoading;
	            }
	        },
	        /**
	         * Gets an event that will be raised when the underlying data changes.
	         * @memberof CzmlDataSource.prototype
	         * @type {Event}
	         */
	        changedEvent : {
	            get : function() {
	                return this._changed;
	            }
	        },
	        /**
	         * Gets an event that will be raised if an error is encountered during processing.
	         * @memberof CzmlDataSource.prototype
	         * @type {Event}
	         */
	        errorEvent : {
	            get : function() {
	                return this._error;
	            }
	        },
	        /**
	         * Gets an event that will be raised when the data source either starts or stops loading.
	         * @memberof CzmlDataSource.prototype
	         * @type {Event}
	         */
	        loadingEvent : {
	            get : function() {
	                return this._loading;
	            }
	        }
	    });

	    /**
	     * Gets the array of CZML processing functions.
	     * @memberof CzmlDataSource
	     * @type Array
	     */
	    CzmlDataSource.updaters = [
	    processBillboard, //
	    processEllipse, //
	    processEllipsoid, //
	    processLabel, //
	    processModel, //
	    processName, //
	    processDescription, //
	    processPath, //
	    processPoint, //
	    processPolygon, //
	    processPolyline, //
	    processRectangle, //
	    processPosition, //
	    processViewFrom, //
	    processWall, //
	    processOrientation, //
	    processAvailability];

	    /**
	     * Processes the provided url or CZML object without clearing any existing data.
	     *
	     * @param {String|Object} data A url or CZML object to be processed.
	     * @param {Object} [options] An object with the following properties:
	     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
	     * @returns {Promise} A promise that resolves to this instances once the data is processed.
	     */
	    CzmlDataSource.prototype.process = function(czml, options) {
	        if (typeof options === 'string') {
	            options = {
	                sourceUri : options
	            };
	            deprecationWarning('CzmlDataSource.process.options', 'Passing a sourceUri string as the second paraameter to CzmlDataSource.process has been deprecated. Pass an options object instead.');
	        }
	        return load(this, czml, options, false);
	    };

	    /**
	     * Loads the provided url or CZML object, replacing any existing data.
	     *
	     * @param {String|Object} data A url or CZML object to be processed.
	     * @param {Object} [options] An object with the following properties:
	     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
	     * @returns {Promise} A promise that resolves to this instances once the data is processed.
	     */
	    CzmlDataSource.prototype.load = function(czml, options) {
	        if (typeof options === 'string') {
	            options = {
	                sourceUri : options
	            };
	            deprecationWarning('CzmlDataSource.process.load', 'Passing a sourceUri string as the second paraameter to CzmlDataSource.load has been deprecated. Pass an options object instead.');
	        }
	        return load(this, czml, options, true);
	    };

	    CzmlDataSource.prototype.processUrl = function(url) {
	        deprecationWarning('CzmlDataSource.prototype.processUrl', 'CzmlDataSource.processUrl has been deprecated.  Use CzmlDataSource.process instead.');
	        return this.process(url);
	    };

	    CzmlDataSource.prototype.loadUrl = function(url) {
	        deprecationWarning('CzmlDataSource.prototype.loadUrl', 'CzmlDataSource.loadUrl has been deprecated.  Use CzmlDataSource.load instead.');
	        return this.load(url);
	    };

	    /**
	     * A helper function used by custom CZML updater functions
	     * which creates or updates a {@link Property} from a CZML packet.
	     * @function
	     *
	     * @param {Function} type The constructor function for the property being processed.
	     * @param {Object} object The object on which the property will be added or updated.
	     * @param {String} propertyName The name of the property on the object.
	     * @param {Object} packetData The CZML packet being processed.
	     * @param {TimeInterval} interval A constraining interval for which the data is valid.
	     * @param {String} sourceUri The originating uri of the data being processed.
	     * @param {EntityCollection} entityCollection The collection being processsed.
	     */
	    CzmlDataSource.processPacketData = processPacketData;

	    /**
	     * A helper function used by custom CZML updater functions
	     * which creates or updates a {@link PositionProperty} from a CZML packet.
	     * @function
	     *
	     * @param {Object} object The object on which the property will be added or updated.
	     * @param {String} propertyName The name of the property on the object.
	     * @param {Object} packetData The CZML packet being processed.
	     * @param {TimeInterval} interval A constraining interval for which the data is valid.
	     * @param {String} sourceUri The originating uri of the data being processed.
	     * @param {EntityCollection} entityCollection The collection being processsed.
	     */
	    CzmlDataSource.processPositionPacketData = processPositionPacketData;

	    /**
	     * A helper function used by custom CZML updater functions
	     * which creates or updates a {@link MaterialProperty} from a CZML packet.
	     * @function
	     *
	     * @param {Object} object The object on which the property will be added or updated.
	     * @param {String} propertyName The name of the property on the object.
	     * @param {Object} packetData The CZML packet being processed.
	     * @param {TimeInterval} interval A constraining interval for which the data is valid.
	     * @param {String} sourceUri The originating uri of the data being processed.
	     * @param {EntityCollection} entityCollection The collection being processsed.
	     */
	    CzmlDataSource.processMaterialPacketData = processMaterialPacketData;

	    CzmlDataSource._processCzml = function(czml, entityCollection, sourceUri, updaterFunctions, dataSource) {
	        updaterFunctions = defined(updaterFunctions) ? updaterFunctions : CzmlDataSource.updaters;

	        if (isArray(czml)) {
	            for (var i = 0, len = czml.length; i < len; i++) {
	                processCzmlPacket(czml[i], entityCollection, updaterFunctions, sourceUri, dataSource);
	            }
	        } else {
	            processCzmlPacket(czml, entityCollection, updaterFunctions, sourceUri, dataSource);
	        }
	    };

	    return CzmlDataSource;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(4),
	        __webpack_require__(2)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defineProperties,
	        DeveloperError) {
	    "use strict";

	    /**
	     * Defines the interface for data sources, which turn arbitrary data into a
	     * {@link EntityCollection} for generic consumption. This object is an interface
	     * for documentation purposes and is not intended to be instantiated directly.
	     * @alias DataSource
	     * @constructor
	     *
	     * @see Entity
	     * @see DataSourceDisplay
	     */
	    var DataSource = function() {
	        DeveloperError.throwInstantiationError();
	    };

	    defineProperties(DataSource.prototype, {
	        /**
	         * Gets a human-readable name for this instance.
	         * @memberof DataSource.prototype
	         * @type {String}
	         */
	        name : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets the preferred clock settings for this data source.
	         * @memberof DataSource.prototype
	         * @type {DataSourceClock}
	         */
	        clock : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets the collection of {@link Entity} instances.
	         * @memberof DataSource.prototype
	         * @type {EntityCollection}
	         */
	        entities : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets a value indicating if the data source is currently loading data.
	         * @memberof DataSource.prototype
	         * @type {Boolean}
	         */
	        isLoading : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets an event that will be raised when the underlying data changes.
	         * @memberof DataSource.prototype
	         * @type {Event}
	         */
	        changedEvent : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets an event that will be raised if an error is encountered during processing.
	         * @memberof DataSource.prototype
	         * @type {Event}
	         */
	        errorEvent : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets an event that will be raised when the value of isLoading changes.
	         * @memberof DataSource.prototype
	         * @type {Event}
	         */
	        loadingEvent : {
	            get : DeveloperError.throwInstantiationError
	        }
	    });

	    /**
	     * Updates the data source to the provided time.  This function is optional and
	     * is not required to be implemented.  It is provided for data sources which
	     * retrieve data based on the current animation time or scene state.
	     * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
	     * @function
	     *
	     * @param {JulianDate} time The simulation time.
	     * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.
	     */
	    DataSource.prototype.update = DeveloperError.throwInstantiationError;

	    /**
	     * @private
	     */
	    DataSource.setLoading = function(dataSource, isLoading) {
	        if (dataSource._isLoading !== isLoading) {
	            if (isLoading) {
	                dataSource._entityCollection.suspendEvents();
	            } else {
	                dataSource._entityCollection.resumeEvents();
	            }
	            dataSource._isLoading = isLoading;
	            dataSource._loading.raiseEvent(dataSource, isLoading);
	        }
	    };

	    return DataSource;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(115),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(16),
	        __webpack_require__(141)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Clock,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        JulianDate,
	        createRawPropertyDescriptor) {
	    "use strict";

	    /**
	     * Represents CZML document-level clock settings.
	     *
	     * @alias DataSourceClock
	     * @constructor
	     */
	    var DataSourceClock = function() {
	        this._startTime = undefined;
	        this._stopTime = undefined;
	        this._currentTime = undefined;
	        this._clockRange = undefined;
	        this._clockStep = undefined;
	        this._multiplier = undefined;
	        this._definitionChanged = new Event();
	    };

	    defineProperties(DataSourceClock.prototype, {
	        /**
	         * Gets the event that is raised whenever a new property is assigned.
	         * @memberof DataSourceClock.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the start time of the clock to use when looping or clamped.
	         * @memberof DataSourceClock.prototype
	         * @type {JulianDate}
	         */
	        startTime : createRawPropertyDescriptor('startTime'),

	        /**
	         * Gets or sets the stop time of the clock to use when looping or clamped.
	         * @memberof DataSourceClock.prototype
	         * @type {JulianDate}
	         */
	        stopTime : createRawPropertyDescriptor('stopTime'),

	        /**
	         * Gets or sets the initial time to use when switching to this clock.
	         * @memberof DataSourceClock.prototype
	         * @type {JulianDate}
	         */
	        currentTime : createRawPropertyDescriptor('currentTime'),

	        /**
	         * Gets or sets how the clock should behave when <code>startTime</code> or <code>stopTime</code> is reached.
	         * @memberof DataSourceClock.prototype
	         * @type {ClockRange}
	         */
	        clockRange : createRawPropertyDescriptor('clockRange'),

	        /**
	         * Gets or sets if clock advancement is frame dependent or system clock dependent.
	         * @memberof DataSourceClock.prototype
	         * @type {ClockStep}
	         */
	        clockStep : createRawPropertyDescriptor('clockStep'),

	        /**
	         * Gets or sets how much time advances with each tick, negative values allow for advancing backwards.
	         * If <code>clockStep</code> is set to ClockStep.TICK_DEPENDENT this is the number of seconds to advance.
	         * If <code>clockStep</code> is set to ClockStep.SYSTEM_CLOCK_MULTIPLIER this value is multiplied by the
	         * elapsed system time since the last call to tick.
	         * @memberof DataSourceClock.prototype
	         * @type {Number}
	         */
	        multiplier : createRawPropertyDescriptor('multiplier')
	    });

	    /**
	     * Duplicates a DataSourceClock instance.
	     *
	     * @param {DataSourceClock} [result] The object onto which to store the result.
	     * @returns {DataSourceClock} The modified result parameter or a new instance if one was not provided.
	     */
	    DataSourceClock.prototype.clone = function(result) {
	        if (!defined(result)) {
	            result = new DataSourceClock();
	        }
	        result.startTime = this.startTime;
	        result.stopTime = this.stopTime;
	        result.currentTime = this.currentTime;
	        result.clockRange = this.clockRange;
	        result.clockStep = this.clockStep;
	        result.multiplier = this.multiplier;
	        return result;
	    };

	    /**
	     * Returns true if this DataSourceClock is equivalent to the other
	     *
	     * @param {DataSourceClock} other The other DataSourceClock to compare to.
	     * @returns {Boolean} <code>true</code> if the DataSourceClocks are equal; otherwise, <code>false</code>.
	     */
	    DataSourceClock.prototype.equals = function(other) {
	        return this === other ||
	               defined(other) &&
	               JulianDate.equals(this.startTime, other.startTime) &&
	               JulianDate.equals(this.stopTime, other.stopTime) &&
	               JulianDate.equals(this.currentTime, other.currentTime) &&
	               this.clockRange === other.clockRange &&
	               this.clockStep === other.clockStep &&
	               this.multiplier === other.multiplier;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {DataSourceClock} source The object to be merged into this object.
	     */
	    DataSourceClock.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.startTime = defaultValue(this.startTime, source.startTime);
	        this.stopTime = defaultValue(this.stopTime, source.stopTime);
	        this.currentTime = defaultValue(this.currentTime, source.currentTime);
	        this.clockRange = defaultValue(this.clockRange, source.clockRange);
	        this.clockStep = defaultValue(this.clockStep, source.clockStep);
	        this.multiplier = defaultValue(this.multiplier, source.multiplier);
	    };

	    /**
	     * Gets the value of this clock instance as a {@link Clock} object.
	     *
	     * @returns {Clock} The modified result parameter or a new instance if one was not provided.
	     */
	    DataSourceClock.prototype.getValue = function(result) {
	        if (!defined(result)) {
	            result = new Clock();
	        }
	        result.startTime = this.startTime;
	        result.stopTime = this.stopTime;
	        result.clockRange = this.clockRange;
	        result.clockStep = this.clockStep;
	        result.multiplier = this.multiplier;
	        result.currentTime = this.currentTime;
	        return result;
	    };

	    return DataSourceClock;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(34),
	        __webpack_require__(28),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(6),
	        __webpack_require__(8),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian2,
	        Color,
	        defaultValue,
	        defined,
	        defineProperties,
	        Event,
	        createPropertyDescriptor,
	        Property) {
	    "use strict";

	    var defaultColor = Color.WHITE;
	    var defaultCellAlpha = 0.1;
	    var defaultLineCount = new Cartesian2(8, 8);
	    var defaultLineOffset = new Cartesian2(0, 0);
	    var defaultLineThickness = new Cartesian2(1, 1);

	    /**
	     * A {@link MaterialProperty} that maps to grid {@link Material} uniforms.
	     * @alias GridMaterialProperty
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.color=Color.WHITE] A Property specifying the grid {@link Color}.
	     * @param {Property} [options.cellAlpha=0.1] A numeric Property specifying cell alpha values.
	     * @param {Property} [options.lineCount=new Cartesian2(8, 8)] A {@link Cartesian2} Property specifying the number of grid lines along each axis.
	     * @param {Property} [options.lineThickness=new Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
	     * @param {Property} [options.lineOffset=new Cartesian2(0.0, 0.0)] A {@link Cartesian2} Property specifying starting offset of grid lines along each axis.
	     *
	     * @constructor
	     */
	    var GridMaterialProperty = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        this._definitionChanged = new Event();
	        this._color = undefined;
	        this._colorSubscription = undefined;
	        this._cellAlpha = undefined;
	        this._cellAlphaSubscription = undefined;
	        this._lineCount = undefined;
	        this._lineCountSubscription = undefined;
	        this._lineThickness = undefined;
	        this._lineThicknessSubscription = undefined;
	        this._lineOffset = undefined;
	        this._lineOffsetSubscription = undefined;

	        this.color = options.color;
	        this.cellAlpha = options.cellAlpha;
	        this.lineCount = options.lineCount;
	        this.lineThickness = options.lineThickness;
	        this.lineOffset = options.lineOffset;
	    };

	    defineProperties(GridMaterialProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof GridMaterialProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return Property.isConstant(this._color) &&
	                       Property.isConstant(this._cellAlpha) &&
	                       Property.isConstant(this._lineCount) &&
	                       Property.isConstant(this._lineThickness) &&
	                       Property.isConstant(this._lineOffset);
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof GridMaterialProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets or sets the Property specifying the grid {@link Color}.
	         * @memberof GridMaterialProperty.prototype
	         * @type {Property}
	         * @default Color.WHITE
	         */
	        color : createPropertyDescriptor('color'),
	        /**
	         * Gets or sets the numeric Property specifying cell alpha values.
	         * @memberof GridMaterialProperty.prototype
	         * @type {Property}
	         * @default 0.1
	         */
	        cellAlpha : createPropertyDescriptor('cellAlpha'),
	        /**
	         * Gets or sets the {@link Cartesian2} Property specifying the number of grid lines along each axis.
	         * @memberof GridMaterialProperty.prototype
	         * @type {Property}
	         * @default new Cartesian2(8.0, 8.0)
	         */
	        lineCount : createPropertyDescriptor('lineCount'),
	        /**
	         * Gets or sets the {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
	         * @memberof GridMaterialProperty.prototype
	         * @type {Property}
	         * @default new Cartesian2(1.0, 1.0)
	         */
	        lineThickness : createPropertyDescriptor('lineThickness'),
	        /**
	         * Gets or sets the {@link Cartesian2} Property specifying the starting offset of grid lines along each axis.
	         * @memberof GridMaterialProperty.prototype
	         * @type {Property}
	         * @default new Cartesian2(0.0, 0.0)
	         */
	        lineOffset : createPropertyDescriptor('lineOffset')
	    });

	    /**
	     * Gets the {@link Material} type at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    GridMaterialProperty.prototype.getType = function(time) {
	        return 'Grid';
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    GridMaterialProperty.prototype.getValue = function(time, result) {
	        if (!defined(result)) {
	            result = {};
	        }
	        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
	        result.cellAlpha = Property.getValueOrDefault(this._cellAlpha, time, defaultCellAlpha);
	        result.lineCount = Property.getValueOrClonedDefault(this._lineCount, time, defaultLineCount, result.lineCount);
	        result.lineThickness = Property.getValueOrClonedDefault(this._lineThickness, time, defaultLineThickness, result.lineThickness);
	        result.lineOffset = Property.getValueOrClonedDefault(this._lineOffset, time, defaultLineOffset, result.lineOffset);
	        return result;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    GridMaterialProperty.prototype.equals = function(other) {
	        return this === other || //
	        (other instanceof GridMaterialProperty && //
	        Property.equals(this._color, other._color) && //
	        Property.equals(this._cellAlpha, other._cellAlpha) && //
	        Property.equals(this._lineCount, other._lineCount) && //
	        Property.equals(this._lineThickness, other._lineThickness) && //
	        Property.equals(this._lineOffset, other._lineOffset));
	    };

	    return GridMaterialProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(29),
	        __webpack_require__(35),
	        __webpack_require__(21),
	        __webpack_require__(55),
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        Matrix3,
	        Quaternion,
	        ReferenceFrame,
	        Transforms) {
	    "use strict";

	    /**
	     * The interface for all {@link Property} objects that define a
	     * orientation as a {@link Quaternion}.
	     * This type defines an interface and cannot be instantiated directly.
	     *
	     * @alias OrientationProperty
	     * @constructor
	     */
	    var OrientationProperty = function() {
	        DeveloperError.throwInstantiationError();
	    };

	    defineProperties(OrientationProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof OrientationProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : DeveloperError.throwInstantiationError
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof OrientationProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : DeveloperError.throwInstantiationError
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time relative to the position's reference frame.
	     * @function
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Quaternion} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Quaternion} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    OrientationProperty.prototype.getValue = DeveloperError.throwInstantiationError;

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    OrientationProperty.prototype.equals = DeveloperError.throwInstantiationError;

	    function framesEqual(frame1, frame2) {
	        return frame1 && frame1.id ?
	            frame1.id === (frame2 && frame2.id) :
	            frame1 === frame2;
	    }

	    function frameParents(frame) {
	        var frames = [];
	        while (defined(frame) && frame !== null) {
	            frames.unshift(frame);
	            frame = frame.position && frame.position.referenceFrame;
	        }
	        return frames;
	    }

	    function lowestCommonAncestor(parents1, parents2) {
	        if (!framesEqual(parents1[0],parents2[0])) return -1;

	        var h = Math.min(parents1.length, parents2.length);
	        for (var i = 0; i <= h; i++) {
	            if (!framesEqual(parents1[i],parents2[i])) return i-1;
	        }

	        return -1;
	    }

	    var scratchIcrfToFixedMatrix3 = new Matrix3();
	    var scratchIcrfToFixed = new Quaternion();

	    function getIcrfToFixed(time) {
	        var icrfToFixedRotation = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
	        if (!defined(icrfToFixedRotation)) {
	            icrfToFixedRotation = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
	        }
	        return Quaternion.fromRotationMatrix(icrfToFixedRotation, scratchIcrfToFixed);
	    }

	    var scratchMatrix3 = new Matrix3();
	    var scratchQuaternion = new Quaternion();

	    /**
	     * @private
	     */
	    OrientationProperty.convertToReferenceFrame = function(time, value, inputFrame, outputFrame, result) {
	      if (!defined(value)) {
	          return value;
	      }
	      if (!defined(result)) {
	          result = new Quaternion();
	      }

	      if (inputFrame === outputFrame) {
	          return Quaternion.clone(value, result);
	      }

	      if (inputFrame === null || outputFrame === null) {
	          return undefined;
	      }

	      var inputFrameParents = frameParents(inputFrame);
	      var outputFrameParents = frameParents(outputFrame);
	      var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
	      var lcaFrame = inputFrameParents[lcaIndex];

	      var inputOrientationAccumulator = function (accumulatedOrientationValue, frame) {
	          if (!defined(accumulatedOrientationValue)) return accumulatedOrientationValue;

	          var frameOrientationProperty = frame.orientation;
	          if (!defined(frameOrientationProperty)) return undefined;

	          var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	          if (!defined(frameOrientationValue)) return undefined;

	          return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
	      }

	      var outputOrientationAccumulator = function (accumulatedOrientationValue, frame) {
	          if (!defined(accumulatedOrientationValue)) return accumulatedOrientationValue;

	          var frameOrientationProperty = frame.orientation;
	          if (!defined(frameOrientationProperty)) return undefined;

	          var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
	          if (!defined(frameOrientationValue)) return undefined;

	          Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
	          return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
	      }

	      if (defined(lcaFrame)) {
	          inputFrameParents = inputFrameParents.slice(lcaIndex+1);
	          outputFrameParents = outputFrameParents.slice(lcaIndex+1);

	          var lcaFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
	          if (!defined(lcaFrameValue)) return undefined;

	          return outputFrameParents.reduce(outputOrientationAccumulator, lcaFrameValue);
	      }

	      var inputRootFrame = inputFrameParents.shift();
	      var outputRootFrame = outputFrameParents.shift();

	      if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
	          var inertialFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
	          if (!defined(inertialFrameValue)) return undefined;

	          var fixedFrameValue = Quaternion.multiply(getIcrfToFixed(time), inertialFrameValue, result);
	          return outputFrameParents.reduce(outputOrientationAccumulator, fixedFrameValue);
	      }

	      if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
	          var fixedFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result))
	          if (!defined(fixedFrameValue)) return undefined;

	          var fixedToIcrf = Quaternion.conjugate(getIcrfToFixed(time), scratchQuaternion);
	          var inertialFrameValue = Quaternion.multiply(fixedToIcrf, fixedFrameValue, result);
	          return outputFrameParents.reduce(outputOrientationAccumulator, inertialFrameValue);
	      }

	      return undefined;
	    }

	    return OrientationProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(6),
	        __webpack_require__(8),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Color,
	        defaultValue,
	        defined,
	        defineProperties,
	        Event,
	        createPropertyDescriptor,
	        Property) {
	    "use strict";

	    var defaultColor = Color.WHITE;
	    var defaultGlowPower = 0.25;

	    /**
	     * A {@link MaterialProperty} that maps to polyline glow {@link Material} uniforms.
	     * @alias PolylineGlowMaterialProperty
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
	     * @param {Property} [options.glowPower=0.25] A numeric Property specifying the strength of the glow, as a percentage of the total line width.
	     */
	    var PolylineGlowMaterialProperty = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        this._definitionChanged = new Event();
	        this._color = undefined;
	        this._colorSubscription = undefined;
	        this._glowPower = undefined;
	        this._glowPowerSubscription = undefined;

	        this.color = options.color;
	        this.glowPower = options.glowPower;
	    };

	    defineProperties(PolylineGlowMaterialProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof PolylineGlowMaterialProperty.prototype
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return Property.isConstant(this._color) && Property.isConstant(this._glow);
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof PolylineGlowMaterialProperty.prototype
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets or sets the Property specifying the {@link Color} of the line.
	         * @memberof PolylineGlowMaterialProperty.prototype
	         * @type {Property}
	         */
	        color : createPropertyDescriptor('color'),
	        /**
	         * Gets or sets the numeric Property specifying the strength of the glow, as a percentage of the total line width (less than 1.0).
	         * @memberof PolylineGlowMaterialProperty.prototype
	         * @type {Property}
	         */
	        glowPower : createPropertyDescriptor('glowPower')
	    });

	    /**
	     * Gets the {@link Material} type at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    PolylineGlowMaterialProperty.prototype.getType = function(time) {
	        return 'PolylineGlow';
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    PolylineGlowMaterialProperty.prototype.getValue = function(time, result) {
	        if (!defined(result)) {
	            result = {};
	        }
	        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
	        result.glowPower = Property.getValueOrDefault(this._glowPower, time, defaultGlowPower, result.glowPower);
	        return result;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    PolylineGlowMaterialProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof PolylineGlowMaterialProperty && //
	                Property.equals(this._color, other._color) &&
	                Property.equals(this._glowPower, other._glowPower));
	    };

	    return PolylineGlowMaterialProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(6),
	        __webpack_require__(8),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Color,
	        defaultValue,
	        defined,
	        defineProperties,
	        Event,
	        createPropertyDescriptor,
	        Property) {
	    "use strict";

	    var defaultColor = Color.WHITE;
	    var defaultOutlineColor = Color.BLACK;
	    var defaultOutlineWidth = 1.0;

	    /**
	     * A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.
	     * @alias PolylineOutlineMaterialProperty
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline, in pixels.
	     */
	    var PolylineOutlineMaterialProperty = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        this._definitionChanged = new Event();
	        this._color = undefined;
	        this._colorSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;

	        this.color = options.color;
	        this.outlineColor = options.outlineColor;
	        this.outlineWidth = options.outlineWidth;
	    };

	    defineProperties(PolylineOutlineMaterialProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof PolylineOutlineMaterialProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return Property.isConstant(this._color) && Property.isConstant(this._outlineColor) && Property.isConstant(this._outlineWidth);
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof PolylineOutlineMaterialProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets or sets the Property specifying the {@link Color} of the line.
	         * @memberof PolylineOutlineMaterialProperty.prototype
	         * @type {Property}
	         * @default Color.WHITE
	         */
	        color : createPropertyDescriptor('color'),
	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof PolylineOutlineMaterialProperty.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),
	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof PolylineOutlineMaterialProperty.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth')
	    });

	    /**
	     * Gets the {@link Material} type at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    PolylineOutlineMaterialProperty.prototype.getType = function(time) {
	        return 'PolylineOutline';
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    PolylineOutlineMaterialProperty.prototype.getValue = function(time, result) {
	        if (!defined(result)) {
	            result = {};
	        }
	        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
	        result.outlineColor = Property.getValueOrClonedDefault(this._outlineColor, time, defaultOutlineColor, result.outlineColor);
	        result.outlineWidth = Property.getValueOrDefault(this._outlineWidth, time, defaultOutlineWidth);
	        return result;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    PolylineOutlineMaterialProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof PolylineOutlineMaterialProperty && //
	                Property.equals(this._color, other._color) && //
	                Property.equals(this._outlineColor, other._outlineColor) && //
	                Property.equals(this._outlineWidth, other._outlineWidth));
	    };

	    return PolylineOutlineMaterialProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(19),
	        __webpack_require__(8)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        createMaterialPropertyDescriptor,
	        createPropertyDescriptor) {
	    "use strict";

	    /**
	     * Describes a polyline volume defined as a line strip and corresponding two dimensional shape which is extruded along it.
	     * The resulting volume conforms to the curvature of the globe.
	     *
	     * @alias PolylineVolumeGraphics
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions which define the line strip.
	     * @param {Property} [options.shape] A Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
	     * @param {Property} [options.cornerType=CornerType.ROUNDED] A {@link CornerType} Property specifying the style of the corners.
	     * @param {Property} [options.show=true] A boolean Property specifying the visibility of the volume.
	     * @param {Property} [options.fill=true] A boolean Property specifying whether the volume is filled with the provided material.
	     * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the volume.
	     * @param {Property} [options.outline=false] A boolean Property specifying whether the volume is outlined.
	     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	     * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude point.
	     *
	     * @see Entity
	     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}
	     */
	    var PolylineVolumeGraphics = function(options) {
	        this._show = undefined;
	        this._showSubscription = undefined;
	        this._material = undefined;
	        this._materialSubscription = undefined;
	        this._positions = undefined;
	        this._positionsSubscription = undefined;
	        this._shape = undefined;
	        this._shapeSubscription = undefined;
	        this._granularity = undefined;
	        this._granularitySubscription = undefined;
	        this._cornerType = undefined;
	        this._cornerTypeSubscription = undefined;
	        this._fill = undefined;
	        this._fillSubscription = undefined;
	        this._outline = undefined;
	        this._outlineSubscription = undefined;
	        this._outlineColor = undefined;
	        this._outlineColorSubscription = undefined;
	        this._outlineWidth = undefined;
	        this._outlineWidthSubscription = undefined;
	        this._definitionChanged = new Event();

	        this.merge(defaultValue(options, defaultValue.EMPTY_OBJECT));
	    };

	    defineProperties(PolylineVolumeGraphics.prototype, {
	        /**
	         * Gets the event that is raised whenever a property or sub-property is changed or modified.
	         * @memberof PolylineVolumeGraphics.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },

	        /**
	         * Gets or sets the boolean Property specifying the visibility of the volume.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        show : createPropertyDescriptor('show'),

	        /**
	         * Gets or sets the Property specifying the material used to fill the volume.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {MaterialProperty}
	         * @default Color.WHITE
	         */
	        material : createMaterialPropertyDescriptor('material'),

	        /**
	         * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the line strip.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         */
	        positions : createPropertyDescriptor('positions'),

	        /**
	         * Gets or sets the Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         */
	        shape : createPropertyDescriptor('shape'),

	        /**
	         * Gets or sets the numeric Property specifying the angular distance between points on the volume.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         * @default {CesiumMath.RADIANS_PER_DEGREE}
	         */
	        granularity : createPropertyDescriptor('granularity'),

	        /**
	         * Gets or sets the boolean Property specifying whether the volume is filled with the provided material.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         * @default true
	         */
	        fill : createPropertyDescriptor('fill'),

	        /**
	         * Gets or sets the Property specifying whether the volume is outlined.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         * @default false
	         */
	        outline : createPropertyDescriptor('outline'),

	        /**
	         * Gets or sets the Property specifying the {@link Color} of the outline.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        outlineColor : createPropertyDescriptor('outlineColor'),

	        /**
	         * Gets or sets the numeric Property specifying the width of the outline.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        outlineWidth : createPropertyDescriptor('outlineWidth'),

	        /**
	         * Gets or sets the {@link CornerType} Property specifying the style of the corners.
	         * @memberof PolylineVolumeGraphics.prototype
	         * @type {Property}
	         * @default CornerType.ROUNDED
	         */
	        cornerType : createPropertyDescriptor('cornerType')
	    });

	    /**
	     * Duplicates this instance.
	     *
	     * @param {PolylineVolumeGraphics} [result] The object onto which to store the result.
	     * @returns {PolylineVolumeGraphics} The modified result parameter or a new instance if one was not provided.
	     */
	    PolylineVolumeGraphics.prototype.clone = function(result) {
	        if (!defined(result)) {
	            return new PolylineVolumeGraphics(this);
	        }
	        result.show = this.show;
	        result.material = this.material;
	        result.positions = this.positions;
	        result.shape = this.shape;
	        result.granularity = this.granularity;
	        result.fill = this.fill;
	        result.outline = this.outline;
	        result.outlineColor = this.outlineColor;
	        result.outlineWidth = this.outlineWidth;
	        result.cornerType = this.cornerType;
	        return result;
	    };

	    /**
	     * Assigns each unassigned property on this object to the value
	     * of the same property on the provided source object.
	     *
	     * @param {PolylineVolumeGraphics} source The object to be merged into this object.
	     */
	    PolylineVolumeGraphics.prototype.merge = function(source) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(source)) {
	            throw new DeveloperError('source is required.');
	        }
	        //>>includeEnd('debug');

	        this.show = defaultValue(this.show, source.show);
	        this.material = defaultValue(this.material, source.material);
	        this.positions = defaultValue(this.positions, source.positions);
	        this.shape = defaultValue(this.shape, source.shape);
	        this.granularity = defaultValue(this.granularity, source.granularity);
	        this.fill = defaultValue(this.fill, source.fill);
	        this.outline = defaultValue(this.outline, source.outline);
	        this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
	        this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
	        this.cornerType = defaultValue(this.cornerType, source.cornerType);
	    };

	    return PolylineVolumeGraphics;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(118),
	        __webpack_require__(21),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        EventHelper,
	        ReferenceFrame,
	        Property) {
	    "use strict";

	    /**
	     * A {@link PositionProperty} whose value is an array whose items are the computed value
	     * of other PositionProperty instances.
	     *
	     * @alias PositionPropertyArray
	     * @constructor
	     *
	     * @param {Property[]} [value] An array of Property instances.
	     */
	    var PositionPropertyArray = function(value, referenceFrame) {
	        this._value = undefined;
	        this._definitionChanged = new Event();
	        this._eventHelper = new EventHelper();
	        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
	        this.setValue(value);
	    };

	    defineProperties(PositionPropertyArray.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  This property
	         * is considered constant if all property items in the array are constant.
	         * @memberof PositionPropertyArray.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                var value = this._value;
	                if (!defined(value)) {
	                    return true;
	                }

	                var length = value.length;
	                for (var i = 0; i < length; i++) {
	                    if (!Property.isConstant(value[i])) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever setValue is called with data different
	         * than the current value or one of the properties in the array also changes.
	         * @memberof PositionPropertyArray.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the reference frame in which the position is defined.
	         * @memberof PositionPropertyArray.prototype
	         * @type {ReferenceFrame}
	         * @default ReferenceFrame.FIXED;
	         */
	        referenceFrame : {
	            get : function() {
	                return this._referenceFrame;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property.
	     *
	     * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
	     * @param {Cartesian3[]} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3[]} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    PositionPropertyArray.prototype.getValue = function(time, result) {
	        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
	    };

	    /**
	     * Gets the value of the property at the provided time and in the provided reference frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    PositionPropertyArray.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        if (!defined(referenceFrame)) {
	            throw new DeveloperError('referenceFrame is required.');
	        }
	        //>>includeEnd('debug');

	        var value = this._value;
	        if (!defined(value)) {
	            return undefined;
	        }

	        var length = value.length;
	        if (!defined(result)) {
	            result = new Array(length);
	        }
	        var i = 0;
	        var x = 0;
	        while (i < length) {
	            var property = value[i];
	            var itemValue = property.getValueInReferenceFrame(time, referenceFrame, result[i]);
	            if (defined(itemValue)) {
	                result[x] = itemValue;
	                x++;
	            }
	            i++;
	        }
	        result.length = x;
	        return result;
	    };

	    /**
	     * Sets the value of the property.
	     *
	     * @param {Property[]} value An array of Property instances.
	     */
	    PositionPropertyArray.prototype.setValue = function(value) {
	        var eventHelper = this._eventHelper;
	        eventHelper.removeAll();

	        if (defined(value)) {
	            this._value = value.slice();
	            var length = value.length;
	            for (var i = 0; i < length; i++) {
	                var property = value[i];
	                if (defined(property)) {
	                    eventHelper.add(property.definitionChanged, PositionPropertyArray.prototype._raiseDefinitionChanged, this);
	                }
	            }
	        } else {
	            this._value = undefined;
	        }
	        this._definitionChanged.raiseEvent(this);
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    PositionPropertyArray.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof PositionPropertyArray && //
	                this._referenceFrame === other._referenceFrame && //
	                Property.arrayEquals(this._value, other._value));
	    };

	    PositionPropertyArray.prototype._raiseDefinitionChanged = function() {
	        this._definitionChanged.raiseEvent(this);
	    };

	    return PositionPropertyArray;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(28),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(6),
	        __webpack_require__(8),
	        __webpack_require__(10),
	        __webpack_require__(139)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Color,
	        defaultValue,
	        defined,
	        defineProperties,
	        Event,
	        createPropertyDescriptor,
	        Property,
	        StripeOrientation) {
	    "use strict";

	    var defaultOrientation = StripeOrientation.HORIZONTAL;
	    var defaultEvenColor = Color.WHITE;
	    var defaultOddColor = Color.BLACK;
	    var defaultOffset = 0;
	    var defaultRepeat = 1;

	    /**
	     * A {@link MaterialProperty} that maps to stripe {@link Material} uniforms.
	     * @alias StripeMaterialProperty
	     * @constructor
	     *
	     * @param {Object} [options] Object with the following properties:
	     * @param {Property} [options.evenColor=Color.WHITE] A Property specifying the first {@link Color}.
	     * @param {Property} [options.oddColor=Color.BLACK] A Property specifying the second {@link Color}.
	     * @param {Property} [options.repeat=1] A numeric Property specifying how many times the stripes repeat.
	     * @param {Property} [options.offset=0] A numeric Property specifying how far into the pattern to start the material.
	     * @param {Property} [options.orientation=StripeOrientation.HORIZONTAL] A Property specifying the {@link StripeOrientation}.
	     */
	    var StripeMaterialProperty = function(options) {
	        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

	        this._definitionChanged = new Event();

	        this._orientation = undefined;
	        this._orientationSubscription = undefined;

	        this._evenColor = undefined;
	        this._evenColorSubscription = undefined;

	        this._oddColor = undefined;
	        this._oddColorSubscription = undefined;

	        this._offset = undefined;
	        this._offsetSubscription = undefined;

	        this._repeat = undefined;
	        this._repeatSubscription = undefined;

	        this.orientation = options.orientation;
	        this.evenColor = options.evenColor;
	        this.oddColor = options.oddColor;
	        this.offset = options.offset;
	        this.repeat = options.repeat;
	    };

	    defineProperties(StripeMaterialProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof StripeMaterialProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return Property.isConstant(this._orientation) && //
	                       Property.isConstant(this._evenColor) && //
	                       Property.isConstant(this._oddColor) && //
	                       Property.isConstant(this._offset) && //
	                       Property.isConstant(this._repeat);
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof StripeMaterialProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets or sets the Property specifying the {@link StripeOrientation}/
	         * @memberof StripeMaterialProperty.prototype
	         * @type {Property}
	         * @default StripeOrientation.HORIZONTAL
	         */
	        orientation : createPropertyDescriptor('orientation'),
	        /**
	         * Gets or sets the Property specifying the first {@link Color}.
	         * @memberof StripeMaterialProperty.prototype
	         * @type {Property}
	         * @default Color.WHITE
	         */
	        evenColor : createPropertyDescriptor('evenColor'),
	        /**
	         * Gets or sets the Property specifying the second {@link Color}.
	         * @memberof StripeMaterialProperty.prototype
	         * @type {Property}
	         * @default Color.BLACK
	         */
	        oddColor : createPropertyDescriptor('oddColor'),
	        /**
	         * Gets or sets the numeric Property specifying the point into the pattern
	         * to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning
	         * of the odd color, 2.0 being the even color again, and any multiple or fractional values
	         * being in between.
	         * @memberof StripeMaterialProperty.prototype
	         * @type {Property}
	         * @default 0.0
	         */
	        offset : createPropertyDescriptor('offset'),
	        /**
	         * Gets or sets the numeric Property specifying how many times the stripes repeat.
	         * @memberof StripeMaterialProperty.prototype
	         * @type {Property}
	         * @default 1.0
	         */
	        repeat : createPropertyDescriptor('repeat')
	    });

	    /**
	     * Gets the {@link Material} type at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the type.
	     * @returns {String} The type of material.
	     */
	    StripeMaterialProperty.prototype.getType = function(time) {
	        return 'Stripe';
	    };

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    StripeMaterialProperty.prototype.getValue = function(time, result) {
	        if (!defined(result)) {
	            result = {};
	        }
	        result.horizontal = Property.getValueOrDefault(this._orientation, time, defaultOrientation) === StripeOrientation.HORIZONTAL;
	        result.evenColor = Property.getValueOrClonedDefault(this._evenColor, time, defaultEvenColor, result.evenColor);
	        result.oddColor = Property.getValueOrClonedDefault(this._oddColor, time, defaultOddColor, result.oddColor);
	        result.offset = Property.getValueOrDefault(this._offset, time, defaultOffset);
	        result.repeat = Property.getValueOrDefault(this._repeat, time, defaultRepeat);
	        return result;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    StripeMaterialProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof StripeMaterialProperty && //
	                       Property.equals(this._orientation, other._orientation) && //
	                       Property.equals(this._evenColor, other._evenColor) && //
	                       Property.equals(this._oddColor, other._oddColor) && //
	                       Property.equals(this._offset, other._offset) && //
	                       Property.equals(this._repeat, other._repeat));
	    };

	    return StripeMaterialProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(21),
	        __webpack_require__(54),
	        __webpack_require__(57),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        ReferenceFrame,
	        TimeIntervalCollection,
	        PositionProperty,
	        Property) {
	    "use strict";

	    /**
	     * A {@link TimeIntervalCollectionProperty} which is also a {@link PositionProperty}.
	     *
	     * @alias TimeIntervalCollectionPositionProperty
	     * @constructor
	     *
	     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	     */
	    var TimeIntervalCollectionPositionProperty = function(referenceFrame) {
	        this._definitionChanged = new Event();
	        this._intervals = new TimeIntervalCollection();
	        this._intervals.changedEvent.addEventListener(TimeIntervalCollectionPositionProperty.prototype._intervalsChanged, this);
	        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
	    };

	    defineProperties(TimeIntervalCollectionPositionProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof TimeIntervalCollectionPositionProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._intervals.isEmpty;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is considered to have changed if a call to getValue would return
	         * a different result for the same time.
	         * @memberof TimeIntervalCollectionPositionProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the interval collection.
	         * @memberof TimeIntervalCollectionPositionProperty.prototype
	         * @type {TimeIntervalCollection}
	         */
	        intervals : {
	            get : function() {
	                return this._intervals;
	            }
	        },
	        /**
	         * Gets the reference frame in which the position is defined.
	         * @memberof TimeIntervalCollectionPositionProperty.prototype
	         * @type {ReferenceFrame}
	         * @default ReferenceFrame.FIXED;
	         */
	        referenceFrame : {
	            get : function() {
	                return this._referenceFrame;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time in the fixed frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    TimeIntervalCollectionPositionProperty.prototype.getValue = function(time, result) {
	        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
	    };

	    /**
	     * Gets the value of the property at the provided time and in the provided reference frame.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
	     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    TimeIntervalCollectionPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required.');
	        }
	        if (!defined(referenceFrame)) {
	            throw new DeveloperError('referenceFrame is required.');
	        }
	        //>>includeEnd('debug');

	        var position = this._intervals.findDataForIntervalContainingDate(time);
	        if (defined(position)) {
	            return PositionProperty.convertToReferenceFrame(time, position, this._referenceFrame, referenceFrame, result);
	        }
	        return undefined;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    TimeIntervalCollectionPositionProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof TimeIntervalCollectionPositionProperty && //
	                this._intervals.equals(other._intervals, Property.equals) && //
	                this._referenceFrame === other._referenceFrame);
	    };

	    /**
	     * @private
	     */
	    TimeIntervalCollectionPositionProperty.prototype._intervalsChanged = function() {
	        this._definitionChanged.raiseEvent(this);
	    };

	    return TimeIntervalCollectionPositionProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(6),
	        __webpack_require__(54),
	        __webpack_require__(10)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        Event,
	        TimeIntervalCollection,
	        Property) {
	    "use strict";

	    /**
	     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
	     * data property of each {@link TimeInterval} represents the value at time.
	     *
	     * @alias TimeIntervalCollectionProperty
	     * @constructor
	     *
	     * @example
	     * //Create a Cartesian2 interval property which contains data on August 1st, 2012
	     * //and uses a different value every 6 hours.
	     * var composite = new Cesium.TimeIntervalCollectionProperty();
	     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',
	     *     isStartIncluded : true,
	     *     isStopIncluded : false,
	     *     data : new Cesium.Cartesian2(2.0, 3.4)
	     * }));
	     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',
	     *     isStartIncluded : true,
	     *     isStopIncluded : false,
	     *     data : new Cesium.Cartesian2(12.0, 2.7)
	     * }));
	     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',
	     *     isStartIncluded : true,
	     *     isStopIncluded : false,
	     *     data : new Cesium.Cartesian2(5.0, 12.4)
	     * }));
	     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	     *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',
	     *     isStartIncluded : true,
	     *     isStopIncluded : true,
	     *     data : new Cesium.Cartesian2(85.0, 4.1)
	     * }));
	     */
	    var TimeIntervalCollectionProperty = function() {
	        this._definitionChanged = new Event();
	        this._intervals = new TimeIntervalCollection();
	        this._intervals.changedEvent.addEventListener(TimeIntervalCollectionProperty.prototype._intervalsChanged, this);
	    };

	    defineProperties(TimeIntervalCollectionProperty.prototype, {
	        /**
	         * Gets a value indicating if this property is constant.  A property is considered
	         * constant if getValue always returns the same result for the current definition.
	         * @memberof TimeIntervalCollectionProperty.prototype
	         *
	         * @type {Boolean}
	         * @readonly
	         */
	        isConstant : {
	            get : function() {
	                return this._intervals.isEmpty;
	            }
	        },
	        /**
	         * Gets the event that is raised whenever the definition of this property changes.
	         * The definition is changed whenever setValue is called with data different
	         * than the current value.
	         * @memberof TimeIntervalCollectionProperty.prototype
	         *
	         * @type {Event}
	         * @readonly
	         */
	        definitionChanged : {
	            get : function() {
	                return this._definitionChanged;
	            }
	        },
	        /**
	         * Gets the interval collection.
	         * @memberof TimeIntervalCollectionProperty.prototype
	         *
	         * @type {TimeIntervalCollection}
	         */
	        intervals : {
	            get : function() {
	                return this._intervals;
	            }
	        }
	    });

	    /**
	     * Gets the value of the property at the provided time.
	     *
	     * @param {JulianDate} time The time for which to retrieve the value.
	     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
	     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
	     */
	    TimeIntervalCollectionProperty.prototype.getValue = function(time, result) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(time)) {
	            throw new DeveloperError('time is required');
	        }
	        //>>includeEnd('debug');

	        var value = this._intervals.findDataForIntervalContainingDate(time);
	        if (defined(value) && (typeof value.clone === 'function')) {
	            return value.clone(result);
	        }
	        return value;
	    };

	    /**
	     * Compares this property to the provided property and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {Property} [other] The other property.
	     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
	     */
	    TimeIntervalCollectionProperty.prototype.equals = function(other) {
	        return this === other || //
	               (other instanceof TimeIntervalCollectionProperty && //
	               this._intervals.equals(other._intervals, Property.equals));
	    };

	    /**
	     * @private
	     */
	    TimeIntervalCollectionProperty.prototype._intervalsChanged = function() {
	        this._definitionChanged.raiseEvent(this);
	    };

	    return TimeIntervalCollectionProperty;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(2),
	        __webpack_require__(167)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defaultValue,
	        defined,
	        DeveloperError,
	        Intersect) {
	    "use strict";

	    /**
	     * The culling volume defined by planes.
	     *
	     * @alias CullingVolume
	     * @constructor
	     *
	     * @param {Cartesian4[]} planes An array of clipping planes.
	     */
	    var CullingVolume = function(planes) {
	        /**
	         * Each plane is represented by a Cartesian4 object, where the x, y, and z components
	         * define the unit vector normal to the plane, and the w component is the distance of the
	         * plane from the origin.
	         * @type {Cartesian4[]}
	         * @default []
	         */
	        this.planes = defaultValue(planes, []);
	    };

	    /**
	     * Determines whether a bounding volume intersects the culling volume.
	     *
	     * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.
	     * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.
	     */
	    CullingVolume.prototype.computeVisibility = function(boundingVolume) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(boundingVolume)) {
	            throw new DeveloperError('boundingVolume is required.');
	        }
	        //>>includeEnd('debug');

	        var planes = this.planes;
	        var intersecting = false;
	        for (var k = 0, len = planes.length; k < len; ++k) {
	            var result = boundingVolume.intersect(planes[k]);
	            if (result === Intersect.OUTSIDE) {
	                return Intersect.OUTSIDE;
	            } else if (result === Intersect.INTERSECTING) {
	                intersecting = true;
	            }
	        }

	        return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
	    };

	    return CullingVolume;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * The horizontal location of an origin relative to an object, e.g., a {@link Billboard}.
	     * For example, the horizontal origin is used to display a billboard to the left or right (in
	     * screen space) of the actual position.
	     *
	     * @namespace
	     * @alias HorizontalOrigin
	     *
	     * @see Billboard#horizontalOrigin
	     */
	    var HorizontalOrigin = {
	        /**
	         * The origin is at the horizontal center of the object.
	         *
	         * @type {Number}
	         * @constant
	         */
	        CENTER : 0,

	        /**
	         * The origin is on the left side of the object.
	         *
	         * @type {Number}
	         * @constant
	         */
	        LEFT : 1,

	        /**
	         * The origin is on the right side of the object.
	         *
	         * @type {Number}
	         * @constant
	         */
	        RIGHT : -1
	    };

	    return freezeObject(HorizontalOrigin);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * Describes how to draw a label.
	     *
	     * @namespace
	     * @alias LabelStyle
	     *
	     * @see Label#style
	     */
	    var LabelStyle = {
	        /**
	         * Fill the text of the label, but do not outline.
	         *
	         * @type {Number}
	         * @constant
	         */
	        FILL : 0,

	        /**
	         * Outline the text of the label, but do not fill.
	         *
	         * @type {Number}
	         * @constant
	         */
	        OUTLINE : 1,

	        /**
	         * Fill and outline the text of the label.
	         *
	         * @type {Number}
	         * @constant
	         */
	        FILL_AND_OUTLINE : 2
	    };

	    return freezeObject(LabelStyle);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(204)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        defined,
	        defineProperties,
	        DeveloperError,
	        PerspectiveOffCenterFrustum) {
	    "use strict";

	    /**
	     * The viewing frustum is defined by 6 planes.
	     * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
	     * define the unit vector normal to the plane, and the w component is the distance of the
	     * plane from the origin/camera position.
	     *
	     * @alias PerspectiveFrustum
	     * @constructor
	     *
	     * @see PerspectiveOffCenterFrustum
	     *
	     * @example
	     * var frustum = new Cesium.PerspectiveFrustum();
	     * frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
	     * frustum.fov = Cesium.Math.PI_OVER_THREE;
	     * frustum.near = 1.0;
	     * frustum.far = 2.0;
	     */
	    var PerspectiveFrustum = function() {
	        this._offCenterFrustum = new PerspectiveOffCenterFrustum();

	        /**
	         * The angle of the field of view (FOV), in radians.  This angle will be used
	         * as the horizontal FOV if the width is greater than the height, otherwise
	         * it will be the vertical FOV.
	         * @type {Number}
	         * @default undefined
	         */
	        this.fov = undefined;
	        this._fov = undefined;
	        this._fovy = undefined;

	        /**
	         * The aspect ratio of the frustum's width to it's height.
	         * @type {Number}
	         * @default undefined
	         */
	        this.aspectRatio = undefined;
	        this._aspectRatio = undefined;

	        /**
	         * The distance of the near plane.
	         * @type {Number}
	         * @default 1.0
	         */
	        this.near = 1.0;
	        this._near = this.near;

	        /**
	         * The distance of the far plane.
	         * @type {Number}
	         * @default 500000000.0
	         */
	        this.far = 500000000.0;
	        this._far = this.far;
	    };

	    function update(frustum) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {
	            throw new DeveloperError('fov, aspectRatio, near, or far parameters are not set.');
	        }
	        //>>includeEnd('debug');

	        var f = frustum._offCenterFrustum;

	        if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio ||
	                frustum.near !== frustum._near || frustum.far !== frustum._far) {
	            //>>includeStart('debug', pragmas.debug);
	            if (frustum.fov < 0 || frustum.fov >= Math.PI) {
	                throw new DeveloperError('fov must be in the range [0, PI).');
	            }

	            if (frustum.aspectRatio < 0) {
	                throw new DeveloperError('aspectRatio must be positive.');
	            }

	            if (frustum.near < 0 || frustum.near > frustum.far) {
	                throw new DeveloperError('near must be greater than zero and less than far.');
	            }
	            //>>includeEnd('debug');

	            frustum._aspectRatio = frustum.aspectRatio;
	            frustum._fov = frustum.fov;
	            frustum._fovy = (frustum.aspectRatio <= 1) ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;
	            frustum._near = frustum.near;
	            frustum._far = frustum.far;

	            f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
	            f.bottom = -f.top;
	            f.right = frustum.aspectRatio * f.top;
	            f.left = -f.right;
	            f.near = frustum.near;
	            f.far = frustum.far;
	        }
	    }

	    defineProperties(PerspectiveFrustum.prototype, {
	        /**
	         * Gets the perspective projection matrix computed from the view frustum.
	         * @memberof PerspectiveFrustum.prototype
	         * @type {Matrix4}
	         *
	         * @see PerspectiveFrustum#infiniteProjectionMatrix
	         */
	        projectionMatrix : {
	            get : function() {
	                update(this);
	                return this._offCenterFrustum.projectionMatrix;
	            }
	        },

	        /**
	         * The perspective projection matrix computed from the view frustum with an infinite far plane.
	         * @memberof PerspectiveFrustum.prototype
	         * @type {Matrix4}
	         *
	         * @see PerspectiveFrustum#projectionMatrix
	         */
	        infiniteProjectionMatrix : {
	            get : function() {
	                update(this);
	                return this._offCenterFrustum.infiniteProjectionMatrix;
	            }
	        },

	        /**
	         * Gets the angle of the vertical field of view, in radians.
	         * @memberof PerspectiveFrustum.prototype
	         * @type {Number}
	         * @default undefined
	         */
	        fovy : {
	            get : function() {
	                update(this);
	                return this._fovy;
	            }
	        }
	    });

	    /**
	     * Creates a culling volume for this frustum.
	     *
	     * @param {Cartesian3} position The eye position.
	     * @param {Cartesian3} direction The view direction.
	     * @param {Cartesian3} up The up direction.
	     * @returns {CullingVolume} A culling volume at the given position and orientation.
	     *
	     * @example
	     * // Check if a bounding volume intersects the frustum.
	     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
	     * var intersect = cullingVolume.computeVisibility(boundingVolume);
	     */
	    PerspectiveFrustum.prototype.computeCullingVolume = function(position, direction, up) {
	        update(this);
	        return this._offCenterFrustum.computeCullingVolume(position, direction, up);
	    };

	    /**
	     * Returns the pixel's width and height in meters.
	     *
	     * @param {Cartesian2} drawingBufferDimensions A {@link Cartesian2} with width and height in the x and y properties, respectively.
	     * @param {Number} [distance=near plane distance] The distance to the near plane in meters.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
	     *
	     * @exception {DeveloperError} drawingBufferDimensions.x must be greater than zero.
	     * @exception {DeveloperError} drawingBufferDimensions.y must be greater than zero.
	     *
	     * @example
	     * // Example 1
	     * // Get the width and height of a pixel.
	     * var pixelSize = camera.frustum.getPixelSize({
	     *     width : canvas.clientWidth,
	     *     height : canvas.clientHeight
	     * });
	     *
	     * @example
	     * // Example 2
	     * // Get the width and height of a pixel if the near plane was set to 'distance'.
	     * // For example, get the size of a pixel of an image on a billboard.
	     * var position = camera.position;
	     * var direction = camera.direction;
	     * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
	     * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter)); // project vector onto camera direction vector
	     * var distance = Cesium.Cartesian3.magnitude(toCenterProj);
	     * var pixelSize = camera.frustum.getPixelSize({
	     *     width : canvas.clientWidth,
	     *     height : canvas.clientHeight
	     * }, distance);
	     */
	    PerspectiveFrustum.prototype.getPixelSize = function(drawingBufferDimensions, distance, result) {
	        update(this);
	        return this._offCenterFrustum.getPixelSize(drawingBufferDimensions, distance, result);
	    };

	    /**
	     * Returns a duplicate of a PerspectiveFrustum instance.
	     *
	     * @param {PerspectiveFrustum} [result] The object onto which to store the result.
	     * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
	     */
	    PerspectiveFrustum.prototype.clone = function(result) {
	        if (!defined(result)) {
	            result = new PerspectiveFrustum();
	        }

	        result.aspectRatio = this.aspectRatio;
	        result.fov = this.fov;
	        result.near = this.near;
	        result.far = this.far;

	        // force update of clone to compute matrices
	        result._aspectRatio = undefined;
	        result._fov = undefined;
	        result._near = undefined;
	        result._far = undefined;

	        this._offCenterFrustum.clone(result._offCenterFrustum);

	        return result;
	    };

	    /**
	     * Compares the provided PerspectiveFrustum componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    PerspectiveFrustum.prototype.equals = function(other) {
	        if (!defined(other)) {
	            return false;
	        }

	        update(this);
	        update(other);

	        return (this.fov === other.fov &&
	                this.aspectRatio === other.aspectRatio &&
	                this.near === other.near &&
	                this.far === other.far &&
	                this._offCenterFrustum.equals(other._offCenterFrustum));
	    };

	    return PerspectiveFrustum;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(34),
	        __webpack_require__(12),
	        __webpack_require__(51),
	        __webpack_require__(3),
	        __webpack_require__(1),
	        __webpack_require__(4),
	        __webpack_require__(2),
	        __webpack_require__(44),
	        __webpack_require__(200)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        Cartesian2,
	        Cartesian3,
	        Cartesian4,
	        defaultValue,
	        defined,
	        defineProperties,
	        DeveloperError,
	        Matrix4,
	        CullingVolume) {
	    "use strict";

	    /**
	     * The viewing frustum is defined by 6 planes.
	     * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
	     * define the unit vector normal to the plane, and the w component is the distance of the
	     * plane from the origin/camera position.
	     *
	     * @alias PerspectiveOffCenterFrustum
	     * @constructor
	     *
	     * @see PerspectiveFrustum
	     *
	     * @example
	     * var frustum = new Cesium.PerspectiveOffCenterFrustum();
	     * frustum.right = 1.0;
	     * frustum.left = -1.0;
	     * frustum.top = 1.0;
	     * frustum.bottom = -1.0;
	     * frustum.near = 1.0;
	     * frustum.far = 2.0;
	     */
	    var PerspectiveOffCenterFrustum = function() {
	        /**
	         * Defines the left clipping plane.
	         * @type {Number}
	         * @default undefined
	         */
	        this.left = undefined;
	        this._left = undefined;

	        /**
	         * Defines the right clipping plane.
	         * @type {Number}
	         * @default undefined
	         */
	        this.right = undefined;
	        this._right = undefined;

	        /**
	         * Defines the top clipping plane.
	         * @type {Number}
	         * @default undefined
	         */
	        this.top = undefined;
	        this._top = undefined;

	        /**
	         * Defines the bottom clipping plane.
	         * @type {Number}
	         * @default undefined
	         */
	        this.bottom = undefined;
	        this._bottom = undefined;

	        /**
	         * The distance of the near plane.
	         * @type {Number}
	         * @default 1.0
	         */
	        this.near = 1.0;
	        this._near = this.near;

	        /**
	         * The distance of the far plane.
	         * @type {Number}
	         * @default 500000000.0
	         */
	        this.far = 500000000.0;
	        this._far = this.far;

	        this._cullingVolume = new CullingVolume();
	        this._perspectiveMatrix = new Matrix4();
	        this._infinitePerspective = new Matrix4();
	    };

	    function update(frustum) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(frustum.right) || !defined(frustum.left) ||
	            !defined(frustum.top) || !defined(frustum.bottom) ||
	            !defined(frustum.near) || !defined(frustum.far)) {
	            throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
	        }
	        //>>includeEnd('debug');

	        var t = frustum.top;
	        var b = frustum.bottom;
	        var r = frustum.right;
	        var l = frustum.left;
	        var n = frustum.near;
	        var f = frustum.far;

	        if (t !== frustum._top || b !== frustum._bottom ||
	            l !== frustum._left || r !== frustum._right ||
	            n !== frustum._near || f !== frustum._far) {

	            //>>includeStart('debug', pragmas.debug);
	            if (frustum.near <= 0 || frustum.near > frustum.far) {
	                throw new DeveloperError('near must be greater than zero and less than far.');
	            }
	            //>>includeEnd('debug');

	            frustum._left = l;
	            frustum._right = r;
	            frustum._top = t;
	            frustum._bottom = b;
	            frustum._near = n;
	            frustum._far = f;
	            frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
	            frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
	        }
	    }

	    defineProperties(PerspectiveOffCenterFrustum.prototype, {
	        /**
	         * Gets the perspective projection matrix computed from the view frustum.
	         * @memberof PerspectiveOffCenterFrustum.prototype
	         * @type {Matrix4}
	         *
	         * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix
	         */
	        projectionMatrix : {
	            get : function() {
	                update(this);
	                return this._perspectiveMatrix;
	            }
	        },

	        /**
	         * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
	         * @memberof PerspectiveOffCenterFrustum.prototype
	         * @type {Matrix4}
	         *
	         * @see PerspectiveOffCenterFrustum#projectionMatrix
	         */
	        infiniteProjectionMatrix : {
	            get : function() {
	                update(this);
	                return this._infinitePerspective;
	            }
	        }
	    });

	    var getPlanesRight = new Cartesian3();
	    var getPlanesNearCenter = new Cartesian3();
	    var getPlanesFarCenter = new Cartesian3();
	    var getPlanesNormal = new Cartesian3();
	    /**
	     * Creates a culling volume for this frustum.
	     *
	     * @param {Cartesian3} position The eye position.
	     * @param {Cartesian3} direction The view direction.
	     * @param {Cartesian3} up The up direction.
	     * @returns {CullingVolume} A culling volume at the given position and orientation.
	     *
	     * @example
	     * // Check if a bounding volume intersects the frustum.
	     * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
	     * var intersect = cullingVolume.computeVisibility(boundingVolume);
	     */
	    PerspectiveOffCenterFrustum.prototype.computeCullingVolume = function(position, direction, up) {
	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(position)) {
	            throw new DeveloperError('position is required.');
	        }

	        if (!defined(direction)) {
	            throw new DeveloperError('direction is required.');
	        }

	        if (!defined(up)) {
	            throw new DeveloperError('up is required.');
	        }
	        //>>includeEnd('debug');

	        var planes = this._cullingVolume.planes;

	        var t = this.top;
	        var b = this.bottom;
	        var r = this.right;
	        var l = this.left;
	        var n = this.near;
	        var f = this.far;

	        var right = Cartesian3.cross(direction, up, getPlanesRight);

	        var nearCenter = getPlanesNearCenter;
	        Cartesian3.multiplyByScalar(direction, n, nearCenter);
	        Cartesian3.add(position, nearCenter, nearCenter);

	        var farCenter = getPlanesFarCenter;
	        Cartesian3.multiplyByScalar(direction, f, farCenter);
	        Cartesian3.add(position, farCenter, farCenter);

	        var normal = getPlanesNormal;

	        //Left plane computation
	        Cartesian3.multiplyByScalar(right, l, normal);
	        Cartesian3.add(nearCenter, normal, normal);
	        Cartesian3.subtract(normal, position, normal);
	        Cartesian3.normalize(normal, normal);
	        Cartesian3.cross(normal, up, normal);

	        var plane = planes[0];
	        if (!defined(plane)) {
	            plane = planes[0] = new Cartesian4();
	        }
	        plane.x = normal.x;
	        plane.y = normal.y;
	        plane.z = normal.z;
	        plane.w = -Cartesian3.dot(normal, position);

	        //Right plane computation
	        Cartesian3.multiplyByScalar(right, r, normal);
	        Cartesian3.add(nearCenter, normal, normal);
	        Cartesian3.subtract(normal, position, normal);
	        Cartesian3.normalize(normal, normal);
	        Cartesian3.cross(up, normal, normal);

	        plane = planes[1];
	        if (!defined(plane)) {
	            plane = planes[1] = new Cartesian4();
	        }
	        plane.x = normal.x;
	        plane.y = normal.y;
	        plane.z = normal.z;
	        plane.w = -Cartesian3.dot(normal, position);

	        //Bottom plane computation
	        Cartesian3.multiplyByScalar(up, b, normal);
	        Cartesian3.add(nearCenter, normal, normal);
	        Cartesian3.subtract(normal, position, normal);
	        Cartesian3.normalize(normal, normal);
	        Cartesian3.cross(right, normal, normal);

	        plane = planes[2];
	        if (!defined(plane)) {
	            plane = planes[2] = new Cartesian4();
	        }
	        plane.x = normal.x;
	        plane.y = normal.y;
	        plane.z = normal.z;
	        plane.w = -Cartesian3.dot(normal, position);

	        //Top plane computation
	        Cartesian3.multiplyByScalar(up, t, normal);
	        Cartesian3.add(nearCenter, normal, normal);
	        Cartesian3.subtract(normal, position, normal);
	        Cartesian3.normalize(normal, normal);
	        Cartesian3.cross(normal, right, normal);

	        plane = planes[3];
	        if (!defined(plane)) {
	            plane = planes[3] = new Cartesian4();
	        }
	        plane.x = normal.x;
	        plane.y = normal.y;
	        plane.z = normal.z;
	        plane.w = -Cartesian3.dot(normal, position);

	        //Near plane computation
	        plane = planes[4];
	        if (!defined(plane)) {
	            plane = planes[4] = new Cartesian4();
	        }
	        plane.x = direction.x;
	        plane.y = direction.y;
	        plane.z = direction.z;
	        plane.w = -Cartesian3.dot(direction, nearCenter);

	        //Far plane computation
	        Cartesian3.negate(direction, normal);

	        plane = planes[5];
	        if (!defined(plane)) {
	            plane = planes[5] = new Cartesian4();
	        }
	        plane.x = normal.x;
	        plane.y = normal.y;
	        plane.z = normal.z;
	        plane.w = -Cartesian3.dot(normal, farCenter);

	        return this._cullingVolume;
	    };

	    /**
	     * Returns the pixel's width and height in meters.
	     *
	     * @param {Cartesian2} drawingBufferDimensions A {@link Cartesian2} with width and height in the x and y properties, respectively.
	     * @param {Number} [distance=near plane distance] The distance to the near plane in meters.
	     * @param {Cartesian2} [result] The object onto which to store the result.
	     * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
	     *
	     * @exception {DeveloperError} drawingBufferDimensions.x must be greater than zero.
	     * @exception {DeveloperError} drawingBufferDimensions.y must be greater than zero.
	     *
	     * @example
	     * // Example 1
	     * // Get the width and height of a pixel.
	     * var pixelSize = camera.frustum.getPixelSize(new Cesium.Cartesian2(canvas.clientWidth, canvas.clientHeight));
	     *
	     * @example
	     * // Example 2
	     * // Get the width and height of a pixel if the near plane was set to 'distance'.
	     * // For example, get the size of a pixel of an image on a billboard.
	     * var position = camera.position;
	     * var direction = camera.direction;
	     * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
	     * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector
	     * var distance = Cesium.Cartesian3.magnitude(toCenterProj);
	     * var pixelSize = camera.frustum.getPixelSize(new Cesium.Cartesian2(canvas.clientWidth, canvas.clientHeight), distance);
	     */
	    PerspectiveOffCenterFrustum.prototype.getPixelSize = function(drawingBufferDimensions, distance, result) {
	        update(this);

	        //>>includeStart('debug', pragmas.debug);
	        if (!defined(drawingBufferDimensions)) {
	            throw new DeveloperError('drawingBufferDimensions is required.');
	        }
	        //>>includeEnd('debug');

	        var width = drawingBufferDimensions.x;
	        var height = drawingBufferDimensions.y;

	        //>>includeStart('debug', pragmas.debug);
	        if (width <= 0) {
	            throw new DeveloperError('drawingBufferDimensions.x must be greater than zero.');
	        }

	        if (height <= 0) {
	            throw new DeveloperError('drawingBufferDimensions.y must be greater than zero.');
	        }
	        //>>includeEnd('debug');

	        distance = defaultValue(distance, this.near);

	        var inverseNear = 1.0 / this.near;
	        var tanTheta = this.top * inverseNear;
	        var pixelHeight = 2.0 * distance * tanTheta / height;
	        tanTheta = this.right * inverseNear;
	        var pixelWidth = 2.0 * distance * tanTheta / width;

	        if (!defined(result)) {
	            return new Cartesian2(pixelWidth, pixelHeight);
	        }

	        result.x = pixelWidth;
	        result.y = pixelHeight;
	        return result;
	    };

	    /**
	     * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
	     *
	     * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.
	     * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
	     */
	    PerspectiveOffCenterFrustum.prototype.clone = function(result) {
	        if (!defined(result)) {
	            result = new PerspectiveOffCenterFrustum();
	        }

	        result.right = this.right;
	        result.left = this.left;
	        result.top = this.top;
	        result.bottom = this.bottom;
	        result.near = this.near;
	        result.far = this.far;

	        // force update of clone to compute matrices
	        result._left = undefined;
	        result._right = undefined;
	        result._top = undefined;
	        result._bottom = undefined;
	        result._near = undefined;
	        result._far = undefined;

	        return result;
	    };

	    /**
	     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
	     * <code>true</code> if they are equal, <code>false</code> otherwise.
	     *
	     * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.
	     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
	     */
	    PerspectiveOffCenterFrustum.prototype.equals = function(other) {
	        return (defined(other) &&
	                this.right === other.right &&
	                this.left === other.left &&
	                this.top === other.top &&
	                this.bottom === other.bottom &&
	                this.near === other.near &&
	                this.far === other.far);
	    };

	    return PerspectiveOffCenterFrustum;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(7)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(
	        freezeObject) {
	    "use strict";

	    /**
	     * The vertical location of an origin relative to an object, e.g., a {@link Billboard}.
	     * For example, the vertical origin is used to display a billboard above or below (in
	     * screen space) of the actual position.
	     *
	     * @namespace
	     * @alias VerticalOrigin
	     *
	     * @see Billboard#verticalOrigin
	     */
	    var VerticalOrigin = {
	        /**
	         * The origin is at the vertical center of the object.
	         *
	         * @type {Number}
	         * @constant
	         */
	        CENTER : 0,

	        /**
	         * The origin is at the bottom of the object.
	         *
	         * @type {Number}
	         * @constant
	         */
	        BOTTOM : 1,

	        /**
	         * The origin is at the top of the object.
	         *
	         * @type {Number}
	         * @constant
	         */
	        TOP : -1
	    };

	    return freezeObject(VerticalOrigin);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	  I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
	  so it's better encapsulated. Now you can have multiple random number generators
	  and they won't stomp all over eachother's state.

	  If you want to use this as a substitute for Math.random(), use the random()
	  method like so:

	  var m = new MersenneTwister();
	  var randomNumber = m.random();

	  You can also call the other genrand_{foo}() methods on the instance.

	  If you want to use a specific seed in order to get a repeatable random
	  sequence, pass an integer into the constructor:

	  var m = new MersenneTwister(123);

	  and that will always produce the same random sequence.

	  Sean McCullough (banksean@gmail.com)
	*/

	/*
	   A C-program for MT19937, with initialization improved 2002/1/26.
	   Coded by Takuji Nishimura and Makoto Matsumoto.

	   Before using, initialize the state by using init_genrand(seed)
	   or init_by_array(init_key, key_length).
	*/
	/**
	@license
	mersenne-twister.js - https://gist.github.com/banksean/300494

	   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
	   All rights reserved.

	   Redistribution and use in source and binary forms, with or without
	   modification, are permitted provided that the following conditions
	   are met:

	     1. Redistributions of source code must retain the above copyright
	        notice, this list of conditions and the following disclaimer.

	     2. Redistributions in binary form must reproduce the above copyright
	        notice, this list of conditions and the following disclaimer in the
	        documentation and/or other materials provided with the distribution.

	     3. The names of its contributors may not be used to endorse or promote
	        products derived from this software without specific prior written
	        permission.

	   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
	   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	/*
	   Any feedback is very welcome.
	   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
	   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
	*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	var MersenneTwister = function(seed) {
	  if (seed == undefined) {
	    seed = new Date().getTime();
	  }
	  /* Period parameters */
	  this.N = 624;
	  this.M = 397;
	  this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	  this.mt = new Array(this.N); /* the array for the state vector */
	  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	  this.init_genrand(seed);
	}

	/* initializes mt[N] with a seed */
	MersenneTwister.prototype.init_genrand = function(s) {
	  this.mt[0] = s >>> 0;
	  for (this.mti=1; this.mti<this.N; this.mti++) {
	      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
	   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
	  + this.mti;
	      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
	      /* In the previous versions, MSBs of the seed affect   */
	      /* only MSBs of the array mt[].                        */
	      /* 2002/01/09 modified by Makoto Matsumoto             */
	      this.mt[this.mti] >>>= 0;
	      /* for >32 bit machines */
	  }
	}

	/* initialize by an array with array-length */
	/* init_key is the array for initializing keys */
	/* key_length is its length */
	/* slight change for C++, 2004/2/26 */
	//MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
	//  var i, j, k;
	//  this.init_genrand(19650218);
	//  i=1; j=0;
	//  k = (this.N>key_length ? this.N : key_length);
	//  for (; k; k--) {
	//    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
	//    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
	//      + init_key[j] + j; /* non linear */
	//    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
	//    i++; j++;
	//    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	//    if (j>=key_length) j=0;
	//  }
	//  for (k=this.N-1; k; k--) {
	//    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
	//    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
	//      - i; /* non linear */
	//    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
	//    i++;
	//    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	//  }
	//
	//  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
	//}

	/* generates a random number on [0,0xffffffff]-interval */
	MersenneTwister.prototype.genrand_int32 = function() {
	  var y;
	  var mag01 = new Array(0x0, this.MATRIX_A);
	  /* mag01[x] = x * MATRIX_A  for x=0,1 */

	  if (this.mti >= this.N) { /* generate N words at one time */
	    var kk;

	    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */
	      this.init_genrand(5489); /* a default initial seed is used */

	    for (kk=0;kk<this.N-this.M;kk++) {
	      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
	      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
	    }
	    for (;kk<this.N-1;kk++) {
	      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
	      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
	    }
	    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
	    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

	    this.mti = 0;
	  }

	  y = this.mt[this.mti++];

	  /* Tempering */
	  y ^= (y >>> 11);
	  y ^= (y << 7) & 0x9d2c5680;
	  y ^= (y << 15) & 0xefc60000;
	  y ^= (y >>> 18);

	  return y >>> 0;
	}

	/* generates a random number on [0,0x7fffffff]-interval */
	//MersenneTwister.prototype.genrand_int31 = function() {
	//  return (this.genrand_int32()>>>1);
	//}

	/* generates a random number on [0,1]-real-interval */
	//MersenneTwister.prototype.genrand_real1 = function() {
	//  return this.genrand_int32()*(1.0/4294967295.0);
	//  /* divided by 2^32-1 */
	//}

	/* generates a random number on [0,1)-real-interval */
	MersenneTwister.prototype.random = function() {
	  return this.genrand_int32()*(1.0/4294967296.0);
	  /* divided by 2^32 */
	}

	/* generates a random number on (0,1)-real-interval */
	//MersenneTwister.prototype.genrand_real3 = function() {
	//  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0);
	//  /* divided by 2^32 */
	//}

	/* generates a random number on [0,1) with 53-bit resolution*/
	//MersenneTwister.prototype.genrand_res53 = function() {
	//  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;
	//  return(a*67108864.0+b)*(1.0/9007199254740992.0);
	//}

	/* These real versions are due to Isaku Wada, 2002/01/09 added */

	return MersenneTwister;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	@license
	sprintf.js from the php.js project - https://github.com/kvz/phpjs
	Directly from https://github.com/kvz/phpjs/blob/master/functions/strings/sprintf.js

	php.js is copyright 2012 Kevin van Zonneveld.

	Portions copyright Brett Zamir (http://brett-zamir.me), Kevin van Zonneveld
	(http://kevin.vanzonneveld.net), Onno Marsman, Theriault, Michael White
	(http://getsprink.com), Waldo Malqui Silva, Paulo Freitas, Jack, Jonas
	Raoni Soares Silva (http://www.jsfromhell.com), Philip Peterson, Legaev
	Andrey, Ates Goral (http://magnetiq.com), Alex, Ratheous, Martijn Wieringa,
	Rafa? Kukawski (http://blog.kukawski.pl), lmeyrick
	(https://sourceforge.net/projects/bcmath-js/), Nate, Philippe Baumann,
	Enrique Gonzalez, Webtoolkit.info (http://www.webtoolkit.info/), Carlos R.
	L. Rodrigues (http://www.jsfromhell.com), Ash Searle
	(http://hexmen.com/blog/), Jani Hartikainen, travc, Ole Vrijenhoek,
	Erkekjetter, Michael Grier, Rafa? Kukawski (http://kukawski.pl), Johnny
	Mast (http://www.phpvrouwen.nl), T.Wild, d3x,
	http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript,
	Rafa? Kukawski (http://blog.kukawski.pl/), stag019, pilus, WebDevHobo
	(http://webdevhobo.blogspot.com/), marrtins, GeekFG
	(http://geekfg.blogspot.com), Andrea Giammarchi
	(http://webreflection.blogspot.com), Arpad Ray (mailto:arpad@php.net),
	gorthaur, Paul Smith, Tim de Koning (http://www.kingsquare.nl), Joris, Oleg
	Eremeev, Steve Hilder, majak, gettimeofday, KELAN, Josh Fraser
	(http://onlineaspect.com/2007/06/08/auto-detect-a-time-zone-with-javascript/),
	Marc Palau, Martin
	(http://www.erlenwiese.de/), Breaking Par Consulting Inc
	(http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256CFB006C45F7),
	Chris, Mirek Slugen, saulius, Alfonso Jimenez
	(http://www.alfonsojimenez.com), Diplom@t (http://difane.com/), felix,
	Mailfaker (http://www.weedem.fr/), Tyler Akins (http://rumkin.com), Caio
	Ariede (http://caioariede.com), Robin, Kankrelune
	(http://www.webfaktory.info/), Karol Kowalski, Imgen Tata
	(http://www.myipdf.com/), mdsjack (http://www.mdsjack.bo.it), Dreamer,
	Felix Geisendoerfer (http://www.debuggable.com/felix), Lars Fischer, AJ,
	David, Aman Gupta, Michael White, Public Domain
	(http://www.json.org/json2.js), Steven Levithan
	(http://blog.stevenlevithan.com), Sakimori, Pellentesque Malesuada,
	Thunder.m, Dj (http://phpjs.org/functions/htmlentities:425#comment_134018),
	Steve Clay, David James, Francois, class_exists, nobbler, T. Wild, Itsacon
	(http://www.itsacon.net/), date, Ole Vrijenhoek (http://www.nervous.nl/),
	Fox, Raphael (Ao RUDLER), Marco, noname, Mateusz "loonquawl" Zalega, Frank
	Forte, Arno, ger, mktime, john (http://www.jd-tech.net), Nick Kolosov
	(http://sammy.ru), marc andreu, Scott Cariss, Douglas Crockford
	(http://javascript.crockford.com), madipta, Slawomir Kaniecki,
	ReverseSyntax, Nathan, Alex Wilson, kenneth, Bayron Guevara, Adam Wallner
	(http://web2.bitbaro.hu/), paulo kuong, jmweb, Lincoln Ramsay, djmix,
	Pyerre, Jon Hohle, Thiago Mata (http://thiagomata.blog.com), lmeyrick
	(https://sourceforge.net/projects/bcmath-js/this.), Linuxworld, duncan,
	Gilbert, Sanjoy Roy, Shingo, sankai, Oskar Larsson H?gfeldt
	(http://oskar-lh.name/), Denny Wardhana, 0m3r, Everlasto, Subhasis Deb,
	josh, jd, Pier Paolo Ramon (http://www.mastersoup.com/), P, merabi, Soren
	Hansen, Eugene Bulkin (http://doubleaw.com/), Der Simon
	(http://innerdom.sourceforge.net/), echo is bad, Ozh, XoraX
	(http://www.xorax.info), EdorFaus, JB, J A R, Marc Jansen, Francesco, LH,
	Stoyan Kyosev (http://www.svest.org/), nord_ua, omid
	(http://phpjs.org/functions/380:380#comment_137122), Brad Touesnard, MeEtc
	(http://yass.meetcweb.com), Peter-Paul Koch
	(http://www.quirksmode.org/js/beat.html), Olivier Louvignes
	(http://mg-crea.com/), T0bsn, Tim Wiel, Bryan Elliott, Jalal Berrami,
	Martin, JT, David Randall, Thomas Beaucourt (http://www.webapp.fr), taith,
	vlado houba, Pierre-Luc Paour, Kristof Coomans (SCK-CEN Belgian Nucleair
	Research Centre), Martin Pool, Kirk Strobeck, Rick Waldron, Brant Messenger
	(http://www.brantmessenger.com/), Devan Penner-Woelk, Saulo Vallory, Wagner
	B. Soares, Artur Tchernychev, Valentina De Rosa, Jason Wong
	(http://carrot.org/), Christoph, Daniel Esteban, strftime, Mick@el, rezna,
	Simon Willison (http://simonwillison.net), Anton Ongson, Gabriel Paderni,
	Marco van Oort, penutbutterjelly, Philipp Lenssen, Bjorn Roesbeke
	(http://www.bjornroesbeke.be/), Bug?, Eric Nagel, Tomasz Wesolowski,
	Evertjan Garretsen, Bobby Drake, Blues (http://tech.bluesmoon.info/), Luke
	Godfrey, Pul, uestla, Alan C, Ulrich, Rafal Kukawski, Yves Sucaet,
	sowberry, Norman "zEh" Fuchs, hitwork, Zahlii, johnrembo, Nick Callen,
	Steven Levithan (stevenlevithan.com), ejsanders, Scott Baker, Brian Tafoya
	(http://www.premasolutions.com/), Philippe Jausions
	(http://pear.php.net/user/jausions), Aidan Lister
	(http://aidanlister.com/), Rob, e-mike, HKM, ChaosNo1, metjay, strcasecmp,
	strcmp, Taras Bogach, jpfle, Alexander Ermolaev
	(http://snippets.dzone.com/user/AlexanderErmolaev), DxGx, kilops, Orlando,
	dptr1988, Le Torbi, James (http://www.james-bell.co.uk/), Pedro Tainha
	(http://www.pedrotainha.com), James, Arnout Kazemier
	(http://www.3rd-Eden.com), Chris McMacken, gabriel paderni, Yannoo,
	FGFEmperor, baris ozdil, Tod Gentille, Greg Frazier, jakes, 3D-GRAF, Allan
	Jensen (http://www.winternet.no), Howard Yeend, Benjamin Lupton, davook,
	daniel airton wermann (http://wermann.com.br), Atli Tr, Maximusya, Ryan
	W Tenney (http://ryan.10e.us), Alexander M Beedie, fearphage
	(http://http/my.opera.com/fearphage/), Nathan Sepulveda, Victor, Matteo,
	Billy, stensi, Cord, Manish, T.J. Leahy, Riddler
	(http://www.frontierwebdev.com/), Rafa? Kukawski, FremyCompany, Matt
	Bradley, Tim de Koning, Luis Salazar (http://www.freaky-media.com/), Diogo
	Resende, Rival, Andrej Pavlovic, Garagoth, Le Torbi
	(http://www.letorbi.de/), Dino, Josep Sanz (http://www.ws3.es/), rem,
	Russell Walker (http://www.nbill.co.uk/), Jamie Beck
	(http://www.terabit.ca/), setcookie, Michael, YUI Library:
	http://developer.yahoo.com/yui/docs/YAHOO.util.DateLocale.html, Blues at
	http://hacks.bluesmoon.info/strftime/strftime.js, Ben
	(http://benblume.co.uk/), DtTvB
	(http://dt.in.th/2008-09-16.string-length-in-bytes.html), Andreas, William,
	meo, incidence, Cagri Ekin, Amirouche, Amir Habibi
	(http://www.residence-mixte.com/), Luke Smith (http://lucassmith.name),
	Kheang Hok Chin (http://www.distantia.ca/), Jay Klehr, Lorenzo Pisani,
	Tony, Yen-Wei Liu, Greenseed, mk.keck, Leslie Hoare, dude, booeyOH, Ben
	Bryan

	Licensed under the MIT (MIT-LICENSE.txt) license.

	Permission is hereby granted, free of charge, to any person obtaining a
	copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES
	OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
	*/

	/*global define*/
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {

	function sprintf () {
	  // http://kevin.vanzonneveld.net
	  // +   original by: Ash Searle (http://hexmen.com/blog/)
	  // + namespaced by: Michael White (http://getsprink.com)
	  // +    tweaked by: Jack
	  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	  // +      input by: Paulo Freitas
	  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	  // +      input by: Brett Zamir (http://brett-zamir.me)
	  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	  // +   improved by: Dj
	  // +   improved by: Allidylls
	  // *     example 1: sprintf("%01.2f", 123.1);
	  // *     returns 1: 123.10
	  // *     example 2: sprintf("[%10s]", 'monkey');
	  // *     returns 2: '[    monkey]'
	  // *     example 3: sprintf("[%'#10s]", 'monkey');
	  // *     returns 3: '[####monkey]'
	  // *     example 4: sprintf("%d", 123456789012345);
	  // *     returns 4: '123456789012345'
	  var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
	  var a = arguments,
	    i = 0,
	    format = a[i++];

	  // pad()
	  var pad = function (str, len, chr, leftJustify) {
	    if (!chr) {
	      chr = ' ';
	    }
	    var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
	    return leftJustify ? str + padding : padding + str;
	  };

	  // justify()
	  var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
	    var diff = minWidth - value.length;
	    if (diff > 0) {
	      if (leftJustify || !zeroPad) {
	        value = pad(value, minWidth, customPadChar, leftJustify);
	      } else {
	        value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
	      }
	    }
	    return value;
	  };

	  // formatBaseX()
	  var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
	    // Note: casts negative numbers to positive ones
	    var number = value >>> 0;
	    prefix = prefix && number && {
	      '2': '0b',
	      '8': '0',
	      '16': '0x'
	    }[base] || '';
	    value = prefix + pad(number.toString(base), precision || 0, '0', false);
	    return justify(value, prefix, leftJustify, minWidth, zeroPad);
	  };

	  // formatString()
	  var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
	    if (precision != null) {
	      value = value.slice(0, precision);
	    }
	    return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
	  };

	  // doFormat()
	  var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
	    var number;
	    var prefix;
	    var method;
	    var textTransform;
	    var value;

	    if (substring == '%%') {
	      return '%';
	    }

	    // parse flags
	    var leftJustify = false,
	      positivePrefix = '',
	      zeroPad = false,
	      prefixBaseX = false,
	      customPadChar = ' ';
	    var flagsl = flags.length;
	    for (var j = 0; flags && j < flagsl; j++) {
	      switch (flags.charAt(j)) {
	      case ' ':
	        positivePrefix = ' ';
	        break;
	      case '+':
	        positivePrefix = '+';
	        break;
	      case '-':
	        leftJustify = true;
	        break;
	      case "'":
	        customPadChar = flags.charAt(j + 1);
	        break;
	      case '0':
	        zeroPad = true;
	        break;
	      case '#':
	        prefixBaseX = true;
	        break;
	      }
	    }

	    // parameters may be null, undefined, empty-string or real valued
	    // we want to ignore null, undefined and empty-string values
	    if (!minWidth) {
	      minWidth = 0;
	    } else if (minWidth == '*') {
	      minWidth = +a[i++];
	    } else if (minWidth.charAt(0) == '*') {
	      minWidth = +a[minWidth.slice(1, -1)];
	    } else {
	      minWidth = +minWidth;
	    }

	    // Note: undocumented perl feature:
	    if (minWidth < 0) {
	      minWidth = -minWidth;
	      leftJustify = true;
	    }

	    if (!isFinite(minWidth)) {
	      throw new Error('sprintf: (minimum-)width must be finite');
	    }

	    if (!precision) {
	      precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;
	    } else if (precision == '*') {
	      precision = +a[i++];
	    } else if (precision.charAt(0) == '*') {
	      precision = +a[precision.slice(1, -1)];
	    } else {
	      precision = +precision;
	    }

	    // grab value using valueIndex if required?
	    value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

	    switch (type) {
	    case 's':
	      return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
	    case 'c':
	      return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
	    case 'b':
	      return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	    case 'o':
	      return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	    case 'x':
	      return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	    case 'X':
	      return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
	    case 'u':
	      return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
	    case 'i':
	    case 'd':
	      number = +value || 0;
	      number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate
	      prefix = number < 0 ? '-' : positivePrefix;
	      value = prefix + pad(String(Math.abs(number)), precision, '0', false);
	      return justify(value, prefix, leftJustify, minWidth, zeroPad);
	    case 'e':
	    case 'E':
	    case 'f': // Should handle locales (as per setlocale)
	    case 'F':
	    case 'g':
	    case 'G':
	      number = +value;
	      prefix = number < 0 ? '-' : positivePrefix;
	      method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
	      textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
	      value = prefix + Math.abs(number)[method](precision);
	      return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
	    default:
	      return substring;
	    }
	  };

	  return format.replace(regex, doFormat);
	}

	return sprintf;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * cuid.js
	 * Collision-resistant UID generator for browsers and node.
	 * Sequential for fast db lookups and recency sorting.
	 * Safe for element IDs and server-side lookups.
	 *
	 * Extracted from CLCTR
	 * 
	 * Copyright (c) Eric Elliott 2012
	 * MIT License
	 */

	/*global window, navigator, document, require, process, module */
	(function (app) {
	  'use strict';
	  var namespace = 'cuid',
	    c = 0,
	    blockSize = 4,
	    base = 36,
	    discreteValues = Math.pow(base, blockSize),

	    pad = function pad(num, size) {
	      var s = "000000000" + num;
	      return s.substr(s.length-size);
	    },

	    randomBlock = function randomBlock() {
	      return pad((Math.random() *
	            discreteValues << 0)
	            .toString(base), blockSize);
	    },

	    safeCounter = function () {
	      c = (c < discreteValues) ? c : 0;
	      c++; // this is not subliminal
	      return c - 1;
	    },

	    api = function cuid() {
	      // Starting with a lowercase letter makes
	      // it HTML element ID friendly.
	      var letter = 'c', // hard-coded allows for sequential access

	        // timestamp
	        // warning: this exposes the exact date and time
	        // that the uid was created.
	        timestamp = (new Date().getTime()).toString(base),

	        // Prevent same-machine collisions.
	        counter,

	        // A few chars to generate distinct ids for different
	        // clients (so different computers are far less
	        // likely to generate the same id)
	        fingerprint = api.fingerprint(),

	        // Grab some more chars from Math.random()
	        random = randomBlock() + randomBlock();

	        counter = pad(safeCounter().toString(base), blockSize);

	      return  (letter + timestamp + counter + fingerprint + random);
	    };

	  api.slug = function slug() {
	    var date = new Date().getTime().toString(36),
	      counter,
	      print = api.fingerprint().slice(0,1) +
	        api.fingerprint().slice(-1),
	      random = randomBlock().slice(-2);

	      counter = safeCounter().toString(36).slice(-4);

	    return date.slice(-2) + 
	      counter + print + random;
	  };

	  api.globalCount = function globalCount() {
	    // We want to cache the results of this
	    var cache = (function calc() {
	        var i,
	          count = 0;

	        for (i in window) {
	          count++;
	        }

	        return count;
	      }());

	    api.globalCount = function () { return cache; };
	    return cache;
	  };

	  api.fingerprint = function browserPrint() {
	    return pad((navigator.mimeTypes.length +
	      navigator.userAgent.length).toString(36) +
	      api.globalCount().toString(36), 4);
	  };

	  // don't change anything from here down.
	  if (app.register) {
	    app.register(namespace, api);
	  } else if (true) {
	    module.exports = api;
	  } else {
	    app[namespace] = api;
	  }

	}(this.applitude || this));


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2015
	 */
	var EventHandler = __webpack_require__(48);
	function OptionsManager(value) {
	    this._value = value;
	    this.eventOutput = null;
	}
	OptionsManager.patch = function patchObject(source, data) {
	    var manager = new OptionsManager(source);
	    for (var i = 1; i < arguments.length; i++)
	        manager.patch(arguments[i]);
	    return source;
	};
	function _createEventOutput() {
	    this.eventOutput = new EventHandler();
	    this.eventOutput.bindThis(this);
	    EventHandler.setOutputHandler(this, this.eventOutput);
	}
	OptionsManager.prototype.patch = function patch() {
	    var myState = this._value;
	    for (var i = 0; i < arguments.length; i++) {
	        var data = arguments[i];
	        for (var k in data) {
	            if (k in myState && (data[k] && data[k].constructor === Object) && (myState[k] && myState[k].constructor === Object)) {
	                if (!myState.hasOwnProperty(k))
	                    myState[k] = Object.create(myState[k]);
	                this.key(k).patch(data[k]);
	                if (this.eventOutput)
	                    this.eventOutput.emit('change', {
	                        id: k,
	                        value: this.key(k).value()
	                    });
	            } else
	                this.set(k, data[k]);
	        }
	    }
	    return this;
	};
	OptionsManager.prototype.setOptions = OptionsManager.prototype.patch;
	OptionsManager.prototype.key = function key(identifier) {
	    var result = new OptionsManager(this._value[identifier]);
	    if (!(result._value instanceof Object) || result._value instanceof Array)
	        result._value = {};
	    return result;
	};
	OptionsManager.prototype.get = function get(key) {
	    return key ? this._value[key] : this._value;
	};
	OptionsManager.prototype.getOptions = OptionsManager.prototype.get;
	OptionsManager.prototype.set = function set(key, value) {
	    var originalValue = this.get(key);
	    this._value[key] = value;
	    if (this.eventOutput && value !== originalValue)
	        this.eventOutput.emit('change', {
	            id: key,
	            value: value
	        });
	    return this;
	};
	OptionsManager.prototype.on = function on() {
	    _createEventOutput.call(this);
	    return this.on.apply(this, arguments);
	};
	OptionsManager.prototype.removeListener = function removeListener() {
	    _createEventOutput.call(this);
	    return this.removeListener.apply(this, arguments);
	};
	OptionsManager.prototype.pipe = function pipe() {
	    _createEventOutput.call(this);
	    return this.pipe.apply(this, arguments);
	};
	OptionsManager.prototype.unpipe = function unpipe() {
	    _createEventOutput.call(this);
	    return this.unpipe.apply(this, arguments);
	};
	module.exports = OptionsManager;

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2015
	 */
	var EventHandler = __webpack_require__(48);
	function EventArbiter(startMode) {
	    this.dispatchers = {};
	    this.currMode = undefined;
	    this.setMode(startMode);
	}
	EventArbiter.prototype.setMode = function setMode(mode) {
	    if (mode !== this.currMode) {
	        var startMode = this.currMode;
	        if (this.dispatchers[this.currMode])
	            this.dispatchers[this.currMode].trigger('unpipe');
	        this.currMode = mode;
	        if (this.dispatchers[mode])
	            this.dispatchers[mode].emit('pipe');
	        this.emit('change', {
	            from: startMode,
	            to: mode
	        });
	    }
	};
	EventArbiter.prototype.forMode = function forMode(mode) {
	    if (!this.dispatchers[mode])
	        this.dispatchers[mode] = new EventHandler();
	    return this.dispatchers[mode];
	};
	EventArbiter.prototype.emit = function emit(eventType, event) {
	    if (this.currMode === undefined)
	        return false;
	    if (!event)
	        event = {};
	    var dispatcher = this.dispatchers[this.currMode];
	    if (dispatcher)
	        return dispatcher.trigger(eventType, event);
	};
	module.exports = EventArbiter;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2015
	 */
	var EventHandler = __webpack_require__(48);
	function EventFilter(condition) {
	    EventHandler.call(this);
	    this._condition = condition;
	}
	EventFilter.prototype = Object.create(EventHandler.prototype);
	EventFilter.prototype.constructor = EventFilter;
	EventFilter.prototype.emit = function emit(type, data) {
	    if (this._condition(type, data))
	        return EventHandler.prototype.emit.apply(this, arguments);
	};
	EventFilter.prototype.trigger = EventFilter.prototype.emit;
	module.exports = EventFilter;

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2015
	 */
	var EventHandler = __webpack_require__(48);
	function EventMapper(mappingFunction) {
	    EventHandler.call(this);
	    this._mappingFunction = mappingFunction;
	}
	EventMapper.prototype = Object.create(EventHandler.prototype);
	EventMapper.prototype.constructor = EventMapper;
	EventMapper.prototype.subscribe = null;
	EventMapper.prototype.unsubscribe = null;
	EventMapper.prototype.emit = function emit(type, data) {
	    var target = this._mappingFunction.apply(this, arguments);
	    if (target && target.emit instanceof Function)
	        target.emit(type, data);
	};
	EventMapper.prototype.trigger = EventMapper.prototype.emit;
	module.exports = EventMapper;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    draining = true;
	    var currentQueue;
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        var i = -1;
	        while (++i < len) {
	            currentQueue[i]();
	        }
	        len = queue.length;
	    }
	    draining = false;
	}
	process.nextTick = function (fun) {
	    queue.push(fun);
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.4 - 2014-09-28
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2014 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';

	var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge]
	 * @returns {Object} dest
	 */
	function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	function merge(dest, src) {
	    return extend(dest, src, true);
	}

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        extend(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument;
	    return (doc.defaultView || doc.parentWindow);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = last.deltaX - input.deltaX;
	        var deltaY = last.deltaY - input.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.allow = true; // used by Input.TouchMouse to disable mouse events
	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
	        if (!this.pressed || !this.allow) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */
	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        // when we're in a touch event, so  block all upcoming mouse events
	        // most mobile browser also emit mouseevents, right after touchstart
	        if (isTouch) {
	            this.mouse.allow = false;
	        } else if (isMouse && !this.mouse.allow) {
	            return;
	        }

	        // reset the allowMouse when we're done
	        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
	            this.mouse.allow = true;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        // not needed with native support for the touchAction property
	        if (NATIVE_TOUCH_ACTION) {
	            return;
	        }

	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // pan-x and pan-y can be combined
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.id = uniqueId();

	    this.manager = null;
	    this.options = merge(options || {}, this.defaults);

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        extend(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(withState) {
	            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(true);
	        }

	        emit(); // simple 'eventName' events

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(true);
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = extend({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {
	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        this._super.emit.call(this, input);
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            this.manager.emit(this.options.event + inOut, input);
	        }
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 500, // minimal time of the pointer to be pressed
	        threshold: 5 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.65,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.velocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.velocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.velocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.direction &&
	            input.distance > this.options.threshold &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.direction);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 2, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED ) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create an manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.4';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, { enable: false }],
	        [PinchRecognizer, { enable: false }, ['rotate']],
	        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
	        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    options = options || {};

	    this.options = merge(options, Hammer.defaults);
	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        extend(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        var recognizers = this.recognizers;
	        recognizer = this.get(recognizer);
	        recognizers.splice(inArray(recognizers, recognizer), 1);

	        this.touchAction.update();
	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    each(manager.options.cssProps, function(value, name) {
	        element.style[prefixed(element.style, name)] = add ? value : '';
	    });
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	extend(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	if ("function" == TYPE_FUNCTION && __webpack_require__(214)) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/**
	* Detect Element Resize
	*
	* https://github.com/sdecima/javascript-detect-element-resize
	* Sebastian Decima
	*
	* version: 0.5.3
	**/

	(function () {
		var attachEvent = document.attachEvent,
			stylesCreated = false;
		
		if (!attachEvent) {
			var requestFrame = (function(){
				var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||
									function(fn){ return window.setTimeout(fn, 20); };
				return function(fn){ return raf(fn); };
			})();
			
			var cancelFrame = (function(){
				var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame ||
									   window.clearTimeout;
			  return function(id){ return cancel(id); };
			})();

			function resetTriggers(element){
				var triggers = element.__resizeTriggers__,
					expand = triggers.firstElementChild,
					contract = triggers.lastElementChild,
					expandChild = expand.firstElementChild;
				contract.scrollLeft = contract.scrollWidth;
				contract.scrollTop = contract.scrollHeight;
				expandChild.style.width = expand.offsetWidth + 1 + 'px';
				expandChild.style.height = expand.offsetHeight + 1 + 'px';
				expand.scrollLeft = expand.scrollWidth;
				expand.scrollTop = expand.scrollHeight;
			};

			function checkTriggers(element){
				return element.offsetWidth != element.__resizeLast__.width ||
							 element.offsetHeight != element.__resizeLast__.height;
			}
			
			function scrollListener(e){
				var element = this;
				resetTriggers(this);
				if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
				this.__resizeRAF__ = requestFrame(function(){
					if (checkTriggers(element)) {
						element.__resizeLast__.width = element.offsetWidth;
						element.__resizeLast__.height = element.offsetHeight;
						element.__resizeListeners__.forEach(function(fn){
							fn.call(element, e);
						});
					}
				});
			};
			
			/* Detect CSS Animations support to detect element display/re-attach */
			var animation = false,
				animationstring = 'animation',
				keyframeprefix = '',
				animationstartevent = 'animationstart',
				domPrefixes = 'Webkit Moz O ms'.split(' '),
				startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
				pfx  = '';
			{
				var elm = document.createElement('fakeelement');
				if( elm.style.animationName !== undefined ) { animation = true; }    
				
				if( animation === false ) {
					for( var i = 0; i < domPrefixes.length; i++ ) {
						if( elm.style[ domPrefixes[i] + 'AnimationName' ] !== undefined ) {
							pfx = domPrefixes[ i ];
							animationstring = pfx + 'Animation';
							keyframeprefix = '-' + pfx.toLowerCase() + '-';
							animationstartevent = startEvents[ i ];
							animation = true;
							break;
						}
					}
				}
			}
			
			var animationName = 'resizeanim';
			var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
			var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';
		}
		
		function createStyles() {
			if (!stylesCreated) {
				//opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
				var css = (animationKeyframes ? animationKeyframes : '') +
						'.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' +
						'.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
					head = document.head || document.getElementsByTagName('head')[0],
					style = document.createElement('style');
				
				style.type = 'text/css';
				if (style.styleSheet) {
					style.styleSheet.cssText = css;
				} else {
					style.appendChild(document.createTextNode(css));
				}

				head.appendChild(style);
				stylesCreated = true;
			}
		}
		
		window.addResizeListener = function(element, fn){
			if (attachEvent) element.attachEvent('onresize', fn);
			else {
				if (!element.__resizeTriggers__) {
					if (getComputedStyle(element).position == 'static') element.style.position = 'relative';
					createStyles();
					element.__resizeLast__ = {};
					element.__resizeListeners__ = [];
					(element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
					element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' +
																							'<div class="contract-trigger"></div>';
					element.appendChild(element.__resizeTriggers__);
					resetTriggers(element);
					element.addEventListener('scroll', scrollListener, true);
					
					/* Listen for a css animation to detect element display/re-attach */
					animationstartevent && element.__resizeTriggers__.addEventListener(animationstartevent, function(e) {
						if(e.animationName == animationName)
							resetTriggers(element);
					});
				}
				element.__resizeListeners__.push(fn);
			}
		};
		
		window.removeResizeListener = function(element, fn){
			if (attachEvent) element.detachEvent('onresize', fn);
			else {
				element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
				if (!element.__resizeListeners__.length) {
						element.removeEventListener('scroll', scrollListener);
						element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
				}
			}
		}
	})();

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "/*!\n* basket.js\n* v0.5.2 - 2015-02-07\n* http://addyosmani.github.com/basket.js\n* (c) Addy Osmani;  License\n* Created by: Addy Osmani, Sindre Sorhus, Andre Hansson, Mat Scales\n* Contributors: Ironsjp, Mathias Bynens, Rick Waldron, Felipe Morais\n* Uses rsvp.js, https://github.com/tildeio/rsvp.js\n*/\n(function(){\"use strict\";function a(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1}function b(a){var b=a._promiseCallbacks;return b||(b=a._promiseCallbacks={}),b}function c(a,b){return\"onerror\"===a?void rb.on(\"error\",b):2!==arguments.length?rb[a]:void(rb[a]=b)}function d(a){return\"function\"==typeof a||\"object\"==typeof a&&null!==a}function e(a){return\"function\"==typeof a}function f(a){return\"object\"==typeof a&&null!==a}function g(){}function h(){setTimeout(function(){for(var a,b=0;b<wb.length;b++){a=wb[b];var c=a.payload;c.guid=c.key+c.id,c.childGuid=c.key+c.childId,c.error&&(c.stack=c.error.stack),rb.trigger(a.name,a.payload)}wb.length=0},50)}function i(a,b,c){1===wb.push({name:a,payload:{key:b._guidKey,id:b._id,eventName:a,detail:b._result,childId:c&&c._id,label:b._label,timeStamp:ub(),error:rb[\"instrument-with-stack\"]?new Error(b._label):null}})&&h()}function j(){return new TypeError(\"A promises callback cannot return that same promise.\")}function k(){}function l(a){try{return a.then}catch(b){return Bb.error=b,Bb}}function m(a,b,c,d){try{a.call(b,c,d)}catch(e){return e}}function n(a,b,c){rb.async(function(a){var d=!1,e=m(c,b,function(c){d||(d=!0,b!==c?q(a,c):s(a,c))},function(b){d||(d=!0,t(a,b))},\"Settle: \"+(a._label||\" unknown promise\"));!d&&e&&(d=!0,t(a,e))},a)}function o(a,b){b._state===zb?s(a,b._result):b._state===Ab?(b._onError=null,t(a,b._result)):u(b,void 0,function(c){b!==c?q(a,c):s(a,c)},function(b){t(a,b)})}function p(a,b){if(b.constructor===a.constructor)o(a,b);else{var c=l(b);c===Bb?t(a,Bb.error):void 0===c?s(a,b):e(c)?n(a,b,c):s(a,b)}}function q(a,b){a===b?s(a,b):d(b)?p(a,b):s(a,b)}function r(a){a._onError&&a._onError(a._result),v(a)}function s(a,b){a._state===yb&&(a._result=b,a._state=zb,0===a._subscribers.length?rb.instrument&&xb(\"fulfilled\",a):rb.async(v,a))}function t(a,b){a._state===yb&&(a._state=Ab,a._result=b,rb.async(r,a))}function u(a,b,c,d){var e=a._subscribers,f=e.length;a._onError=null,e[f]=b,e[f+zb]=c,e[f+Ab]=d,0===f&&a._state&&rb.async(v,a)}function v(a){var b=a._subscribers,c=a._state;if(rb.instrument&&xb(c===zb?\"fulfilled\":\"rejected\",a),0!==b.length){for(var d,e,f=a._result,g=0;g<b.length;g+=3)d=b[g],e=b[g+c],d?y(c,d,e,f):e(f);a._subscribers.length=0}}function w(){this.error=null}function x(a,b){try{return a(b)}catch(c){return Cb.error=c,Cb}}function y(a,b,c,d){var f,g,h,i,k=e(c);if(k){if(f=x(c,d),f===Cb?(i=!0,g=f.error,f=null):h=!0,b===f)return void t(b,j())}else f=d,h=!0;b._state!==yb||(k&&h?q(b,f):i?t(b,g):a===zb?s(b,f):a===Ab&&t(b,f))}function z(a,b){var c=!1;try{b(function(b){c||(c=!0,q(a,b))},function(b){c||(c=!0,t(a,b))})}catch(d){t(a,d)}}function A(a,b,c){return a===zb?{state:\"fulfilled\",value:c}:{state:\"rejected\",reason:c}}function B(a,b,c,d){this._instanceConstructor=a,this.promise=new a(k,d),this._abortOnReject=c,this._validateInput(b)?(this._input=b,this.length=b.length,this._remaining=b.length,this._init(),0===this.length?s(this.promise,this._result):(this.length=this.length||0,this._enumerate(),0===this._remaining&&s(this.promise,this._result))):t(this.promise,this._validationError())}function C(a,b){return new Db(this,a,!0,b).promise}function D(a,b){function c(a){q(f,a)}function d(a){t(f,a)}var e=this,f=new e(k,b);if(!tb(a))return t(f,new TypeError(\"You must pass an array to race.\")),f;for(var g=a.length,h=0;f._state===yb&&g>h;h++)u(e.resolve(a[h]),void 0,c,d);return f}function E(a,b){var c=this;if(a&&\"object\"==typeof a&&a.constructor===c)return a;var d=new c(k,b);return q(d,a),d}function F(a,b){var c=this,d=new c(k,b);return t(d,a),d}function G(){throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\")}function H(){throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\")}function I(a,b){this._id=Jb++,this._label=b,this._state=void 0,this._result=void 0,this._subscribers=[],rb.instrument&&xb(\"created\",this),k!==a&&(e(a)||G(),this instanceof I||H(),z(this,a))}function J(){this.value=void 0}function K(a){try{return a.then}catch(b){return Lb.value=b,Lb}}function L(a,b,c){try{a.apply(b,c)}catch(d){return Lb.value=d,Lb}}function M(a,b){for(var c,d,e={},f=a.length,g=new Array(f),h=0;f>h;h++)g[h]=a[h];for(d=0;d<b.length;d++)c=b[d],e[c]=g[d+1];return e}function N(a){for(var b=a.length,c=new Array(b-1),d=1;b>d;d++)c[d-1]=a[d];return c}function O(a,b){return{then:function(c,d){return a.call(b,c,d)}}}function P(a,b){var c=function(){for(var c,d=this,e=arguments.length,f=new Array(e+1),g=!1,h=0;e>h;++h){if(c=arguments[h],!g){if(g=S(c),g===Mb){var i=new Kb(k);return t(i,Mb.value),i}g&&g!==!0&&(c=O(g,c))}f[h]=c}var j=new Kb(k);return f[e]=function(a,c){a?t(j,a):void 0===b?q(j,c):b===!0?q(j,N(arguments)):tb(b)?q(j,M(arguments,b)):q(j,c)},g?R(j,f,a,d):Q(j,f,a,d)};return c.__proto__=a,c}function Q(a,b,c,d){var e=L(c,d,b);return e===Lb&&t(a,e.value),a}function R(a,b,c,d){return Kb.all(b).then(function(b){var e=L(c,d,b);return e===Lb&&t(a,e.value),a})}function S(a){return a&&\"object\"==typeof a?a.constructor===Kb?!0:K(a):!1}function T(a,b){return Kb.all(a,b)}function U(a,b,c){this._superConstructor(a,b,!1,c)}function V(a,b){return new U(Kb,a,b).promise}function W(a,b){return Kb.race(a,b)}function X(a,b,c){this._superConstructor(a,b,!0,c)}function Y(a,b){return new Rb(Kb,a,b).promise}function Z(a,b,c){this._superConstructor(a,b,!1,c)}function $(a,b){return new Z(Kb,a,b).promise}function _(a){throw setTimeout(function(){throw a}),a}function ab(a){var b={};return b.promise=new Kb(function(a,c){b.resolve=a,b.reject=c},a),b}function bb(a,b,c){return Kb.all(a,c).then(function(a){if(!e(b))throw new TypeError(\"You must pass a function as map's second argument.\");for(var d=a.length,f=new Array(d),g=0;d>g;g++)f[g]=b(a[g]);return Kb.all(f,c)})}function cb(a,b){return Kb.resolve(a,b)}function db(a,b){return Kb.reject(a,b)}function eb(a,b,c){return Kb.all(a,c).then(function(a){if(!e(b))throw new TypeError(\"You must pass a function as filter's second argument.\");for(var d=a.length,f=new Array(d),g=0;d>g;g++)f[g]=b(a[g]);return Kb.all(f,c).then(function(b){for(var c=new Array(d),e=0,f=0;d>f;f++)b[f]&&(c[e]=a[f],e++);return c.length=e,c})})}function fb(a,b){gc[_b]=a,gc[_b+1]=b,_b+=2,2===_b&&Tb()}function gb(){var a=process.nextTick,b=process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);return Array.isArray(b)&&\"0\"===b[1]&&\"10\"===b[2]&&(a=setImmediate),function(){a(lb)}}function hb(){return function(){vertxNext(lb)}}function ib(){var a=0,b=new dc(lb),c=document.createTextNode(\"\");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function jb(){var a=new MessageChannel;return a.port1.onmessage=lb,function(){a.port2.postMessage(0)}}function kb(){return function(){setTimeout(lb,1)}}function lb(){for(var a=0;_b>a;a+=2){var b=gc[a],c=gc[a+1];b(c),gc[a]=void 0,gc[a+1]=void 0}_b=0}function mb(){try{var a=require(\"vertx\");return a.runOnLoop||a.runOnContext,hb()}catch(b){return kb()}}function nb(a,b){rb.async(a,b)}function ob(){rb.on.apply(rb,arguments)}function pb(){rb.off.apply(rb,arguments)}var qb={mixin:function(a){return a.on=this.on,a.off=this.off,a.trigger=this.trigger,a._promiseCallbacks=void 0,a},on:function(c,d){var e,f=b(this);e=f[c],e||(e=f[c]=[]),-1===a(e,d)&&e.push(d)},off:function(c,d){var e,f,g=b(this);return d?(e=g[c],f=a(e,d),void(-1!==f&&e.splice(f,1))):void(g[c]=[])},trigger:function(a,c){var d,e,f=b(this);if(d=f[a])for(var g=0;g<d.length;g++)(e=d[g])(c)}},rb={instrument:!1};qb.mixin(rb);var sb;sb=Array.isArray?Array.isArray:function(a){return\"[object Array]\"===Object.prototype.toString.call(a)};var tb=sb,ub=Date.now||function(){return(new Date).getTime()},vb=Object.create||function(a){if(arguments.length>1)throw new Error(\"Second argument not supported\");if(\"object\"!=typeof a)throw new TypeError(\"Argument must be an object\");return g.prototype=a,new g},wb=[],xb=i,yb=void 0,zb=1,Ab=2,Bb=new w,Cb=new w,Db=B;B.prototype._validateInput=function(a){return tb(a)},B.prototype._validationError=function(){return new Error(\"Array Methods must be provided an Array\")},B.prototype._init=function(){this._result=new Array(this.length)},B.prototype._enumerate=function(){for(var a=this.length,b=this.promise,c=this._input,d=0;b._state===yb&&a>d;d++)this._eachEntry(c[d],d)},B.prototype._eachEntry=function(a,b){var c=this._instanceConstructor;f(a)?a.constructor===c&&a._state!==yb?(a._onError=null,this._settledAt(a._state,b,a._result)):this._willSettleAt(c.resolve(a),b):(this._remaining--,this._result[b]=this._makeResult(zb,b,a))},B.prototype._settledAt=function(a,b,c){var d=this.promise;d._state===yb&&(this._remaining--,this._abortOnReject&&a===Ab?t(d,c):this._result[b]=this._makeResult(a,b,c)),0===this._remaining&&s(d,this._result)},B.prototype._makeResult=function(a,b,c){return c},B.prototype._willSettleAt=function(a,b){var c=this;u(a,void 0,function(a){c._settledAt(zb,b,a)},function(a){c._settledAt(Ab,b,a)})};var Eb=C,Fb=D,Gb=E,Hb=F,Ib=\"rsvp_\"+ub()+\"-\",Jb=0,Kb=I;I.cast=Gb,I.all=Eb,I.race=Fb,I.resolve=Gb,I.reject=Hb,I.prototype={constructor:I,_guidKey:Ib,_onError:function(a){rb.async(function(b){setTimeout(function(){b._onError&&rb.trigger(\"error\",a)},0)},this)},then:function(a,b,c){var d=this,e=d._state;if(e===zb&&!a||e===Ab&&!b)return rb.instrument&&xb(\"chained\",this,this),this;d._onError=null;var f=new this.constructor(k,c),g=d._result;if(rb.instrument&&xb(\"chained\",d,f),e){var h=arguments[e-1];rb.async(function(){y(e,f,h,g)})}else u(d,f,a,b);return f},\"catch\":function(a,b){return this.then(null,a,b)},\"finally\":function(a,b){var c=this.constructor;return this.then(function(b){return c.resolve(a()).then(function(){return b})},function(b){return c.resolve(a()).then(function(){throw b})},b)}};var Lb=new J,Mb=new J,Nb=P,Ob=T;U.prototype=vb(Db.prototype),U.prototype._superConstructor=Db,U.prototype._makeResult=A,U.prototype._validationError=function(){return new Error(\"allSettled must be called with an array\")};var Pb=V,Qb=W,Rb=X;X.prototype=vb(Db.prototype),X.prototype._superConstructor=Db,X.prototype._init=function(){this._result={}},X.prototype._validateInput=function(a){return a&&\"object\"==typeof a},X.prototype._validationError=function(){return new Error(\"Promise.hash must be called with an object\")},X.prototype._enumerate=function(){var a=this.promise,b=this._input,c=[];for(var d in b)a._state===yb&&b.hasOwnProperty(d)&&c.push({position:d,entry:b[d]});var e=c.length;this._remaining=e;for(var f,g=0;a._state===yb&&e>g;g++)f=c[g],this._eachEntry(f.entry,f.position)};var Sb=Y;Z.prototype=vb(Rb.prototype),Z.prototype._superConstructor=Db,Z.prototype._makeResult=A,Z.prototype._validationError=function(){return new Error(\"hashSettled must be called with an object\")};var Tb,Ub=$,Vb=_,Wb=ab,Xb=bb,Yb=cb,Zb=db,$b=eb,_b=0,ac=fb,bc=\"undefined\"!=typeof window?window:void 0,cc=bc||{},dc=cc.MutationObserver||cc.WebKitMutationObserver,ec=\"undefined\"!=typeof process&&\"[object process]\"==={}.toString.call(process),fc=\"undefined\"!=typeof Uint8ClampedArray&&\"undefined\"!=typeof importScripts&&\"undefined\"!=typeof MessageChannel,gc=new Array(1e3);if(Tb=ec?gb():dc?ib():fc?jb():void 0===bc&&\"function\"==typeof require?mb():kb(),rb.async=ac,\"undefined\"!=typeof window&&\"object\"==typeof window.__PROMISE_INSTRUMENTATION__){var hc=window.__PROMISE_INSTRUMENTATION__;c(\"instrument\",!0);for(var ic in hc)hc.hasOwnProperty(ic)&&ob(ic,hc[ic])}var jc={race:Qb,Promise:Kb,allSettled:Pb,hash:Sb,hashSettled:Ub,denodeify:Nb,on:ob,off:pb,map:Xb,filter:$b,resolve:Yb,reject:Zb,all:Ob,rethrow:Vb,defer:Wb,EventTarget:qb,configure:c,async:nb};\"function\"==typeof define&&define.amd?define(function(){return jc}):\"undefined\"!=typeof module&&module.exports?module.exports=jc:\"undefined\"!=typeof this&&(this.RSVP=jc)}).call(this),function(a,b){\"use strict\";var c=b.head||b.getElementsByTagName(\"head\")[0],d=\"basket-\",e=5e3,f=[],g=function(a,b){try{return localStorage.setItem(d+a,JSON.stringify(b)),!0}catch(c){if(c.name.toUpperCase().indexOf(\"QUOTA\")>=0){var e,f=[];for(e in localStorage)0===e.indexOf(d)&&f.push(JSON.parse(localStorage[e]));return f.length?(f.sort(function(a,b){return a.stamp-b.stamp}),basket.remove(f[0].key),g(a,b)):void 0}return}},h=function(a){var b=new RSVP.Promise(function(b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.onreadystatechange=function(){4===d.readyState&&(200===d.status||0===d.status&&d.responseText?b({content:d.responseText,type:d.getResponseHeader(\"content-type\")}):c(new Error(d.statusText)))},setTimeout(function(){d.readyState<4&&d.abort()},basket.timeout),d.send()});return b},i=function(a){return h(a.url).then(function(b){var c=j(a,b);return a.skipCache||g(a.key,c),c})},j=function(a,b){var c=+new Date;return a.data=b.content,a.originalType=b.type,a.type=a.type||b.type,a.skipCache=a.skipCache||!1,a.stamp=c,a.expire=c+60*(a.expire||e)*60*1e3,a},k=function(a,b){return!a||a.expire-+new Date<0||b.unique!==a.unique||basket.isValidItem&&!basket.isValidItem(a,b)},l=function(a){var b,c,d;if(a.url)return a.key=a.key||a.url,b=basket.get(a.key),a.execute=a.execute!==!1,d=k(b,a),a.live||d?(a.unique&&(a.url+=(a.url.indexOf(\"?\")>0?\"&\":\"?\")+\"basket-unique=\"+a.unique),c=i(a),a.live&&!d&&(c=c.then(function(a){return a},function(){return b}))):(b.type=a.type||b.originalType,b.execute=a.execute,c=new RSVP.Promise(function(a){a(b)})),c},m=function(a){var d=b.createElement(\"script\");d.defer=!0,d.text=a.data,c.appendChild(d)},n={\"default\":m},o=function(a){return a.type&&n[a.type]?n[a.type](a):n[\"default\"](a)},p=function(a){return a.map(function(a){return a.execute&&o(a),a})},q=function(){var a,b,c=[];for(a=0,b=arguments.length;b>a;a++)c.push(l(arguments[a]));return RSVP.all(c)},r=function(){var a=q.apply(null,arguments),b=this.then(function(){return a}).then(p);return b.thenRequire=r,b};a.basket={require:function(){for(var a=0,b=arguments.length;b>a;a++)arguments[a].execute=arguments[a].execute!==!1,arguments[a].once&&f.indexOf(arguments[a].url)>=0?arguments[a].execute=!1:arguments[a].execute!==!1&&f.indexOf(arguments[a].url)<0&&f.push(arguments[a].url);var c=q.apply(null,arguments).then(p);return c.thenRequire=r,c},remove:function(a){return localStorage.removeItem(d+a),this},get:function(a){var b=localStorage.getItem(d+a);try{return JSON.parse(b||\"false\")}catch(c){return!1}},clear:function(a){var b,c,e=+new Date;for(b in localStorage)c=b.split(d)[1],c&&(!a||this.get(c).expire<=e)&&this.remove(c);return this},isValidItem:null,timeout:5e3,addHandler:function(a,b){Array.isArray(a)||(a=[a]),a.forEach(function(a){n[a]=b})},removeHandler:function(a){basket.addHandler(a,void 0)}},basket.clear(!0)}(this,document);\n//# sourceMappingURL=basket.full.min.js.map"

/***/ },
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Georgia Tech Research Corporation
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//    http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// This software was created as part of a research project at the
	// Augmented Environments Lab at Georgia Tech.  To support our research, we
	// request that if you make use of this software, you let us know how
	// you used it by sending mail to Blair MacIntyre (blair@cc.gatech.edu).
	//

	'use strict';

	var _Object$defineProperty = __webpack_require__(59)['default'];

	var _interopRequireDefault = __webpack_require__(9)['default'];

	var _bluebird = __webpack_require__(17);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	window.__ARGON_CHANNEL = true;
	var Argon = module.exports = __webpack_require__(152);

	// Let Argon Channel Manager know that this is an Argon channel (vs a regular webpage).
	if (document.readyState === 'complete') {
	  notifyParent();
	} else {
	  window.addEventListener('load', function load() {
	    notifyParent();
	  }, false);
	}

	function notifyParent() {
	  window.parent.postMessage({
	    ARGON_URL: window.location.href,
	    ARGON_VERSION_STRING: Argon.version
	  }, '*');
	}

	var _channelHasFocus = false;
	_Object$defineProperty(Argon, 'channelHasFocus', {
	  get: function get() {
	    return _channelHasFocus;
	  }
	});

	function _setFocus(bool) {
	  if (bool && !_channelHasFocus) {
	    _channelHasFocus = true;
	    Argon.emit('focus');
	  } else if (!bool && _channelHasFocus) {
	    _channelHasFocus = false;
	    Argon.emit('blur');
	  }
	}

	Argon.managerPort.on('focus', function () {
	  _setFocus(true);
	});

	Argon.managerPort.on('blur', function () {
	  _setFocus(false);
	});

	Argon.managerPort.whenConnected.then(function (e) {
	  _setFocus(e.focus);
	  Argon.emit('connect');
	}).timeout(500)['catch'](function (error) {
	  if (!Argon.Platform.isRunningInArgonApp && !Argon.managerPort.isConnected) _setFocus(true);
	});

/***/ }
/******/ ])
});
;